Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\build.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\examples\log.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\examples\ls-tree.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\commitgraph\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\commitgraph\verify.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\corpus\db.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\corpus\engine.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\corpus\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\corpus\run.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\corpus\trace.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\discover.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\hours\core.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\hours\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\hours\util.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\index\checkout.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\index\information.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\index\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\mailmap.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\net.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\organize.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\pack\create.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\pack\explode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\pack\index.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\pack\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\pack\multi_index.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\pack\receive.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\pack\verify.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\query\db.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\query\engine\command.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\query\engine\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\query\engine\update.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\query\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\archive.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\attributes\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\attributes\query.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\attributes\validate_baseline.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\clean.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\clone.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\commit.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\commitgraph\list.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\commitgraph\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\commitgraph\verify.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\config.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\credential.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\dirty.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\exclude.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\fetch.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\fsck.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\index\entries.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\index\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\mailmap.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\odb.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\remote.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\revision\explain.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\revision\list.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\revision\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\revision\previous_branches.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\revision\resolve.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\status.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\submodule.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\tree.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gitoxide-core\src\repository\verify.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\examples\clone.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: main,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\examples\clone.rs

Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\examples\init-repo-and-commit.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\examples\interrupt-handler-allows-graceful-shutdown.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\examples\reversible-interrupt-handlers.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\examples\stats.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\attribute_stack.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\clone\access.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\clone\checkout.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\clone\fetch\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\clone\fetch\util.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\clone\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\commit.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\cache\access.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\cache\incubate.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\cache\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\cache\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\cache\util.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\overrides.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\snapshot\access.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\snapshot\credential_helpers.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\snapshot\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\snapshot\_impls.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\keys.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\author.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\branch.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\checkout.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\clone.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\committer.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\core.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\credential.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\diff.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\extensions.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\fetch.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\gitoxide.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\http.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\index.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\mailmap.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\pack.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\protocol.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\push.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\remote.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\safe.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\ssh.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\status.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\url.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\sections\user.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\config\tree\traits.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\create.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\diff.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\dirwalk\iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\dirwalk\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\dirwalk\options.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\discover.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\env.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\ext\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\ext\object_id.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\ext\reference.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\ext\rev_spec.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\ext\tree.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\filter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\head\log.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\head\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\head\peel.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\id.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\interrupt.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: deregister,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\interrupt.rs

Found method with unsafe block in deregister:
File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\interrupt.rs
Start Line: 32, End Line: 59
/// Remove all previously registered handlers, and assure the default behaviour is reinstated, if this is the last available instance.
///
/// Note that only the instantiation of the default behaviour can fail.
pub fn deregister(self) -> std::io::Result<()> {
    let mut hooks = REGISTERED_HOOKS.lock();
    let count = DEREGISTER_COUNT.fetch_sub(1, Ordering::SeqCst);
    if count > 1 || hooks.is_empty() {
        return Ok(());
    }
    if self.do_reset {
        super::reset();
    }
    for (_, hook_id) in hooks.iter() {
        signal_hook::low_level::unregister(*hook_id);
    }
    let hooks = hooks.drain(..);
    let mut default_hooks = DEFAULT_BEHAVIOUR_HOOKS.lock();
    for (sig, _) in hooks {
        #[allow(unsafe_code)]
        unsafe {
            default_hooks
                .push(
                    signal_hook::low_level::register(
                        sig,
                        move || {
                            signal_hook::low_level::emulate_default_handler(sig).ok();
                        },
                    )?,
                );
        }
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: init_handler,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\interrupt.rs

Found function with unsafe block in init_handler:
File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\interrupt.rs
Start Line: 95, End Line: 144
/// Initialize a signal handler to listen to SIGINT and SIGTERM and trigger our [`trigger()`](super::trigger()) that way.
/// Also trigger `interrupt()` which promises to never use a Mutex, allocate or deallocate, or do anything else that's blocking.
/// Use `grace_count` to determine how often the termination signal can be received before it's terminal, e.g. 1 would only terminate
/// the application the second time the signal is received.
/// Note that only the `grace_count` and `interrupt` of the first call are effective, all others will be ignored.
///
/// Use the returned `Deregister` type to explicitly deregister hooks, or to do so automatically.
///
/// # Note
///
/// It will abort the process on second press and won't inform the user about this behaviour either as we are unable to do so without
/// deadlocking even when trying to write to stderr directly.
///
/// SAFETY: `interrupt()` will be called from a signal handler. See [`signal_hook::low_level::register()`] for details about.
#[allow(unsafe_code, clippy::missing_safety_doc)]
pub unsafe fn init_handler(
    grace_count: usize,
    interrupt: impl Fn() + Send + Sync + Clone + 'static,
) -> io::Result<Deregister> {
    let prev_count = DEREGISTER_COUNT.fetch_add(1, Ordering::SeqCst);
    if prev_count != 0 {
        let _guard = REGISTERED_HOOKS.lock();
        return Ok(Deregister::default());
    }
    let mut guard = REGISTERED_HOOKS.lock();
    if !guard.is_empty() {
        return Ok(Deregister::default());
    }
    let mut hooks = Vec::with_capacity(signal_hook::consts::TERM_SIGNALS.len());
    for sig in signal_hook::consts::TERM_SIGNALS {
        let interrupt = interrupt.clone();
        let action = move || {
            static INTERRUPT_COUNT: AtomicUsize = AtomicUsize::new(0);
            if !super::is_triggered() {
                INTERRUPT_COUNT.store(0, Ordering::SeqCst);
            }
            let msg_idx = INTERRUPT_COUNT.fetch_add(1, Ordering::SeqCst);
            if msg_idx == grace_count {
                gix_tempfile::registry::cleanup_tempfiles_signal_safe();
                signal_hook::low_level::emulate_default_handler(*sig).ok();
            }
            interrupt();
            super::trigger();
        };
        #[allow(unsafe_code)]
        unsafe {
            let hook_id = signal_hook::low_level::register(*sig, action)?;
            hooks.push((*sig, hook_id));
        }
    }
    for hook_id in DEFAULT_BEHAVIOUR_HOOKS.lock().drain(..) {
        signal_hook::low_level::unregister(hook_id);
    }
    gix_tempfile::signal::setup(gix_tempfile::signal::handler::Mode::None);
    *guard = hooks;
    Ok(Deregister::default())
}



Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\mailmap.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\object\blob.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\object\commit.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\object\errors.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\object\impls.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\object\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\object\peel.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\object\tag.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\object\tree\diff\change.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\object\tree\diff\for_each.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\object\tree\diff\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\object\tree\iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\object\tree\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\object\tree\traverse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\open\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\open\options.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\open\permissions.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\open\repository.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\path.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\pathspec.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\prelude.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\progress.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\push.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\reference\edits.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\reference\errors.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\reference\iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\reference\log.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\reference\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\reference\remote.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\access.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\build.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\connect.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\connection\access.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\connection\fetch\config.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\connection\fetch\error.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\connection\fetch\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\connection\fetch\negotiate.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\connection\fetch\receive_pack.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\connection\fetch\update_refs\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\connection\fetch\update_refs\tests.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\connection\fetch\update_refs\update.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\connection\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\connection\ref_map.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\errors.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\fetch.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\name.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\save.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\url\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\url\rewrite.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\remote\url\scheme_permission.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\attributes.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\cache.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\config\branch.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\config\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\config\remote.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\config\transport.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\diff.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\dirwalk.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\filter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\graph.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\identity.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\impls.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\index.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\kind.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\location.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\mailmap.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\object.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\pathspec.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\permissions.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\reference.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\remote.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\revision.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\shallow.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\state.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\submodule.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\thread_safe.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\repository\worktree.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\revision\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\revision\spec\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\revision\spec\parse\delegate\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\revision\spec\parse\delegate\navigate.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\revision\spec\parse\delegate\revision.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\revision\spec\parse\error.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\revision\spec\parse\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\revision\spec\parse\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\revision\walk.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\shallow.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\state.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\status\index_worktree.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\status\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\status\platform.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\submodule\errors.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\submodule\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\tag.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\util.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\worktree\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\src\worktree\proxy.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\clone\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\commit\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\config\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\config\tree.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\diff\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\gix-init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\gix.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\head\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\id\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\init\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\interrupt.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\object\blob.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\object\commit.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\object\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\object\tree\diff.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\object\tree\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\reference\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\reference\remote.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\remote\connect.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\remote\fetch.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\remote\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\remote\ref_map.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\remote\save.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\repository\config\config_snapshot\credential_helpers.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\repository\config\config_snapshot\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\repository\config\identity.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\repository\config\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\repository\config\remote.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\repository\config\transport_options.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\repository\excludes.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\repository\filter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\repository\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\repository\object.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\repository\open.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\repository\pathspec.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\repository\reference.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\repository\remote.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\repository\shallow.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\repository\state.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\repository\submodule.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\repository\worktree.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\revision\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\revision\spec\from_bytes\ambiguous.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\revision\spec\from_bytes\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\revision\spec\from_bytes\peel.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\revision\spec\from_bytes\reflog.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\revision\spec\from_bytes\regex.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\revision\spec\from_bytes\traverse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\revision\spec\from_bytes\util.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\revision\spec\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\status\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\submodule\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix\tests\util\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-actor\src\identity.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-actor\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-actor\src\signature\decode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-actor\src\signature\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-actor\tests\actor.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-actor\tests\identity\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-actor\tests\signature\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-archive\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-archive\src\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-archive\tests\archive.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\fuzz\fuzz_targets\fuzz_search.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\assignment.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\name.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\search\attributes.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\search\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\search\outcome.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\search\refmap.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\source.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\state.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: from_bytes,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\state.rs

Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\tests\assignment\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\tests\attributes.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\tests\parse\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\tests\search\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\tests\state\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-bitmap\src\ewah.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-bitmap\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-blame\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-blame\tests\blame.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-chunk\src\file\decode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-chunk\src\file\index.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-chunk\src\file\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-chunk\src\file\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-chunk\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-command\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-command\tests\command.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-commitgraph\fuzz\fuzz_targets\fuzz_file.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-commitgraph\src\access.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-commitgraph\src\file\access.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-commitgraph\src\file\commit.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-commitgraph\src\file\init.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: try_from,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-commitgraph\src\file\init.rs

Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-commitgraph\src\file\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-commitgraph\src\file\verify.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-commitgraph\src\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-commitgraph\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-commitgraph\src\verify.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-commitgraph\tests\access\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-commitgraph\tests\commitgraph.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\benches\large_config_file.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\fuzz\fuzz_targets\fuzz_file.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\fuzz\fuzz_targets\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\access\comfort.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\access\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\access\mutate.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\access\raw.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\access\read_only.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\impls.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\includes\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\includes\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\init\comfort.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\init\from_env.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\init\from_paths.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\init\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\init\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\meta.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\mutable\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\mutable\multi_value.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\mutable\section.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\mutable\value.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\section\body.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\section\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\tests.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\util.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\file\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\key.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\lookup.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\parse\comment.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\parse\error.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\parse\event.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\parse\events.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\parse\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\parse\nom\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\parse\nom\tests.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\parse\section\header.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\parse\section\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\parse\section\unvalidated.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\parse\tests.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\source.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\value\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\src\value\normalize.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\config.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\access\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\access\mutate.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\access\raw\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\access\raw\raw_multi_value.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\access\raw\raw_value.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\access\raw\set_existing_raw_value.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\access\raw\set_raw_value.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\access\read_only.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\impls\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\init\comfort.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\init\from_env.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\init\from_paths\includes\conditional\gitdir\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\init\from_paths\includes\conditional\gitdir\util.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\init\from_paths\includes\conditional\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\init\from_paths\includes\conditional\onbranch.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\init\from_paths\includes\unconditional.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\init\from_paths\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\init\from_str.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\init\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\mutable\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\mutable\multi_value.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\mutable\section.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\mutable\value.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\resolve_includes.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\file\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\key\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\mem.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\parse\error.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\parse\from_bytes.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\parse\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\parse\section.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\source\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\value\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config\tests\value\normalize.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config-value\fuzz\fuzz_targets\fuzz_value.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config-value\src\boolean.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config-value\src\color.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config-value\src\integer.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config-value\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config-value\src\path.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: home_for_user,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config-value\src\path.rs

-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: home_for_user,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config-value\src\path.rs

Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config-value\src\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config-value\tests\value\boolean.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config-value\tests\value\color.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config-value\tests\value\integer.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config-value\tests\value\main.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-config-value\tests\value\path.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\examples\custom-helper.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\examples\git-credential-lite.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\examples\invoke-git-credential.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\src\helper\cascade.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\src\helper\invoke.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\src\helper\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\src\program\main.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\src\program\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\src\protocol\context\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\src\protocol\context\serde.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\src\protocol\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\tests\credentials.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\tests\helper\cascade.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\tests\helper\context.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\tests\helper\invoke.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\tests\helper\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\tests\program\from_custom_definition.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\tests\program\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\tests\protocol\context.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-credentials\tests\protocol\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-date\fuzz\fuzz_targets\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-date\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-date\src\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-date\src\time\format.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-date\src\time\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-date\src\time\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-date\src\time\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-date\tests\date.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-date\tests\time\baseline.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-date\tests\time\format.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-date\tests\time\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-date\tests\time\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-diff\src\blob\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-diff\src\blob\pipeline.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-diff\src\blob\platform.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-diff\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-diff\src\rewrites\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-diff\src\rewrites\tracker.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-diff\src\tree\changes.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-diff\src\tree\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-diff\src\tree\recorder.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-diff\src\tree\visit.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-diff\tests\blob\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-diff\tests\blob\pipeline.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-diff\tests\blob\platform.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-diff\tests\diff.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-diff\tests\rewrites\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-diff\tests\rewrites\tracker.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-diff\tests\tree\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-dir\src\entry.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-dir\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-dir\src\walk\classify.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-dir\src\walk\function.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-dir\src\walk\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-dir\src\walk\readdir.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-dir\tests\dir.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-dir\tests\dir_walk_cwd.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-dir\tests\walk\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-dir\tests\walk_utils\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-discover\src\is.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-discover\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-discover\src\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-discover\src\path.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-discover\src\repository.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-discover\src\upwards\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-discover\src\upwards\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-discover\src\upwards\util.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-discover\tests\discover.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-discover\tests\isolated.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-discover\tests\is_git\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-discover\tests\parse\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-discover\tests\path\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-discover\tests\upwards\ceiling_dirs.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-discover\tests\upwards\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\cache.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\decode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\fs.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\hash.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\interrupt.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\parallel\eager_iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\parallel\in_order.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\parallel\in_parallel.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: in_parallel_with_slice,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\parallel\in_parallel.rs

Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\parallel\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\parallel\reduce.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\parallel\serial.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\progress.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\threading.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\zlib\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\zlib\stream\deflate\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\zlib\stream\deflate\tests.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\zlib\stream\inflate.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\src\zlib\stream\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\tests\features.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\tests\hash.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\tests\parallel\in_order_iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\tests\parallel\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\tests\parallel_shared.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\tests\parallel_shared_threaded.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\tests\parallel_threaded.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\tests\pipe.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-features\tests\trace\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fetchhead\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\examples\arrow.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\driver\apply.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\driver\delayed.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\driver\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\driver\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\driver\process\client.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\driver\process\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\driver\process\server.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\driver\shutdown.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\eol\convert_to_git.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\eol\convert_to_worktree.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\eol\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\eol\utils.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\ident.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\pipeline\convert.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\pipeline\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\pipeline\util.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\worktree\encode_to_git.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: encode_to_git,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\worktree\encode_to_git.rs

Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\worktree\encode_to_worktree.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\worktree\encoding.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\src\worktree\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\tests\driver\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\tests\eol\convert_to_git.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\tests\eol\convert_to_worktree.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\tests\eol\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\tests\filter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\tests\ident\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\tests\pipeline\convert_to_git.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\tests\pipeline\convert_to_worktree.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\tests\pipeline\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-filter\tests\worktree\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fs\src\capabilities.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fs\src\dir\create.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fs\src\dir\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fs\src\dir\remove.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fs\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fs\src\read_dir.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fs\src\snapshot.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fs\src\stack.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fs\src\symlink.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fs\tests\capabilities\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fs\tests\current_dir.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fs\tests\dir\create.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fs\tests\dir\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fs\tests\dir\remove.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fs\tests\fs.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fs\tests\read_dir\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fs\tests\stack\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fsck\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fsck\tests\connectivity\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-fsck\tests\fsck.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-glob\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-glob\src\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-glob\src\pattern.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-glob\src\search\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-glob\src\search\pattern.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-glob\src\wildmatch.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-glob\tests\glob.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-glob\tests\parse\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-glob\tests\pattern\matching.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-glob\tests\pattern\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-glob\tests\search\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-glob\tests\search\pattern.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-glob\tests\wildmatch\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-hash\src\kind.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-hash\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-hash\src\object_id.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-hash\src\oid.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: try_from_bytes,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-hash\src\oid.rs

Found method with unsafe block in try_from_bytes:
File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-hash\src\oid.rs
Start Line: 78, End Line: 88
/// Try to create a shared object id from a slice of bytes representing a hash `digest`
#[inline]
pub fn try_from_bytes(digest: &[u8]) -> Result<&Self, Error> {
    match digest.len() {
        20 => {
            Ok(#[allow(unsafe_code)] unsafe { &*(digest as *const [u8] as *const oid) })
        }
        len => Err(Error::InvalidByteSliceLength(len)),
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: from_bytes,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-hash\src\oid.rs

Found method with unsafe block in from_bytes:
File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-hash\src\oid.rs
Start Line: 97, End Line: 102
/// Only from code that statically assures correct sizes using array conversions.
pub(crate) fn from_bytes(value: &[u8]) -> &Self {
    #[allow(unsafe_code)] unsafe { &*(value as *const [u8] as *const oid) }
}



Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-hash\src\prefix.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-hash\tests\hash.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-hash\tests\kind\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-hash\tests\object_id\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-hash\tests\oid\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-hash\tests\prefix\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-hashtable\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-hashtable\tests\hashtable.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ignore\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ignore\src\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ignore\src\search.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ignore\tests\ignore.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ignore\tests\parse\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ignore\tests\search\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\access\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\access\sparse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\decode\entries.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\decode\header.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\decode\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\entry\flags.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\entry\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\entry\mode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\entry\stat.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\entry\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\extension\decode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\extension\end_of_index_entry\decode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\extension\end_of_index_entry\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\extension\end_of_index_entry\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\extension\fs_monitor.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\extension\index_entry_offset_table.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\extension\iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\extension\link.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\extension\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\extension\resolve_undo.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\extension\sparse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\extension\tree\decode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\extension\tree\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\extension\tree\verify.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\extension\tree\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\extension\untracked_cache.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\file\init.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: at,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\file\init.rs

Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\file\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\file\verify.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\file\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\fs.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\verify.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\src\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\tests\index\access.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\tests\index\entry\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\tests\index\entry\mode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\tests\index\entry\stat.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\tests\index\entry\time.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\tests\index\file\access.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\tests\index\file\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\tests\index\file\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\tests\index\file\read.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\tests\index\file\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\tests\index\fs.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\tests\index\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\tests\index\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-index\tests\integrate.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-lfs\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-lock\src\acquire.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-lock\src\commit.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-lock\src\file.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-lock\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-lock\tests\all.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-lock\tests\lock\file.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-lock\tests\lock\marker.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-lock\tests\lock\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-macros\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-macros\src\momo.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-macros\tests\macros.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-macros\tests\momo\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-macros\tests\momo\ux\error_if_ineffective.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-macros\tests\momo\ux\error_on_struct.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-mailmap\src\entry.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-mailmap\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-mailmap\src\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-mailmap\src\snapshot\entry.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-mailmap\src\snapshot\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-mailmap\src\snapshot\signature.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-mailmap\src\snapshot\util.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-mailmap\tests\mailmap.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-mailmap\tests\parse\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-mailmap\tests\snapshot\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-negotiate\src\consecutive.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-negotiate\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-negotiate\src\noop.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-negotiate\src\skipping.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-negotiate\tests\baseline\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-negotiate\tests\negotiate.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-note\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\benches\decode_objects.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\fuzz\fuzz_targets\fuzz_commit.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\fuzz\fuzz_targets\fuzz_tag.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\fuzz\fuzz_targets\fuzz_tree.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\blob.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\commit\decode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\commit\message\body.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\commit\message\decode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\commit\message\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\commit\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\commit\ref_iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\commit\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\data.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\encode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\find.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\kind.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\object\convert.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\object\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\tag\decode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\tag\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\tag\ref_iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\tag\write\tests.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\tag\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\traits.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\tree\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\tree\ref_iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\src\tree\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\tests\commit\from_bytes.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\tests\commit\iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\tests\commit\message.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\tests\commit\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\tests\encode\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\tests\object.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\tests\object_ref\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\tests\tag\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-object\tests\tree\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\alternate\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\alternate\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\cache.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\find.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\sink.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\dynamic\access.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\dynamic\find.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\dynamic\handle.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\dynamic\header.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\dynamic\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\dynamic\iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\dynamic\load_index.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\dynamic\load_one.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\dynamic\metrics.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\dynamic\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\dynamic\prefix.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\dynamic\structure.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\dynamic\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\dynamic\verify.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\dynamic\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\loose\find.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\loose\iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\loose\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\loose\verify.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\loose\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\store_impls\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\src\traits.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\tests\integrate.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\tests\odb\alternate\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\tests\odb\find\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\tests\odb\header\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\tests\odb\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\tests\odb\regression\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\tests\odb\sink\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\tests\odb\store\compound.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\tests\odb\store\dynamic.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\tests\odb\store\linked.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\tests\odb\store\loose.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-odb\tests\odb\store\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\bundle\find.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\bundle\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\bundle\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\bundle\write\error.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\bundle\write\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\bundle\write\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\cache\delta\from_offsets.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\cache\delta\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\cache\delta\traverse\mod.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: traverse,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\cache\delta\traverse\mod.rs

Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\cache\delta\traverse\resolve.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: into_child_iter,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\cache\delta\traverse\resolve.rs

-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: into_child_iter,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\cache\delta\traverse\resolve.rs

-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: deltas,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\cache\delta\traverse\resolve.rs

Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\cache\delta\traverse\util.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: get_mut,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\cache\delta\traverse\util.rs

Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\cache\delta\tree.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\cache\lru.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\cache\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\cache\object.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\delta.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\entry\decode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\entry\header.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\entry\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\file\decode\entry.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\file\decode\header.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\file\decode\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\file\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\file\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\file\verify.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\header.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\input\bytes_to_entries.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\input\entries_to_bytes.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\input\entry.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\input\lookup_ref_delta_objects.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\input\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\input\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\output\bytes.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\output\count\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\output\count\objects\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\output\count\objects\reduce.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\output\count\objects\tree.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\output\count\objects\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\output\count\objects\util.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\output\entry\iter_from_counts.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\output\entry\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\data\output\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\find.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\find_traits.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\index\access.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\index\encode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\index\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\index\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\index\traverse\error.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\index\traverse\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\index\traverse\reduce.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\index\traverse\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\index\traverse\with_index.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\index\traverse\with_lookup.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\index\util.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\index\verify.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\index\write\error.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\index\write\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\lib.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: read_only,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\lib.rs

Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\multi_index\access.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\multi_index\chunk.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\multi_index\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\multi_index\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\multi_index\verify.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\multi_index\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\src\verify.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\tests\integrate.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\tests\pack\bundle.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\tests\pack\data\file.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\tests\pack\data\header.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\tests\pack\data\input.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\tests\pack\data\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\tests\pack\data\output\count_and_entries.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\tests\pack\data\output\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\tests\pack\index.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\tests\pack\iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\tests\pack\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\tests\pack\multi_index\access.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\tests\pack\multi_index\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\tests\pack\multi_index\verify.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pack\tests\pack\multi_index\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\src\decode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\src\encode\async_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\src\encode\blocking_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\src\encode\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\src\line\async_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\src\line\blocking_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\src\line\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\src\read\async_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\src\read\blocking_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\src\read\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\src\read\sidebands\async_io.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: poll_fill_buf,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\src\read\sidebands\async_io.rs

Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\src\read\sidebands\blocking_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\src\read\sidebands\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\src\write\async_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\src\write\blocking_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\src\write\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\tests\async-packetline.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\tests\blocking-packetline.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\tests\decode\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\tests\encode\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\tests\read\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\tests\read\sideband.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline\tests\write\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline-blocking\src\decode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline-blocking\src\encode\async_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline-blocking\src\encode\blocking_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline-blocking\src\encode\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline-blocking\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline-blocking\src\line\async_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline-blocking\src\line\blocking_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline-blocking\src\line\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline-blocking\src\read\async_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline-blocking\src\read\blocking_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline-blocking\src\read\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline-blocking\src\read\sidebands\async_io.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: poll_fill_buf,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline-blocking\src\read\sidebands\async_io.rs

Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline-blocking\src\read\sidebands\blocking_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline-blocking\src\read\sidebands\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline-blocking\src\write\async_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline-blocking\src\write\blocking_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-packetline-blocking\src\write\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-path\src\convert.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-path\src\env\git\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-path\src\env\git\tests.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: current,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-path\src\env\git\tests.rs

Found method with unsafe block in current:
File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-path\src\env\git\tests.rs
Start Line: 182, End Line: 199
fn current() -> WindowsResult<Self> {
    let mut wow64process = BOOL::default();
    unsafe { IsWow64Process(GetCurrentProcess(), &mut wow64process)? };
    let platform_architecture = if wow64process.as_bool() {
        Self::Is32on64
    } else if cfg!(target_pointer_width = "32") {
        Self::Is32on32
    } else {
        assert!(cfg!(target_pointer_width = "64"));
        Self::Is64on64
    };
    Ok(platform_architecture)
}



Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-path\src\env\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-path\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-path\src\realpath.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-path\src\util.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-path\tests\convert\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-path\tests\convert\normalize.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-path\tests\path.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-path\tests\realpath\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-path\tests\util\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pathspec\fuzz\fuzz_targets\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pathspec\src\defaults.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pathspec\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pathspec\src\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pathspec\src\pattern.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pathspec\src\search\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pathspec\src\search\matching.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pathspec\src\search\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pathspec\tests\defaults.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pathspec\tests\normalize\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pathspec\tests\parse\invalid.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pathspec\tests\parse\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pathspec\tests\parse\valid.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pathspec\tests\pathspec.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-pathspec\tests\search\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-prompt\examples\askpass.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-prompt\examples\credentials.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-prompt\examples\use-askpass.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-prompt\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-prompt\src\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-prompt\src\unix.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-prompt\tests\options\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-prompt\tests\prompt.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\command\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\command\tests.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\fetch\arguments\async_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\fetch\arguments\blocking_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\fetch\arguments\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\fetch\delegate.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\fetch\error.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\fetch\handshake.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\fetch\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\fetch\response\async_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\fetch\response\blocking_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\fetch\response\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\fetch\tests.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\fetch_fn.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\handshake\function.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\handshake\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\handshake\refs\async_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\handshake\refs\blocking_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\handshake\refs\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\handshake\refs\shared.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\handshake\refs\tests.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: project_inner,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\handshake\refs\tests.rs

Found method with unsafe block in project_inner:
File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\handshake\refs\tests.rs
Start Line: 200, End Line: 205
fn project_inner(self: std::pin::Pin<&mut Self>) -> std::pin::Pin<&mut &'a [u8]> {
    #[allow(unsafe_code)] unsafe { std::pin::Pin::new(&mut self.get_unchecked_mut().0) }
}



Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\ls_refs.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\remote_progress.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\src\util.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\tests\async-protocol.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\tests\blocking-protocol.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\tests\fetch\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\tests\fetch\response.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\tests\fetch\v1.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\tests\fetch\v2.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-protocol\tests\remote_progress\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-quote\src\ansi_c.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-quote\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-quote\src\single.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-quote\tests\quote.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-rebase\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\fuzz\fuzz_targets\fuzz_log.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\fuzz\fuzz_targets\fuzz_names.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\fuzz\fuzz_targets\fuzz_packed_buffer.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\fullname.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\log.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\name.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: new_unchecked,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\name.rs

Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\namespace.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\peel.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\raw.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\file\find.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\file\log\iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\file\log\line.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\file\log\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\file\loose\iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\file\loose\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\file\loose\reference\decode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\file\loose\reference\logiter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\file\loose\reference\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\file\loose\reflog\create_or_update\tests.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\file\loose\reflog.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\file\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\file\overlay_iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\file\packed.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\file\raw_ext.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\file\transaction\commit.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\file\transaction\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\file\transaction\prepare.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\general\handle\find.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\general\handle\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\general\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\general\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\packed\buffer.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: open,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\packed\buffer.rs

Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\packed\decode\tests.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\packed\decode.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\packed\find.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\packed\iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\packed\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\store\packed\transaction.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\target.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\transaction\ext.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\src\transaction\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\file\log.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\file\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\file\reference.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\file\store\access.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\file\store\find.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\file\store\iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\file\store\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\file\store\reflog.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\file\transaction\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\file\transaction\prepare_and_commit\create_or_update\collisions.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\file\transaction\prepare_and_commit\create_or_update\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\file\transaction\prepare_and_commit\delete.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\file\worktree.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\fullname\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\namespace\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\packed\find.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\packed\iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\packed\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\packed\open.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\reference\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\refs.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\store\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-ref\tests\transaction\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\fuzz\fuzz_targets\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\src\instruction.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\src\match_group\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\src\match_group\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\src\match_group\util.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\src\match_group\validate.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\src\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\src\spec.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\src\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\src\write.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\tests\impls\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\tests\matching\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\tests\match_group\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\tests\parse\fetch.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\tests\parse\invalid.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\tests\parse\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\tests\parse\push.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\tests\refspec.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\tests\spec\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-refspec\tests\write\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\fuzz\fuzz_targets\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\src\describe.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\src\spec\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\src\spec\parse\delegate.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\src\spec\parse\function.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: long_describe_prefix,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\src\spec\parse\function.rs

Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\src\spec\parse\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\tests\describe\format.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\tests\describe\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\tests\revision.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\tests\spec\display.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\tests\spec\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\tests\spec\parse\anchor\at_symbol.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\tests\spec\parse\anchor\colon_symbol.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\tests\spec\parse\anchor\describe.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\tests\spec\parse\anchor\hash.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\tests\spec\parse\anchor\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\tests\spec\parse\anchor\refnames.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\tests\spec\parse\kind.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\tests\spec\parse\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\tests\spec\parse\navigate\caret_symbol.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\tests\spec\parse\navigate\colon_symbol.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\tests\spec\parse\navigate\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revision\tests\spec\parse\navigate\tilde_symbol.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revwalk\src\graph\commit.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revwalk\src\graph\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revwalk\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revwalk\src\queue.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-revwalk\tests\revwalk.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-sec\src\identity.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-sec\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-sec\src\permission.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-sec\src\trust.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-sec\tests\identity\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-sec\tests\sec.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-sequencer\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-status\src\index_as_worktree\function.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-status\src\index_as_worktree\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-status\src\index_as_worktree\recorder.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-status\src\index_as_worktree\traits.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-status\src\index_as_worktree\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-status\src\index_as_worktree_with_renames\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-status\src\index_as_worktree_with_renames\recorder.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-status\src\index_as_worktree_with_renames\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-status\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-status\src\stack.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-status\tests\stack\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-status\tests\status\index_as_worktree.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-status\tests\status\index_as_worktree_with_renames.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-status\tests\status\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-status\tests\worktree.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-submodule\src\access.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-submodule\src\config.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-submodule\src\is_active_platform.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-submodule\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-submodule\tests\file\baseline.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-submodule\tests\file\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-submodule\tests\submodule.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-tempfile\examples\delete-tempfiles-on-sigterm-interactive.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-tempfile\examples\delete-tempfiles-on-sigterm.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-tempfile\examples\try-deadlock-on-cleanup.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-tempfile\src\forksafe.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-tempfile\src\handle.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-tempfile\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-tempfile\src\registry.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-tempfile\src\signal.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-tempfile\tests\all.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-tempfile\tests\registry.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-tempfile\tests\tempfile\handle.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-tempfile\tests\tempfile\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-tix\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-trace\src\disabled.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-trace\src\enabled.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-trace\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-trace\tests\trace.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\async_io\bufread_ext.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\async_io\connect.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\async_io\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\async_io\request.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\async_io\traits.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\blocking_io\bufread_ext.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\blocking_io\connect.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\blocking_io\file.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\blocking_io\http\curl\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\blocking_io\http\curl\remote.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\blocking_io\http\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\blocking_io\http\redirect.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\blocking_io\http\reqwest\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\blocking_io\http\reqwest\remote.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\blocking_io\http\traits.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\blocking_io\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\blocking_io\request.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\blocking_io\ssh\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\blocking_io\ssh\program_kind.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\blocking_io\ssh\tests.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\blocking_io\traits.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\capabilities.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\git\async_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\git\blocking_io.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\git\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\non_io_types.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\client\traits.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\tests\async-transport.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\tests\blocking-transport-http.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\tests\blocking-transport.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\tests\client\blocking_io\http\mock.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\tests\client\blocking_io\http\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\tests\client\blocking_io\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\tests\client\capabilities.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\tests\client\git.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-transport\tests\client\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-traverse\src\commit\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-traverse\src\commit\simple.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-traverse\src\commit\topo\init.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-traverse\src\commit\topo\iter.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-traverse\src\commit\topo\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-traverse\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-traverse\src\tree\breadthfirst.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-traverse\src\tree\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-traverse\src\tree\recorder.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-traverse\tests\commit\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-traverse\tests\commit\simple.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-traverse\tests\commit\topo.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-traverse\tests\traverse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-traverse\tests\tree\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-tui\src\main.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-url\fuzz\fuzz_targets\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-url\src\expand_path.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-url\src\impls.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-url\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-url\src\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-url\src\scheme.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-url\tests\access\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-url\tests\baseline.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-url\tests\expand_path\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-url\tests\fuzzed.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-url\tests\parse\file.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-url\tests\parse\http.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-url\tests\parse\invalid.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-url\tests\parse\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-url\tests\parse\ssh.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-url\tests\url.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-utils\src\backoff.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-utils\src\btoi.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-utils\src\buffers.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-utils\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-utils\src\str.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-utils\tests\backoff\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-utils\tests\btoi\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-utils\tests\buffers\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-utils\tests\str\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-utils\tests\utils.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-validate\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-validate\src\path.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-validate\src\reference.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-validate\src\submodule.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-validate\src\tag.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-validate\tests\path\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-validate\tests\reference\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-validate\tests\submodule\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-validate\tests\tag\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-validate\tests\validate.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree\src\stack\delegate.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree\src\stack\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree\src\stack\platform.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree\src\stack\state\attributes.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree\src\stack\state\ignore.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree\src\stack\state\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree\tests\integrate.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree\tests\worktree\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree\tests\worktree\stack\attributes.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree\tests\worktree\stack\create_directory.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree\tests\worktree\stack\ignore.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree\tests\worktree\stack\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree-state\src\checkout\chunk.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree-state\src\checkout\entry.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree-state\src\checkout\function.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree-state\src\checkout\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree-state\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree-state\tests\state\checkout.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree-state\tests\state\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree-state\tests\worktree.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree-stream\src\entry.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree-stream\src\from_tree\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree-stream\src\from_tree\traverse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree-stream\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree-stream\src\protocol.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-worktree-stream\tests\stream.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\src\ein.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\src\gix.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\src\plumbing\main.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: main,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\src\plumbing\main.rs

-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: main,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\src\plumbing\main.rs

Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\src\plumbing\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\src\plumbing\options\free.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\src\plumbing\options\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\src\plumbing\progress.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\src\porcelain\main.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: main,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\src\porcelain\main.rs

-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: main,  File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\src\porcelain\main.rs

Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\src\porcelain\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\src\porcelain\options.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\src\shared.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\src\uni.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\tests\tools\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\tests\tools\src\main.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\build.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\examples\mk_certs.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\aes.rs
-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: true, With_SAFETY_comment: false, Name: new_encrypt,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\aes.rs

Found method with unsafe block in new_encrypt:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\aes.rs
Start Line: 96, End Line: 112
/// Prepares a key for encryption.
///
/// # Failure
///
/// Returns an error if the key is not 128, 192, or 256 bits.
#[corresponds(AES_set_encrypt_key)]
pub fn new_encrypt(key: &[u8]) -> Result<AesKey, KeyError> {
    unsafe {
        assert!(key.len() <= c_int::MAX as usize / 8);
        let mut aes_key = MaybeUninit::uninit();
        let r = ffi::AES_set_encrypt_key(
            key.as_ptr() as *const _,
            key.len() as AesBitType * 8,
            aes_key.as_mut_ptr(),
        );
        if r == 0 { Ok(AesKey(aes_key.assume_init())) } else { Err(KeyError(())) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: true, With_SAFETY_comment: false, Name: new_decrypt,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\aes.rs

Found method with unsafe block in new_decrypt:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\aes.rs
Start Line: 120, End Line: 137
/// Prepares a key for decryption.
///
/// # Failure
///
/// Returns an error if the key is not 128, 192, or 256 bits.
#[corresponds(AES_set_decrypt_key)]
pub fn new_decrypt(key: &[u8]) -> Result<AesKey, KeyError> {
    unsafe {
        assert!(key.len() <= c_int::MAX as usize / 8);
        let mut aes_key = MaybeUninit::uninit();
        let r = ffi::AES_set_decrypt_key(
            key.as_ptr() as *const _,
            key.len() as AesBitType * 8,
            aes_key.as_mut_ptr(),
        );
        if r == 0 { Ok(AesKey(aes_key.assume_init())) } else { Err(KeyError(())) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: aes_ige,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\aes.rs

Found function with unsafe block in aes_ige:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\aes.rs
Start Line: 161, End Line: 180
/// Performs AES IGE encryption or decryption
///
/// AES IGE (Infinite Garble Extension) is a form of AES block cipher utilized in
/// OpenSSL.  Infinite Garble refers to propagating forward errors.  IGE, like other
/// block ciphers implemented for AES requires an initialization vector.  The IGE mode
/// allows a stream of blocks to be encrypted or decrypted without having the entire
/// plaintext available.  For more information, visit [AES IGE Encryption].
///
/// This block cipher uses 16 byte blocks.  The rust implementation will panic
/// if the input or output does not meet this 16-byte boundary.  Attention must
/// be made in this low level implementation to pad the value to the 128-bit boundary.
///
/// [AES IGE Encryption]: http://www.links.org/files/openssl-ige.pdf
///
/// # Panics
///
/// Panics if `in_` is not the same length as `out`, if that length is not a multiple of 16, or if
/// `iv` is not at least 32 bytes.
#[cfg(not(boringssl))]
#[cfg(not(osslconf = "OPENSSL_NO_DEPRECATED_3_0"))]
#[corresponds(AES_ige_encrypt)]
pub fn aes_ige(in_: &[u8], out: &mut [u8], key: &AesKey, iv: &mut [u8], mode: Mode) {
    unsafe {
        assert!(in_.len() == out.len());
        assert!(in_.len() % ffi::AES_BLOCK_SIZE as usize == 0);
        assert!(iv.len() >= ffi::AES_BLOCK_SIZE as usize * 2);
        let mode = match mode {
            Mode::Encrypt => ffi::AES_ENCRYPT,
            Mode::Decrypt => ffi::AES_DECRYPT,
        };
        ffi::AES_ige_encrypt(
            in_.as_ptr() as *const _,
            out.as_mut_ptr() as *mut _,
            in_.len(),
            &key.0,
            iv.as_mut_ptr() as *mut _,
            mode,
        );
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: true, With_SAFETY_comment: false, Name: wrap_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\aes.rs

Found function with unsafe block in wrap_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\aes.rs
Start Line: 196, End Line: 219
/// Wrap a key, according to [RFC 3394](https://tools.ietf.org/html/rfc3394)
///
/// * `key`: The key-encrypting-key to use. Must be a encrypting key
/// * `iv`: The IV to use. You must use the same IV for both wrapping and unwrapping
/// * `out`: The output buffer to store the ciphertext
/// * `in_`: The input buffer, storing the key to be wrapped
///
/// Returns the number of bytes written into `out`
///
/// # Panics
///
/// Panics if either `out` or `in_` do not have sizes that are a multiple of 8, or if
/// `out` is not 8 bytes longer than `in_`
#[corresponds(AES_wrap_key)]
pub fn wrap_key(
    key: &AesKey,
    iv: Option<[u8; 8]>,
    out: &mut [u8],
    in_: &[u8],
) -> Result<usize, KeyError> {
    unsafe {
        assert!(out.len() >= in_.len() + 8);
        let written = ffi::AES_wrap_key(
            &key.0 as *const _ as *mut _,
            iv.as_ref().map_or(ptr::null(), |iv| iv.as_ptr() as *const _),
            out.as_ptr() as *mut _,
            in_.as_ptr() as *const _,
            in_.len() as AesSizeType,
        );
        if written <= 0 { Err(KeyError(())) } else { Ok(written as usize) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: true, With_SAFETY_comment: false, Name: unwrap_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\aes.rs

Found function with unsafe block in unwrap_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\aes.rs
Start Line: 235, End Line: 259
/// Unwrap a key, according to [RFC 3394](https://tools.ietf.org/html/rfc3394)
///
/// * `key`: The key-encrypting-key to decrypt the wrapped key. Must be a decrypting key
/// * `iv`: The same IV used for wrapping the key
/// * `out`: The buffer to write the unwrapped key to
/// * `in_`: The input ciphertext
///
/// Returns the number of bytes written into `out`
///
/// # Panics
///
/// Panics if either `out` or `in_` do not have sizes that are a multiple of 8, or
/// if `in_` is not 8 bytes longer than `out`
#[corresponds(AES_unwrap_key)]
pub fn unwrap_key(
    key: &AesKey,
    iv: Option<[u8; 8]>,
    out: &mut [u8],
    in_: &[u8],
) -> Result<usize, KeyError> {
    unsafe {
        assert!(out.len() + 8 <= in_.len());
        let written = ffi::AES_unwrap_key(
            &key.0 as *const _ as *mut _,
            iv.as_ref().map_or(ptr::null(), |iv| iv.as_ptr() as *const _),
            out.as_ptr() as *mut _,
            in_.as_ptr() as *const _,
            in_.len() as AesSizeType,
        );
        if written <= 0 { Err(KeyError(())) } else { Ok(written as usize) }
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs
-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: fmt,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs

Found method with unsafe block in fmt:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs
Start Line: 70, End Line: 85
fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    unsafe {
        let mem_bio = match MemBio::new() {
            Err(_) => return f.write_str("error"),
            Ok(m) => m,
        };
        let print_result = cvt(
            ffi::ASN1_GENERALIZEDTIME_print(mem_bio.as_ptr(), self.as_ptr()),
        );
        match print_result {
            Err(_) => f.write_str("error"),
            Ok(_) => f.write_str(str::from_utf8_unchecked(mem_bio.get_buf())),
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: diff,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs

Found method with unsafe block in diff:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs
Start Line: 203, End Line: 214
/// Find difference between two times
#[corresponds(ASN1_TIME_diff)]
#[cfg(any(ossl102, boringssl))]
pub fn diff(&self, compare: &Self) -> Result<TimeDiff, ErrorStack> {
    let mut days = 0;
    let mut secs = 0;
    let other = compare.as_ptr();
    let err = unsafe { ffi::ASN1_TIME_diff(&mut days, &mut secs, self.as_ptr(), other) };
    match err {
        0 => Err(ErrorStack::get()),
        _ => Ok(TimeDiff { days, secs }),
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs
Start Line: 304, End Line: 311
#[corresponds(ASN1_TIME_new)]
fn new() -> Result<Asn1Time, ErrorStack> {
    ffi::init();
    unsafe {
        let handle = cvt_p(ffi::ASN1_TIME_new())?;
        Ok(Asn1Time::from_ptr(handle))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: from_period,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs

Found method with unsafe block in from_period:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs
Start Line: 314, End Line: 321
#[corresponds(X509_gmtime_adj)]
fn from_period(period: c_long) -> Result<Asn1Time, ErrorStack> {
    ffi::init();
    unsafe {
        let handle = cvt_p(ffi::X509_gmtime_adj(ptr::null_mut(), period))?;
        Ok(Asn1Time::from_ptr(handle))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: from_unix,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs

Found method with unsafe block in from_unix:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs
Start Line: 330, End Line: 337
/// Creates a new time from the specified `time_t` value
#[corresponds(ASN1_TIME_set)]
pub fn from_unix(time: time_t) -> Result<Asn1Time, ErrorStack> {
    ffi::init();
    unsafe {
        let handle = cvt_p(ffi::ASN1_TIME_set(ptr::null_mut(), time))?;
        Ok(Asn1Time::from_ptr(handle))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: from_str,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs

Found method with unsafe block in from_str:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs
Start Line: 342, End Line: 351
/// Creates a new time corresponding to the specified ASN1 time string.
#[corresponds(ASN1_TIME_set_string)]
#[allow(clippy::should_implement_trait)]
pub fn from_str(s: &str) -> Result<Asn1Time, ErrorStack> {
    unsafe {
        let s = CString::new(s).unwrap();
        let time = Asn1Time::new()?;
        cvt(ffi::ASN1_TIME_set_string(time.as_ptr(), s.as_ptr()))?;
        Ok(time)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: from_str_x509,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs

Found method with unsafe block in from_str_x509:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs
Start Line: 358, End Line: 367
/// Creates a new time corresponding to the specified X509 time string.
///
/// Requires BoringSSL or OpenSSL 1.1.1 or newer.
#[corresponds(ASN1_TIME_set_string_X509)]
#[cfg(any(ossl111, boringssl))]
pub fn from_str_x509(s: &str) -> Result<Asn1Time, ErrorStack> {
    unsafe {
        let s = CString::new(s).unwrap();
        let time = Asn1Time::new()?;
        cvt(ffi::ASN1_TIME_set_string_X509(time.as_ptr(), s.as_ptr()))?;
        Ok(time)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: true, With_SAFETY_comment: false, Name: as_utf8,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs

Found method with unsafe block in as_utf8:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs
Start Line: 440, End Line: 450
/// Converts the ASN.1 underlying format to UTF8
///
/// ASN.1 strings may utilize UTF-16, ASCII, BMP, or UTF8.  This is important to
/// consume the string in a meaningful way without knowing the underlying
/// format.
#[corresponds(ASN1_STRING_to_UTF8)]
pub fn as_utf8(&self) -> Result<OpensslString, ErrorStack> {
    unsafe {
        let mut ptr = ptr::null_mut();
        let len = ffi::ASN1_STRING_to_UTF8(&mut ptr, self.as_ptr());
        if len < 0 {
            return Err(ErrorStack::get());
        }
        Ok(OpensslString::from_ptr(ptr as *mut c_char))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: as_slice,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs

Found method with unsafe block in as_slice:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs
Start Line: 459, End Line: 461
/// Return the string as an array of bytes.
///
/// The bytes do not directly correspond to UTF-8 encoding.  To interact with
/// strings in rust, it is preferable to use [`as_utf8`]
///
/// [`as_utf8`]: struct.Asn1String.html#method.as_utf8
#[corresponds(ASN1_STRING_get0_data)]
pub fn as_slice(&self) -> &[u8] {
    unsafe { slice::from_raw_parts(ASN1_STRING_get0_data(self.as_ptr()), self.len()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: len,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs

Found method with unsafe block in len:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs
Start Line: 465, End Line: 467
/// Returns the number of bytes in the string.
#[corresponds(ASN1_STRING_length)]
pub fn len(&self) -> usize {
    unsafe { ffi::ASN1_STRING_length(self.as_ptr()) as usize }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: get,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs

Found method with unsafe block in get:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs
Start Line: 535, End Line: 537
#[allow(missing_docs, clippy::unnecessary_cast)]
#[deprecated(since = "0.10.6", note = "use to_bn instead")]
pub fn get(&self) -> i64 {
    unsafe { ffi::ASN1_INTEGER_get(self.as_ptr()) as i64 }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: to_bn,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs

Found method with unsafe block in to_bn:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs
Start Line: 541, End Line: 546
/// Converts the integer to a `BigNum`.
#[corresponds(ASN1_INTEGER_to_BN)]
pub fn to_bn(&self) -> Result<BigNum, ErrorStack> {
    unsafe {
        cvt_p(ffi::ASN1_INTEGER_to_BN(self.as_ptr(), ptr::null_mut()))
            .map(|p| BigNum::from_ptr(p))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs

Found method with unsafe block in set:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs
Start Line: 553, End Line: 555
/// Sets the ASN.1 value to the value of a signed 32-bit integer, for larger numbers
/// see [`bn`].
///
/// [`bn`]: ../bn/struct.BigNumRef.html#method.to_asn1_integer
#[corresponds(ASN1_INTEGER_set)]
pub fn set(&mut self, value: i32) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::ASN1_INTEGER_set(self.as_ptr(), value as c_long)).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: to_owned,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs

Found method with unsafe block in to_owned:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs
Start Line: 559, End Line: 561
/// Creates a new Asn1Integer with the same value.
#[corresponds(ASN1_INTEGER_dup)]
pub fn to_owned(&self) -> Result<Asn1Integer, ErrorStack> {
    unsafe {
        cvt_p(ffi::ASN1_INTEGER_dup(self.as_ptr())).map(|p| Asn1Integer::from_ptr(p))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: new_from_bytes,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs

Found method with unsafe block in new_from_bytes:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs
Start Line: 626, End Line: 633
/// Creates an Asn1OctetString from bytes
pub fn new_from_bytes(value: &[u8]) -> Result<Self, ErrorStack> {
    ffi::init();
    unsafe {
        let s = cvt_p(ffi::ASN1_OCTET_STRING_new())?;
        ffi::ASN1_OCTET_STRING_set(s, value.as_ptr(), value.len().try_into().unwrap());
        Ok(Self::from_ptr(s))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: nid,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs

Found method with unsafe block in nid:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs
Start Line: 711, End Line: 713
/// Returns the NID associated with this OID.
pub fn nid(&self) -> Nid {
    unsafe { Nid::from_raw(ffi::OBJ_obj2nid(self.as_ptr())) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: get_i64,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs

Found method with unsafe block in get_i64:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\asn1.rs
Start Line: 765, End Line: 774
/// Get the value, if it fits in the required bounds.
#[corresponds(ASN1_ENUMERATED_get_int64)]
#[cfg(ossl110)]
pub fn get_i64(&self) -> Result<i64, ErrorStack> {
    let mut crl_reason = 0;
    unsafe {
        cvt(ffi::ASN1_ENUMERATED_get_int64(&mut crl_reason, self.as_ptr()))?;
    }
    Ok(crl_reason)
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\base64.rs
-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: true, Name: encode_block,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\base64.rs

-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: true, Name: decode_block,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\base64.rs

Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bio.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: drop,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bio.rs

Found method with unsafe block in drop:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bio.rs
Start Line: 13, End Line: 17
fn drop(&mut self) {
    unsafe {
        ffi::BIO_free_all(self.0);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bio.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bio.rs
Start Line: 21, End Line: 33
pub fn new(buf: &'a [u8]) -> Result<MemBioSlice<'a>, ErrorStack> {
    ffi::init();
    assert!(buf.len() <= c_int::MAX as usize);
    let bio = unsafe {
        cvt_p(BIO_new_mem_buf(buf.as_ptr() as *const _, buf.len() as crate::SLenType))?
    };
    Ok(MemBioSlice(bio, PhantomData))
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: get_buf,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bio.rs

Found method with unsafe block in get_buf:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bio.rs
Start Line: 62, End Line: 68
pub fn get_buf(&self) -> &[u8] {
    unsafe {
        let mut ptr = ptr::null_mut();
        let len = ffi::BIO_get_mem_data(self.0, &mut ptr);
        slice::from_raw_parts(ptr as *const _ as *const _, len as usize)
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 105, End Line: 110
/// Returns a new `BigNumContext`.
#[corresponds(BN_CTX_new)]
pub fn new() -> Result<BigNumContext, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(ffi::BN_CTX_new()).map(BigNumContext)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: new_secure,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in new_secure:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 115, End Line: 120
/// Returns a new secure `BigNumContext`.
#[corresponds(BN_CTX_secure_new)]
#[cfg(ossl110)]
pub fn new_secure() -> Result<BigNumContext, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(ffi::BN_CTX_secure_new()).map(BigNumContext)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: clear,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in clear:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 162, End Line: 164
/// Erases the memory used by this `BigNum`, resetting its value to 0.
///
/// This can be used to destroy sensitive data such as keys when they are no longer needed.
#[corresponds(BN_clear)]
pub fn clear(&mut self) {
    unsafe { ffi::BN_clear(self.as_ptr()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: add_word,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in add_word:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 168, End Line: 170
/// Adds a `u32` to `self`.
#[corresponds(BN_add_word)]
pub fn add_word(&mut self, w: u32) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::BN_add_word(self.as_ptr(), w as ffi::BN_ULONG)).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sub_word,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in sub_word:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 174, End Line: 176
/// Subtracts a `u32` from `self`.
#[corresponds(BN_sub_word)]
pub fn sub_word(&mut self, w: u32) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::BN_sub_word(self.as_ptr(), w as ffi::BN_ULONG)).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: mul_word,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in mul_word:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 180, End Line: 182
/// Multiplies a `u32` by `self`.
#[corresponds(BN_mul_word)]
pub fn mul_word(&mut self, w: u32) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::BN_mul_word(self.as_ptr(), w as ffi::BN_ULONG)).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: div_word,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in div_word:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 187, End Line: 196
/// Divides `self` by a `u32`, returning the remainder.
#[corresponds(BN_div_word)]
#[allow(clippy::useless_conversion)]
pub fn div_word(&mut self, w: u32) -> Result<u64, ErrorStack> {
    unsafe {
        let r = ffi::BN_div_word(self.as_ptr(), w.into());
        if r == ffi::BN_ULONG::MAX { Err(ErrorStack::get()) } else { Ok(r.into()) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: mod_word,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in mod_word:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 201, End Line: 210
/// Returns the result of `self` modulo `w`.
#[corresponds(BN_mod_word)]
#[allow(clippy::useless_conversion)]
pub fn mod_word(&self, w: u32) -> Result<u64, ErrorStack> {
    unsafe {
        let r = ffi::BN_mod_word(self.as_ptr(), w.into());
        if r == ffi::BN_ULONG::MAX { Err(ErrorStack::get()) } else { Ok(r.into()) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: rand_range,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in rand_range:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 215, End Line: 217
/// Places a cryptographically-secure pseudo-random nonnegative
/// number less than `self` in `rnd`.
#[corresponds(BN_rand_range)]
pub fn rand_range(&self, rnd: &mut BigNumRef) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::BN_rand_range(rnd.as_ptr(), self.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: pseudo_rand_range,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in pseudo_rand_range:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 222, End Line: 224
/// The cryptographically weak counterpart to `rand_in_range`.
#[cfg(not(osslconf = "OPENSSL_NO_DEPRECATED_3_0"))]
#[corresponds(BN_pseudo_rand_range)]
pub fn pseudo_rand_range(&self, rnd: &mut BigNumRef) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::BN_pseudo_rand_range(rnd.as_ptr(), self.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_bit,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in set_bit:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 231, End Line: 233
/// Sets bit `n`. Equivalent to `self |= (1 << n)`.
///
/// When setting a bit outside of `self`, it is expanded.
#[corresponds(BN_set_bit)]
#[allow(clippy::useless_conversion)]
pub fn set_bit(&mut self, n: i32) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::BN_set_bit(self.as_ptr(), n.into())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: clear_bit,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in clear_bit:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 240, End Line: 242
/// Clears bit `n`, setting it to 0. Equivalent to `self &= ~(1 << n)`.
///
/// When clearing a bit outside of `self`, an error is returned.
#[corresponds(BN_clear_bit)]
#[allow(clippy::useless_conversion)]
pub fn clear_bit(&mut self, n: i32) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::BN_clear_bit(self.as_ptr(), n.into())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: is_bit_set,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in is_bit_set:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 247, End Line: 249
/// Returns `true` if the `n`th bit of `self` is set to 1, `false` otherwise.
#[corresponds(BN_is_bit_set)]
#[allow(clippy::useless_conversion)]
pub fn is_bit_set(&self, n: i32) -> bool {
    unsafe { ffi::BN_is_bit_set(self.as_ptr(), n.into()) == 1 }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: mask_bits,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in mask_bits:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 256, End Line: 258
/// Truncates `self` to the lowest `n` bits.
///
/// An error occurs if `self` is already shorter than `n` bits.
#[corresponds(BN_mask_bits)]
#[allow(clippy::useless_conversion)]
pub fn mask_bits(&mut self, n: i32) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::BN_mask_bits(self.as_ptr(), n.into())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: lshift1,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in lshift1:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 262, End Line: 264
/// Places `a << 1` in `self`.  Equivalent to `self * 2`.
#[corresponds(BN_lshift1)]
pub fn lshift1(&mut self, a: &BigNumRef) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::BN_lshift1(self.as_ptr(), a.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: rshift1,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in rshift1:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 268, End Line: 270
/// Places `a >> 1` in `self`. Equivalent to `self / 2`.
#[corresponds(BN_rshift1)]
pub fn rshift1(&mut self, a: &BigNumRef) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::BN_rshift1(self.as_ptr(), a.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: checked_add,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in checked_add:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 276, End Line: 278
/// Places `a + b` in `self`.  [`core::ops::Add`] is also implemented for `BigNumRef`.
///
/// [`core::ops::Add`]: struct.BigNumRef.html#method.add
#[corresponds(BN_add)]
pub fn checked_add(&mut self, a: &BigNumRef, b: &BigNumRef) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::BN_add(self.as_ptr(), a.as_ptr(), b.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: checked_sub,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in checked_sub:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 284, End Line: 286
/// Places `a - b` in `self`. [`core::ops::Sub`] is also implemented for `BigNumRef`.
///
/// [`core::ops::Sub`]: struct.BigNumRef.html#method.sub
#[corresponds(BN_sub)]
pub fn checked_sub(&mut self, a: &BigNumRef, b: &BigNumRef) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::BN_sub(self.as_ptr(), a.as_ptr(), b.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: lshift,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in lshift:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 291, End Line: 293
/// Places `a << n` in `self`.  Equivalent to `a * 2 ^ n`.
#[corresponds(BN_lshift)]
#[allow(clippy::useless_conversion)]
pub fn lshift(&mut self, a: &BigNumRef, n: i32) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::BN_lshift(self.as_ptr(), a.as_ptr(), n.into())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: rshift,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in rshift:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 298, End Line: 300
/// Places `a >> n` in `self`. Equivalent to `a / 2 ^ n`.
#[corresponds(BN_rshift)]
#[allow(clippy::useless_conversion)]
pub fn rshift(&mut self, a: &BigNumRef, n: i32) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::BN_rshift(self.as_ptr(), a.as_ptr(), n.into())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: to_owned,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in to_owned:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 304, End Line: 306
/// Creates a new BigNum with the same value.
#[corresponds(BN_dup)]
pub fn to_owned(&self) -> Result<BigNum, ErrorStack> {
    unsafe { cvt_p(ffi::BN_dup(self.as_ptr())).map(|b| BigNum::from_ptr(b)) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_negative,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in set_negative:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 311, End Line: 313
/// Sets the sign of `self`.  Pass true to set `self` to a negative.  False sets
/// `self` positive.
#[corresponds(BN_set_negative)]
pub fn set_negative(&mut self, negative: bool) {
    unsafe { ffi::BN_set_negative(self.as_ptr(), negative as c_int) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: ucmp,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in ucmp:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 328, End Line: 330
/// Compare the absolute values of `self` and `oth`.
///
/// # Examples
///
/// ```
/// # use openssl::bn::BigNum;
/// # use std::cmp::Ordering;
/// let s = -BigNum::from_u32(8).unwrap();
/// let o = BigNum::from_u32(8).unwrap();
///
/// assert_eq!(s.ucmp(&o), Ordering::Equal);
/// ```
#[corresponds(BN_ucmp)]
pub fn ucmp(&self, oth: &BigNumRef) -> Ordering {
    unsafe { ffi::BN_ucmp(self.as_ptr(), oth.as_ptr()).cmp(&0) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: is_negative,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in is_negative:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 334, End Line: 336
/// Returns `true` if `self` is negative.
#[corresponds(BN_is_negative)]
pub fn is_negative(&self) -> bool {
    unsafe { BN_is_negative(self.as_ptr()) == 1 }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: is_odd,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in is_odd:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 348, End Line: 350
/// Returns `true` is `self` is odd.
#[corresponds(BN_is_odd)]
#[cfg(any(ossl110, boringssl, libressl350))]
pub fn is_odd(&self) -> bool {
    unsafe { ffi::BN_is_odd(self.as_ptr()) == 1 }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: num_bits,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in num_bits:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 355, End Line: 357
/// Returns the number of significant bits in `self`.
#[corresponds(BN_num_bits)]
#[allow(clippy::unnecessary_cast)]
pub fn num_bits(&self) -> i32 {
    unsafe { ffi::BN_num_bits(self.as_ptr()) as i32 }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: rand,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in rand:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 390, End Line: 400
/// Generates a cryptographically strong pseudo-random `BigNum`, placing it in `self`.
///
/// # Parameters
///
/// * `bits`: Length of the number in bits.
/// * `msb`: The desired properties of the most significant bit. See [`constants`].
/// * `odd`: If `true`, the generated number will be odd.
///
/// # Examples
///
/// ```
/// use openssl::bn::{BigNum, MsbOption};
/// use openssl::error::ErrorStack;
///
/// fn generate_random() -> Result< BigNum, ErrorStack > {
///    let mut big = BigNum::new()?;
///
///    // Generates a 128-bit odd random number
///    big.rand(128, MsbOption::MAYBE_ZERO, true);
///    Ok((big))
/// }
/// ```
///
/// [`constants`]: index.html#constants
#[corresponds(BN_rand)]
#[allow(clippy::useless_conversion)]
pub fn rand(&mut self, bits: i32, msb: MsbOption, odd: bool) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::BN_rand(self.as_ptr(), bits.into(), msb.0, odd as c_int)).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: pseudo_rand,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in pseudo_rand:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 406, End Line: 416
/// The cryptographically weak counterpart to `rand`.  Not suitable for key generation.
#[cfg(not(osslconf = "OPENSSL_NO_DEPRECATED_3_0"))]
#[corresponds(BN_pseudo_rand)]
#[allow(clippy::useless_conversion)]
pub fn pseudo_rand(
    &mut self,
    bits: i32,
    msb: MsbOption,
    odd: bool,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::BN_pseudo_rand(self.as_ptr(), bits.into(), msb.0, odd as c_int))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: generate_prime,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in generate_prime:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 442, End Line: 460
/// Generates a prime number, placing it in `self`.
///
/// # Parameters
///
/// * `bits`: The length of the prime in bits (lower bound).
/// * `safe`: If true, returns a "safe" prime `p` so that `(p-1)/2` is also prime.
/// * `add`/`rem`: If `add` is set to `Some(add)`, `p % add == rem` will hold, where `p` is the
///   generated prime and `rem` is `1` if not specified (`None`).
///
/// # Examples
///
/// ```
/// use openssl::bn::BigNum;
/// use openssl::error::ErrorStack;
///
/// fn generate_weak_prime() -> Result< BigNum, ErrorStack > {
///    let mut big = BigNum::new()?;
///
///    // Generates a 128-bit simple prime number
///    big.generate_prime(128, false, None, None);
///    Ok((big))
/// }
/// ```
#[corresponds(BN_generate_prime_ex)]
pub fn generate_prime(
    &mut self,
    bits: i32,
    safe: bool,
    add: Option<&BigNumRef>,
    rem: Option<&BigNumRef>,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::BN_generate_prime_ex(
                    self.as_ptr(),
                    bits as c_int,
                    safe as c_int,
                    add.map(|n| n.as_ptr()).unwrap_or(ptr::null_mut()),
                    rem.map(|n| n.as_ptr()).unwrap_or(ptr::null_mut()),
                    ptr::null_mut(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: checked_mul,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in checked_mul:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 467, End Line: 482
/// Places the result of `a * b` in `self`.
/// [`core::ops::Mul`] is also implemented for `BigNumRef`.
///
/// [`core::ops::Mul`]: struct.BigNumRef.html#method.mul
#[corresponds(BN_mul)]
pub fn checked_mul(
    &mut self,
    a: &BigNumRef,
    b: &BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::BN_mul(self.as_ptr(), a.as_ptr(), b.as_ptr(), ctx.as_ptr())).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: checked_div,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in checked_div:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 489, End Line: 505
/// Places the result of `a / b` in `self`. The remainder is discarded.
/// [`core::ops::Div`] is also implemented for `BigNumRef`.
///
/// [`core::ops::Div`]: struct.BigNumRef.html#method.div
#[corresponds(BN_div)]
pub fn checked_div(
    &mut self,
    a: &BigNumRef,
    b: &BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::BN_div(
                    self.as_ptr(),
                    ptr::null_mut(),
                    a.as_ptr(),
                    b.as_ptr(),
                    ctx.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: checked_rem,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in checked_rem:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 509, End Line: 525
/// Places the result of `a % b` in `self`.
#[corresponds(BN_div)]
pub fn checked_rem(
    &mut self,
    a: &BigNumRef,
    b: &BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::BN_div(
                    ptr::null_mut(),
                    self.as_ptr(),
                    a.as_ptr(),
                    b.as_ptr(),
                    ctx.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: div_rem,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in div_rem:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 529, End Line: 546
/// Places the result of `a / b` in `self` and `a % b` in `rem`.
#[corresponds(BN_div)]
pub fn div_rem(
    &mut self,
    rem: &mut BigNumRef,
    a: &BigNumRef,
    b: &BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::BN_div(
                    self.as_ptr(),
                    rem.as_ptr(),
                    a.as_ptr(),
                    b.as_ptr(),
                    ctx.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sqr,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in sqr:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 550, End Line: 552
/// Places the result of `a²` in `self`.
#[corresponds(BN_sqr)]
pub fn sqr(
    &mut self,
    a: &BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::BN_sqr(self.as_ptr(), a.as_ptr(), ctx.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: nnmod,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in nnmod:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 557, End Line: 572
/// Places the result of `a mod m` in `self`.  As opposed to `div_rem`
/// the result is non-negative.
#[corresponds(BN_nnmod)]
pub fn nnmod(
    &mut self,
    a: &BigNumRef,
    m: &BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::BN_nnmod(self.as_ptr(), a.as_ptr(), m.as_ptr(), ctx.as_ptr()))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: mod_add,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in mod_add:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 576, End Line: 593
/// Places the result of `(a + b) mod m` in `self`.
#[corresponds(BN_mod_add)]
pub fn mod_add(
    &mut self,
    a: &BigNumRef,
    b: &BigNumRef,
    m: &BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::BN_mod_add(
                    self.as_ptr(),
                    a.as_ptr(),
                    b.as_ptr(),
                    m.as_ptr(),
                    ctx.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: mod_sub,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in mod_sub:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 597, End Line: 614
/// Places the result of `(a - b) mod m` in `self`.
#[corresponds(BN_mod_sub)]
pub fn mod_sub(
    &mut self,
    a: &BigNumRef,
    b: &BigNumRef,
    m: &BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::BN_mod_sub(
                    self.as_ptr(),
                    a.as_ptr(),
                    b.as_ptr(),
                    m.as_ptr(),
                    ctx.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: mod_mul,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in mod_mul:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 618, End Line: 635
/// Places the result of `(a * b) mod m` in `self`.
#[corresponds(BN_mod_mul)]
pub fn mod_mul(
    &mut self,
    a: &BigNumRef,
    b: &BigNumRef,
    m: &BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::BN_mod_mul(
                    self.as_ptr(),
                    a.as_ptr(),
                    b.as_ptr(),
                    m.as_ptr(),
                    ctx.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: mod_sqr,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in mod_sqr:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 639, End Line: 654
/// Places the result of `a² mod m` in `self`.
#[corresponds(BN_mod_sqr)]
pub fn mod_sqr(
    &mut self,
    a: &BigNumRef,
    m: &BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::BN_mod_sqr(self.as_ptr(), a.as_ptr(), m.as_ptr(), ctx.as_ptr()))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: mod_sqrt,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in mod_sqrt:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 658, End Line: 673
/// Places into `self` the modular square root of `a` such that `self^2 = a (mod p)`
#[corresponds(BN_mod_sqrt)]
pub fn mod_sqrt(
    &mut self,
    a: &BigNumRef,
    p: &BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt_p(ffi::BN_mod_sqrt(self.as_ptr(), a.as_ptr(), p.as_ptr(), ctx.as_ptr()))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: exp,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in exp:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 677, End Line: 692
/// Places the result of `a^p` in `self`.
#[corresponds(BN_exp)]
pub fn exp(
    &mut self,
    a: &BigNumRef,
    p: &BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::BN_exp(self.as_ptr(), a.as_ptr(), p.as_ptr(), ctx.as_ptr())).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: mod_exp,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in mod_exp:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 696, End Line: 713
/// Places the result of `a^p mod m` in `self`.
#[corresponds(BN_mod_exp)]
pub fn mod_exp(
    &mut self,
    a: &BigNumRef,
    p: &BigNumRef,
    m: &BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::BN_mod_exp(
                    self.as_ptr(),
                    a.as_ptr(),
                    p.as_ptr(),
                    m.as_ptr(),
                    ctx.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: mod_inverse,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in mod_inverse:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 717, End Line: 732
/// Places the inverse of `a` modulo `n` in `self`.
#[corresponds(BN_mod_inverse)]
pub fn mod_inverse(
    &mut self,
    a: &BigNumRef,
    n: &BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt_p(ffi::BN_mod_inverse(self.as_ptr(), a.as_ptr(), n.as_ptr(), ctx.as_ptr()))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: gcd,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in gcd:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 736, End Line: 751
/// Places the greatest common denominator of `a` and `b` in `self`.
#[corresponds(BN_gcd)]
pub fn gcd(
    &mut self,
    a: &BigNumRef,
    b: &BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::BN_gcd(self.as_ptr(), a.as_ptr(), b.as_ptr(), ctx.as_ptr())).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: is_prime,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in is_prime:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 763, End Line: 773
/// Checks whether `self` is prime.
///
/// Performs a Miller-Rabin probabilistic primality test with `checks` iterations.
///
/// # Return Value
///
/// Returns `true` if `self` is prime with an error probability of less than `0.25 ^ checks`.
#[cfg(not(osslconf = "OPENSSL_NO_DEPRECATED_3_0"))]
#[corresponds(BN_is_prime_ex)]
#[allow(clippy::useless_conversion)]
pub fn is_prime(
    &self,
    checks: i32,
    ctx: &mut BigNumContextRef,
) -> Result<bool, ErrorStack> {
    unsafe {
        cvt_n(
                ffi::BN_is_prime_ex(
                    self.as_ptr(),
                    checks.into(),
                    ctx.as_ptr(),
                    ptr::null_mut(),
                ),
            )
            .map(|r| r != 0)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: is_prime_fasttest,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in is_prime_fasttest:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 787, End Line: 803
/// Checks whether `self` is prime with optional trial division.
///
/// If `do_trial_division` is `true`, first performs trial division by a number of small primes.
/// Then, like `is_prime`, performs a Miller-Rabin probabilistic primality test with `checks`
/// iterations.
///
/// # Return Value
///
/// Returns `true` if `self` is prime with an error probability of less than `0.25 ^ checks`.
#[cfg(not(osslconf = "OPENSSL_NO_DEPRECATED_3_0"))]
#[corresponds(BN_is_prime_fasttest_ex)]
#[allow(clippy::useless_conversion)]
pub fn is_prime_fasttest(
    &self,
    checks: i32,
    ctx: &mut BigNumContextRef,
    do_trial_division: bool,
) -> Result<bool, ErrorStack> {
    unsafe {
        cvt_n(
                ffi::BN_is_prime_fasttest_ex(
                    self.as_ptr(),
                    checks.into(),
                    ctx.as_ptr(),
                    do_trial_division as c_int,
                    ptr::null_mut(),
                ),
            )
            .map(|r| r != 0)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: to_vec,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in to_vec:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 818, End Line: 826
/// Returns a big-endian byte vector representation of the absolute value of `self`.
///
/// `self` can be recreated by using `from_slice`.
///
/// ```
/// # use openssl::bn::BigNum;
/// let s = -BigNum::from_u32(4543).unwrap();
/// let r = BigNum::from_u32(4543).unwrap();
///
/// let s_vec = s.to_vec();
/// assert_eq!(BigNum::from_slice(&s_vec).unwrap(), r);
/// ```
#[corresponds(BN_bn2bin)]
pub fn to_vec(&self) -> Vec<u8> {
    let size = self.num_bytes() as usize;
    let mut v = Vec::with_capacity(size);
    unsafe {
        ffi::BN_bn2bin(self.as_ptr(), v.as_mut_ptr());
        v.set_len(size);
    }
    v
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: to_vec_padded,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in to_vec_padded:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 851, End Line: 858
/// Returns a big-endian byte vector representation of the absolute value of `self` padded
/// to `pad_to` bytes.
///
/// If `pad_to` is less than `self.num_bytes()` then an error is returned.
///
/// `self` can be recreated by using `from_slice`.
///
/// ```
/// # use openssl::bn::BigNum;
/// let bn = BigNum::from_u32(0x4543).unwrap();
///
/// let bn_vec = bn.to_vec_padded(4).unwrap();
/// assert_eq!(&bn_vec, &[0, 0, 0x45, 0x43]);
///
/// let r = bn.to_vec_padded(1);
/// assert!(r.is_err());
///
/// let bn = -BigNum::from_u32(0x4543).unwrap();
/// let bn_vec = bn.to_vec_padded(4).unwrap();
/// assert_eq!(&bn_vec, &[0, 0, 0x45, 0x43]);
/// ```
#[corresponds(BN_bn2binpad)]
#[cfg(any(ossl110, libressl340, boringssl))]
pub fn to_vec_padded(&self, pad_to: i32) -> Result<Vec<u8>, ErrorStack> {
    let mut v = Vec::with_capacity(pad_to as usize);
    unsafe {
        cvt(ffi::BN_bn2binpad(self.as_ptr(), v.as_mut_ptr(), pad_to))?;
        v.set_len(pad_to as usize);
    }
    Ok(v)
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: to_dec_str,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in to_dec_str:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 869, End Line: 874
/// Returns a decimal string representation of `self`.
///
/// ```
/// # use openssl::bn::BigNum;
/// let s = -BigNum::from_u32(12345).unwrap();
///
/// assert_eq!(&**s.to_dec_str().unwrap(), "-12345");
/// ```
#[corresponds(BN_bn2dec)]
pub fn to_dec_str(&self) -> Result<OpensslString, ErrorStack> {
    unsafe {
        let buf = cvt_p(ffi::BN_bn2dec(self.as_ptr()))?;
        Ok(OpensslString::from_ptr(buf))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: to_hex_str,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in to_hex_str:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 885, End Line: 890
/// Returns a hexadecimal string representation of `self`.
///
/// ```
/// # use openssl::bn::BigNum;
/// let s = -BigNum::from_u32(0x99ff).unwrap();
///
/// assert_eq!(s.to_hex_str().unwrap().to_uppercase(), "-99FF");
/// ```
#[corresponds(BN_bn2hex)]
pub fn to_hex_str(&self) -> Result<OpensslString, ErrorStack> {
    unsafe {
        let buf = cvt_p(ffi::BN_bn2hex(self.as_ptr()))?;
        Ok(OpensslString::from_ptr(buf))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: to_asn1_integer,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in to_asn1_integer:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 894, End Line: 899
/// Returns an `Asn1Integer` containing the value of `self`.
#[corresponds(BN_to_ASN1_INTEGER)]
pub fn to_asn1_integer(&self) -> Result<Asn1Integer, ErrorStack> {
    unsafe {
        cvt_p(ffi::BN_to_ASN1_INTEGER(self.as_ptr(), ptr::null_mut()))
            .map(|p| Asn1Integer::from_ptr(p))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_const_time,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in set_const_time:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 904, End Line: 906
/// Force constant time computation on this value.
#[corresponds(BN_set_flags)]
#[cfg(ossl110)]
pub fn set_const_time(&mut self) {
    unsafe { ffi::BN_set_flags(self.as_ptr(), ffi::BN_FLG_CONSTTIME) }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: is_const_time,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in is_const_time:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 911, End Line: 916
/// Returns true if `self` is in const time mode.
#[corresponds(BN_get_flags)]
#[cfg(ossl110)]
pub fn is_const_time(&self) -> bool {
    unsafe {
        let ret = ffi::BN_get_flags(self.as_ptr(), ffi::BN_FLG_CONSTTIME);
        ret == ffi::BN_FLG_CONSTTIME
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: is_secure,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in is_secure:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 921, End Line: 926
/// Returns true if `self` was created with [`BigNum::new_secure`].
#[corresponds(BN_get_flags)]
#[cfg(ossl110)]
pub fn is_secure(&self) -> bool {
    unsafe {
        let ret = ffi::BN_get_flags(self.as_ptr(), ffi::BN_FLG_SECURE);
        ret == ffi::BN_FLG_SECURE
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: from_u32,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in from_u32:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 953, End Line: 957
/// Creates a new `BigNum` with the given value.
#[corresponds(BN_set_word)]
pub fn from_u32(n: u32) -> Result<BigNum, ErrorStack> {
    BigNum::new()
        .and_then(|v| unsafe {
            cvt(ffi::BN_set_word(v.as_ptr(), n as ffi::BN_ULONG)).map(|_| v)
        })
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: from_dec_str,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in from_dec_str:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 961, End Line: 969
/// Creates a `BigNum` from a decimal string.
#[corresponds(BN_dec2bn)]
pub fn from_dec_str(s: &str) -> Result<BigNum, ErrorStack> {
    unsafe {
        ffi::init();
        let c_str = CString::new(s.as_bytes()).unwrap();
        let mut bn = ptr::null_mut();
        cvt(ffi::BN_dec2bn(&mut bn, c_str.as_ptr() as *const _))?;
        Ok(BigNum::from_ptr(bn))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: from_hex_str,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in from_hex_str:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 973, End Line: 981
/// Creates a `BigNum` from a hexadecimal string.
#[corresponds(BN_hex2bn)]
pub fn from_hex_str(s: &str) -> Result<BigNum, ErrorStack> {
    unsafe {
        ffi::init();
        let c_str = CString::new(s.as_bytes()).unwrap();
        let mut bn = ptr::null_mut();
        cvt(ffi::BN_hex2bn(&mut bn, c_str.as_ptr() as *const _))?;
        Ok(BigNum::from_ptr(bn))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: get_rfc2409_prime_768,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in get_rfc2409_prime_768:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 990, End Line: 995
/// Returns a constant used in IKE as defined in [`RFC 2409`].  This prime number is in
/// the order of magnitude of `2 ^ 768`.  This number is used during calculated key
/// exchanges such as Diffie-Hellman.  This number is labeled Oakley group id 1.
///
/// [`RFC 2409`]: https://tools.ietf.org/html/rfc2409#page-21
#[corresponds(BN_get_rfc2409_prime_768)]
#[cfg(not(boringssl))]
pub fn get_rfc2409_prime_768() -> Result<BigNum, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(BN_get_rfc2409_prime_768(ptr::null_mut())).map(BigNum)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: get_rfc2409_prime_1024,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in get_rfc2409_prime_1024:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 1004, End Line: 1009
/// Returns a constant used in IKE as defined in [`RFC 2409`].  This prime number is in
/// the order of magnitude of `2 ^ 1024`.  This number is used during calculated key
/// exchanges such as Diffie-Hellman.  This number is labeled Oakly group 2.
///
/// [`RFC 2409`]: https://tools.ietf.org/html/rfc2409#page-21
#[corresponds(BN_get_rfc2409_prime_1024)]
#[cfg(not(boringssl))]
pub fn get_rfc2409_prime_1024() -> Result<BigNum, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(BN_get_rfc2409_prime_1024(ptr::null_mut())).map(BigNum)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: get_rfc3526_prime_1536,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in get_rfc3526_prime_1536:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 1018, End Line: 1023
/// Returns a constant used in IKE as defined in [`RFC 3526`].  The prime is in the order
/// of magnitude of `2 ^ 1536`.  This number is used during calculated key
/// exchanges such as Diffie-Hellman.  This number is labeled MODP group 5.
///
/// [`RFC 3526`]: https://tools.ietf.org/html/rfc3526#page-3
#[corresponds(BN_get_rfc3526_prime_1536)]
#[cfg(not(boringssl))]
pub fn get_rfc3526_prime_1536() -> Result<BigNum, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(BN_get_rfc3526_prime_1536(ptr::null_mut())).map(BigNum)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: get_rfc3526_prime_2048,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in get_rfc3526_prime_2048:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 1032, End Line: 1037
/// Returns a constant used in IKE as defined in [`RFC 3526`].  The prime is in the order
/// of magnitude of `2 ^ 2048`.  This number is used during calculated key
/// exchanges such as Diffie-Hellman.  This number is labeled MODP group 14.
///
/// [`RFC 3526`]: https://tools.ietf.org/html/rfc3526#page-3
#[corresponds(BN_get_rfc3526_prime_2048)]
#[cfg(not(boringssl))]
pub fn get_rfc3526_prime_2048() -> Result<BigNum, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(BN_get_rfc3526_prime_2048(ptr::null_mut())).map(BigNum)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: get_rfc3526_prime_3072,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in get_rfc3526_prime_3072:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 1046, End Line: 1051
/// Returns a constant used in IKE as defined in [`RFC 3526`].  The prime is in the order
/// of magnitude of `2 ^ 3072`.  This number is used during calculated key
/// exchanges such as Diffie-Hellman.  This number is labeled MODP group 15.
///
/// [`RFC 3526`]: https://tools.ietf.org/html/rfc3526#page-4
#[corresponds(BN_get_rfc3526_prime_3072)]
#[cfg(not(boringssl))]
pub fn get_rfc3526_prime_3072() -> Result<BigNum, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(BN_get_rfc3526_prime_3072(ptr::null_mut())).map(BigNum)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: get_rfc3526_prime_4096,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in get_rfc3526_prime_4096:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 1060, End Line: 1065
/// Returns a constant used in IKE as defined in [`RFC 3526`].  The prime is in the order
/// of magnitude of `2 ^ 4096`.  This number is used during calculated key
/// exchanges such as Diffie-Hellman.  This number is labeled MODP group 16.
///
/// [`RFC 3526`]: https://tools.ietf.org/html/rfc3526#page-4
#[corresponds(BN_get_rfc3526_prime_4096)]
#[cfg(not(boringssl))]
pub fn get_rfc3526_prime_4096() -> Result<BigNum, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(BN_get_rfc3526_prime_4096(ptr::null_mut())).map(BigNum)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: get_rfc3526_prime_6144,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in get_rfc3526_prime_6144:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 1074, End Line: 1079
/// Returns a constant used in IKE as defined in [`RFC 3526`].  The prime is in the order
/// of magnitude of `2 ^ 6144`.  This number is used during calculated key
/// exchanges such as Diffie-Hellman.  This number is labeled MODP group 17.
///
/// [`RFC 3526`]: https://tools.ietf.org/html/rfc3526#page-6
#[corresponds(BN_get_rfc3526_prime_6114)]
#[cfg(not(boringssl))]
pub fn get_rfc3526_prime_6144() -> Result<BigNum, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(BN_get_rfc3526_prime_6144(ptr::null_mut())).map(BigNum)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: get_rfc3526_prime_8192,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in get_rfc3526_prime_8192:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 1088, End Line: 1093
/// Returns a constant used in IKE as defined in [`RFC 3526`].  The prime is in the order
/// of magnitude of `2 ^ 8192`.  This number is used during calculated key
/// exchanges such as Diffie-Hellman.  This number is labeled MODP group 18.
///
/// [`RFC 3526`]: https://tools.ietf.org/html/rfc3526#page-6
#[corresponds(BN_get_rfc3526_prime_8192)]
#[cfg(not(boringssl))]
pub fn get_rfc3526_prime_8192() -> Result<BigNum, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(BN_get_rfc3526_prime_8192(ptr::null_mut())).map(BigNum)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: from_slice,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in from_slice:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 1108, End Line: 1120
/// Creates a new `BigNum` from an unsigned, big-endian encoded number of arbitrary length.
///
/// OpenSSL documentation at [`BN_bin2bn`]
///
/// [`BN_bin2bn`]: https://www.openssl.org/docs/manmaster/crypto/BN_bin2bn.html
///
/// ```
/// # use openssl::bn::BigNum;
/// let bignum = BigNum::from_slice(&[0x12, 0x00, 0x34]).unwrap();
///
/// assert_eq!(bignum, BigNum::from_u32(0x120034).unwrap());
/// ```
#[corresponds(BN_bin2bn)]
pub fn from_slice(n: &[u8]) -> Result<BigNum, ErrorStack> {
    unsafe {
        ffi::init();
        assert!(n.len() <= LenType::MAX as usize);
        cvt_p(ffi::BN_bin2bn(n.as_ptr(), n.len() as LenType, ptr::null_mut()))
            .map(|p| BigNum::from_ptr(p))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: copy_from_slice,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in copy_from_slice:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 1137, End Line: 1144
/// Copies data from a slice overwriting what was in the BigNum.
///
/// This function can be used to copy data from a slice to a
/// [secure BigNum][`BigNum::new_secure`].
///
/// # Examples
///
/// ```
/// # use openssl::bn::BigNum;
/// let mut bignum = BigNum::new().unwrap();
/// bignum.copy_from_slice(&[0x12, 0x00, 0x34]).unwrap();
///
/// assert_eq!(bignum, BigNum::from_u32(0x120034).unwrap());
/// ```
#[corresponds(BN_bin2bn)]
pub fn copy_from_slice(&mut self, n: &[u8]) -> Result<(), ErrorStack> {
    unsafe {
        assert!(n.len() <= LenType::MAX as usize);
        cvt_p(ffi::BN_bin2bn(n.as_ptr(), n.len() as LenType, self.0))?;
        Ok(())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cmp,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs

Found method with unsafe block in cmp:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\bn.rs
Start Line: 1224, End Line: 1226
fn cmp(&self, oth: &BigNumRef) -> Ordering {
    unsafe { ffi::BN_cmp(self.as_ptr(), oth.as_ptr()).cmp(&0) }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: from_nid,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in from_nid:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 121, End Line: 130
/// Looks up the cipher for a certain nid.
#[corresponds(EVP_get_cipherbynid)]
pub fn from_nid(nid: Nid) -> Option<&'static CipherRef> {
    unsafe {
        let ptr = ffi::EVP_get_cipherbyname(ffi::OBJ_nid2sn(nid.as_raw()));
        if ptr.is_null() { None } else { Some(CipherRef::from_ptr(ptr as *mut _)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: fetch,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in fetch:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 137, End Line: 154
/// Fetches a cipher object corresponding to the specified algorithm name and properties.
///
/// Requires OpenSSL 3.0.0 or newer.
#[corresponds(EVP_CIPHER_fetch)]
#[cfg(ossl300)]
pub fn fetch(
    ctx: Option<&LibCtxRef>,
    algorithm: &str,
    properties: Option<&str>,
) -> Result<Self, ErrorStack> {
    let algorithm = CString::new(algorithm).unwrap();
    let properties = properties.map(|s| CString::new(s).unwrap());
    unsafe {
        let ptr = cvt_p(
            ffi::EVP_CIPHER_fetch(
                ctx.map_or(ptr::null_mut(), ForeignTypeRef::as_ptr),
                algorithm.as_ptr(),
                properties.map_or(ptr::null_mut(), |s| s.as_ptr()),
            ),
        )?;
        Ok(Cipher::from_ptr(ptr))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_128_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 156, End Line: 158
pub fn aes_128_ecb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_128_ecb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_128_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 160, End Line: 162
pub fn aes_128_cbc() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_128_cbc() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_xts,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_128_xts:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 165, End Line: 167
#[cfg(not(boringssl))]
pub fn aes_128_xts() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_128_xts() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_xts,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_256_xts:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 170, End Line: 172
#[cfg(not(boringssl))]
pub fn aes_256_xts() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_256_xts() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_ctr,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_128_ctr:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 174, End Line: 176
pub fn aes_128_ctr() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_128_ctr() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_cfb1,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_128_cfb1:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 179, End Line: 181
#[cfg(not(boringssl))]
pub fn aes_128_cfb1() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_128_cfb1() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_cfb128,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_128_cfb128:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 184, End Line: 186
#[cfg(not(boringssl))]
pub fn aes_128_cfb128() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_128_cfb128() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_cfb8,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_128_cfb8:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 189, End Line: 191
#[cfg(not(boringssl))]
pub fn aes_128_cfb8() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_128_cfb8() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_gcm,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_128_gcm:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 193, End Line: 195
pub fn aes_128_gcm() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_128_gcm() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_ccm,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_128_ccm:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 198, End Line: 200
#[cfg(not(boringssl))]
pub fn aes_128_ccm() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_128_ccm() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_128_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 202, End Line: 204
pub fn aes_128_ofb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_128_ofb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_ocb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_128_ocb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 208, End Line: 210
/// Requires OpenSSL 1.1.0 or newer.
#[cfg(all(ossl110, not(osslconf = "OPENSSL_NO_OCB")))]
pub fn aes_128_ocb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_128_ocb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_wrap,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_128_wrap:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 214, End Line: 216
/// Requires OpenSSL 1.0.2 or newer.
#[cfg(ossl102)]
pub fn aes_128_wrap() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_128_wrap() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_wrap_pad,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_128_wrap_pad:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 220, End Line: 222
/// Requires OpenSSL 1.1.0 or newer.
#[cfg(ossl110)]
pub fn aes_128_wrap_pad() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_128_wrap_pad() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_192_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 224, End Line: 226
pub fn aes_192_ecb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_192_ecb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_192_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 228, End Line: 230
pub fn aes_192_cbc() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_192_cbc() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_ctr,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_192_ctr:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 232, End Line: 234
pub fn aes_192_ctr() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_192_ctr() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_cfb1,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_192_cfb1:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 237, End Line: 239
#[cfg(not(boringssl))]
pub fn aes_192_cfb1() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_192_cfb1() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_cfb128,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_192_cfb128:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 241, End Line: 243
pub fn aes_192_cfb128() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_192_cfb128() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_cfb8,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_192_cfb8:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 246, End Line: 248
#[cfg(not(boringssl))]
pub fn aes_192_cfb8() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_192_cfb8() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_gcm,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_192_gcm:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 250, End Line: 252
pub fn aes_192_gcm() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_192_gcm() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_ccm,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_192_ccm:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 255, End Line: 257
#[cfg(not(boringssl))]
pub fn aes_192_ccm() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_192_ccm() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_192_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 259, End Line: 261
pub fn aes_192_ofb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_192_ofb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_ocb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_192_ocb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 265, End Line: 267
/// Requires OpenSSL 1.1.0 or newer.
#[cfg(all(ossl110, not(osslconf = "OPENSSL_NO_OCB")))]
pub fn aes_192_ocb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_192_ocb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_wrap,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_192_wrap:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 271, End Line: 273
/// Requires OpenSSL 1.0.2 or newer.
#[cfg(ossl102)]
pub fn aes_192_wrap() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_192_wrap() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_wrap_pad,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_192_wrap_pad:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 277, End Line: 279
/// Requires OpenSSL 1.1.0 or newer.
#[cfg(ossl110)]
pub fn aes_192_wrap_pad() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_192_wrap_pad() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_256_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 281, End Line: 283
pub fn aes_256_ecb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_256_ecb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_256_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 285, End Line: 287
pub fn aes_256_cbc() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_256_cbc() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_ctr,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_256_ctr:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 289, End Line: 291
pub fn aes_256_ctr() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_256_ctr() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_cfb1,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_256_cfb1:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 294, End Line: 296
#[cfg(not(boringssl))]
pub fn aes_256_cfb1() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_256_cfb1() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_cfb128,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_256_cfb128:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 298, End Line: 300
pub fn aes_256_cfb128() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_256_cfb128() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_cfb8,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_256_cfb8:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 303, End Line: 305
#[cfg(not(boringssl))]
pub fn aes_256_cfb8() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_256_cfb8() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_gcm,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_256_gcm:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 307, End Line: 309
pub fn aes_256_gcm() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_256_gcm() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_ccm,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_256_ccm:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 312, End Line: 314
#[cfg(not(boringssl))]
pub fn aes_256_ccm() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_256_ccm() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_256_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 316, End Line: 318
pub fn aes_256_ofb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_256_ofb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_ocb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_256_ocb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 322, End Line: 324
/// Requires OpenSSL 1.1.0 or newer.
#[cfg(all(ossl110, not(osslconf = "OPENSSL_NO_OCB")))]
pub fn aes_256_ocb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_256_ocb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_wrap,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_256_wrap:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 328, End Line: 330
/// Requires OpenSSL 1.0.2 or newer.
#[cfg(ossl102)]
pub fn aes_256_wrap() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_256_wrap() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_wrap_pad,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in aes_256_wrap_pad:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 334, End Line: 336
/// Requires OpenSSL 1.1.0 or newer.
#[cfg(ossl110)]
pub fn aes_256_wrap_pad() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_aes_256_wrap_pad() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: bf_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in bf_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 339, End Line: 341
#[cfg(not(osslconf = "OPENSSL_NO_BF"))]
pub fn bf_cbc() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_bf_cbc() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: bf_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in bf_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 344, End Line: 346
#[cfg(not(osslconf = "OPENSSL_NO_BF"))]
pub fn bf_ecb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_bf_ecb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: bf_cfb64,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in bf_cfb64:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 349, End Line: 351
#[cfg(not(osslconf = "OPENSSL_NO_BF"))]
pub fn bf_cfb64() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_bf_cfb64() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: bf_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in bf_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 354, End Line: 356
#[cfg(not(osslconf = "OPENSSL_NO_BF"))]
pub fn bf_ofb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_bf_ofb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: des_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in des_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 358, End Line: 360
pub fn des_cbc() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_des_cbc() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: des_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in des_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 362, End Line: 364
pub fn des_ecb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_des_ecb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: des_ede3,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in des_ede3:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 366, End Line: 368
pub fn des_ede3() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_des_ede3() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: des_ede3_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in des_ede3_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 370, End Line: 372
pub fn des_ede3_ecb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_des_ede3_ecb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: des_ede3_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in des_ede3_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 374, End Line: 376
pub fn des_ede3_cbc() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_des_ede3_cbc() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: des_ede3_cfb8,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in des_ede3_cfb8:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 379, End Line: 381
#[cfg(not(boringssl))]
pub fn des_ede3_cfb8() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_des_ede3_cfb8() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: des_ede3_cfb64,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in des_ede3_cfb64:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 384, End Line: 386
#[cfg(not(boringssl))]
pub fn des_ede3_cfb64() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_des_ede3_cfb64() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: des_ede3_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in des_ede3_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 389, End Line: 391
#[cfg(not(boringssl))]
pub fn des_ede3_ofb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_des_ede3_ofb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: rc4,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in rc4:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 394, End Line: 396
#[cfg(not(osslconf = "OPENSSL_NO_RC4"))]
pub fn rc4() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_rc4() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia128_cfb128,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in camellia128_cfb128:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 399, End Line: 401
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia128_cfb128() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_camellia_128_cfb128() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia128_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in camellia128_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 404, End Line: 406
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia128_ecb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_camellia_128_ecb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia128_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in camellia128_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 409, End Line: 411
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia128_cbc() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_camellia_128_cbc() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia128_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in camellia128_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 414, End Line: 416
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia128_ofb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_camellia_128_ofb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia192_cfb128,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in camellia192_cfb128:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 419, End Line: 421
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia192_cfb128() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_camellia_192_cfb128() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia192_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in camellia192_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 424, End Line: 426
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia192_ecb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_camellia_192_ecb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia192_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in camellia192_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 429, End Line: 431
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia192_cbc() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_camellia_192_cbc() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia192_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in camellia192_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 434, End Line: 436
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia192_ofb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_camellia_192_ofb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia256_cfb128,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in camellia256_cfb128:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 439, End Line: 441
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia256_cfb128() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_camellia_256_cfb128() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia256_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in camellia256_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 444, End Line: 446
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia256_ecb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_camellia_256_ecb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia256_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in camellia256_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 449, End Line: 451
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia256_cbc() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_camellia_256_cbc() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia256_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in camellia256_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 454, End Line: 456
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia256_ofb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_camellia_256_ofb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cast5_cfb64,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in cast5_cfb64:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 459, End Line: 461
#[cfg(not(osslconf = "OPENSSL_NO_CAST"))]
pub fn cast5_cfb64() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_cast5_cfb64() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cast5_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in cast5_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 464, End Line: 466
#[cfg(not(osslconf = "OPENSSL_NO_CAST"))]
pub fn cast5_ecb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_cast5_ecb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cast5_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in cast5_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 469, End Line: 471
#[cfg(not(osslconf = "OPENSSL_NO_CAST"))]
pub fn cast5_cbc() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_cast5_cbc() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cast5_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in cast5_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 474, End Line: 476
#[cfg(not(osslconf = "OPENSSL_NO_CAST"))]
pub fn cast5_ofb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_cast5_ofb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: idea_cfb64,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in idea_cfb64:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 479, End Line: 481
#[cfg(not(osslconf = "OPENSSL_NO_IDEA"))]
pub fn idea_cfb64() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_idea_cfb64() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: idea_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in idea_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 484, End Line: 486
#[cfg(not(osslconf = "OPENSSL_NO_IDEA"))]
pub fn idea_ecb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_idea_ecb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: idea_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in idea_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 489, End Line: 491
#[cfg(not(osslconf = "OPENSSL_NO_IDEA"))]
pub fn idea_cbc() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_idea_cbc() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: idea_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in idea_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 494, End Line: 496
#[cfg(not(osslconf = "OPENSSL_NO_IDEA"))]
pub fn idea_ofb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_idea_ofb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: chacha20,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in chacha20:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 499, End Line: 501
#[cfg(all(any(ossl110, libressl310), not(osslconf = "OPENSSL_NO_CHACHA")))]
pub fn chacha20() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_chacha20() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: chacha20_poly1305,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in chacha20_poly1305:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 504, End Line: 506
#[cfg(all(any(ossl110, libressl360), not(osslconf = "OPENSSL_NO_CHACHA")))]
pub fn chacha20_poly1305() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_chacha20_poly1305() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: seed_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in seed_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 509, End Line: 511
#[cfg(not(osslconf = "OPENSSL_NO_SEED"))]
pub fn seed_cbc() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_seed_cbc() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: seed_cfb128,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in seed_cfb128:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 514, End Line: 516
#[cfg(not(osslconf = "OPENSSL_NO_SEED"))]
pub fn seed_cfb128() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_seed_cfb128() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: seed_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in seed_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 519, End Line: 521
#[cfg(not(osslconf = "OPENSSL_NO_SEED"))]
pub fn seed_ecb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_seed_ecb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: seed_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in seed_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 524, End Line: 526
#[cfg(not(osslconf = "OPENSSL_NO_SEED"))]
pub fn seed_ofb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_seed_ofb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sm4_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in sm4_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 529, End Line: 531
#[cfg(all(any(ossl111, libressl291), not(osslconf = "OPENSSL_NO_SM4")))]
pub fn sm4_ecb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_sm4_ecb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sm4_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in sm4_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 534, End Line: 536
#[cfg(all(any(ossl111, libressl291), not(osslconf = "OPENSSL_NO_SM4")))]
pub fn sm4_cbc() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_sm4_cbc() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sm4_ctr,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in sm4_ctr:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 539, End Line: 541
#[cfg(all(any(ossl111, libressl291), not(osslconf = "OPENSSL_NO_SM4")))]
pub fn sm4_ctr() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_sm4_ctr() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sm4_cfb128,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in sm4_cfb128:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 544, End Line: 546
#[cfg(all(any(ossl111, libressl291), not(osslconf = "OPENSSL_NO_SM4")))]
pub fn sm4_cfb128() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_sm4_cfb128() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sm4_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in sm4_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 549, End Line: 551
#[cfg(all(any(ossl111, libressl291), not(osslconf = "OPENSSL_NO_SM4")))]
pub fn sm4_ofb() -> &'static CipherRef {
    unsafe { CipherRef::from_ptr(ffi::EVP_sm4_ofb() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: nid,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in nid:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 567, End Line: 570
/// Returns the cipher's Nid.
#[corresponds(EVP_CIPHER_nid)]
pub fn nid(&self) -> Nid {
    let nid = unsafe { ffi::EVP_CIPHER_nid(self.as_ptr()) };
    Nid::from_raw(nid)
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: key_length,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in key_length:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 574, End Line: 576
/// Returns the length of keys used with this cipher.
#[corresponds(EVP_CIPHER_key_length)]
pub fn key_length(&self) -> usize {
    unsafe { EVP_CIPHER_key_length(self.as_ptr()) as usize }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: iv_length,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in iv_length:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 584, End Line: 586
/// Returns the length of the IV used with this cipher.
///
/// # Note
///
/// Ciphers that do not use an IV have an IV length of 0.
#[corresponds(EVP_CIPHER_iv_length)]
pub fn iv_length(&self) -> usize {
    unsafe { EVP_CIPHER_iv_length(self.as_ptr()) as usize }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: block_size,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs

Found method with unsafe block in block_size:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher.rs
Start Line: 594, End Line: 596
/// Returns the block size of the cipher.
///
/// # Note
///
/// Stream ciphers have a block size of 1.
#[corresponds(EVP_CIPHER_block_size)]
pub fn block_size(&self) -> usize {
    unsafe { EVP_CIPHER_block_size(self.as_ptr()) as usize }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 97, End Line: 104
/// Creates a new context.
#[corresponds(EVP_CIPHER_CTX_new)]
pub fn new() -> Result<Self, ErrorStack> {
    ffi::init();
    unsafe {
        let ptr = cvt_p(ffi::EVP_CIPHER_CTX_new())?;
        Ok(CipherCtx::from_ptr(ptr))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: copy,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in copy:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 109, End Line: 114
#[corresponds(EVP_CIPHER_CTX_copy)]
pub fn copy(&mut self, src: &CipherCtxRef) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_CIPHER_CTX_copy(self.as_ptr(), src.as_ptr()))?;
        Ok(())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cipher_init,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in cipher_init:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 156, End Line: 190
fn cipher_init(
    &mut self,
    type_: Option<&CipherRef>,
    key: Option<&[u8]>,
    iv: Option<&[u8]>,
    f: unsafe extern "C" fn(
        *mut ffi::EVP_CIPHER_CTX,
        *const ffi::EVP_CIPHER,
        *mut ffi::ENGINE,
        *const c_uchar,
        *const c_uchar,
    ) -> c_int,
) -> Result<(), ErrorStack> {
    if let Some(key) = key {
        let key_len = type_.map_or_else(|| self.key_length(), |c| c.key_length());
        assert!(key_len <= key.len());
    }
    if let Some(iv) = iv {
        let iv_len = type_.map_or_else(|| self.iv_length(), |c| c.iv_length());
        assert!(iv_len <= iv.len());
    }
    unsafe {
        cvt(
            f(
                self.as_ptr(),
                type_.map_or(ptr::null(), |p| p.as_ptr()),
                ptr::null_mut(),
                key.map_or(ptr::null(), |k| k.as_ptr()),
                iv.map_or(ptr::null(), |iv| iv.as_ptr()),
            ),
        )?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: seal_init,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in seal_init:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 206, End Line: 250
/// Initializes the context to perform envelope encryption.
///
/// Normally this is called once to set both the cipher and public keys. However, this process may be split up by
/// first providing the cipher with no public keys and then setting the public keys with no cipher.
///
/// `encrypted_keys` will contain the generated symmetric key encrypted with each corresponding asymmetric private
/// key. The generated IV will be written to `iv`.
///
/// # Panics
///
/// Panics if `pub_keys` is not the same size as `encrypted_keys`, the IV buffer is smaller than the cipher's IV
/// size, or if an IV is provided before the cipher.
#[corresponds(EVP_SealInit)]
#[cfg(not(boringssl))]
pub fn seal_init<T>(
    &mut self,
    type_: Option<&CipherRef>,
    pub_keys: &[PKey<T>],
    encrypted_keys: &mut [Vec<u8>],
    iv: Option<&mut [u8]>,
) -> Result<(), ErrorStack>
where
    T: HasPublic,
{
    assert_eq!(pub_keys.len(), encrypted_keys.len());
    if !pub_keys.is_empty() {
        let iv_len = type_.map_or_else(|| self.iv_length(), |c| c.iv_length());
        assert!(iv.as_ref().map_or(0, | b | b.len()) >= iv_len);
    }
    for (pub_key, buf) in pub_keys.iter().zip(&mut *encrypted_keys) {
        buf.resize(pub_key.size(), 0);
    }
    let mut keys = encrypted_keys.iter_mut().map(|b| b.as_mut_ptr()).collect::<Vec<_>>();
    let mut key_lengths = vec![0; pub_keys.len()];
    let pub_keys_len = i32::try_from(pub_keys.len()).unwrap();
    unsafe {
        cvt(
            ffi::EVP_SealInit(
                self.as_ptr(),
                type_.map_or(ptr::null(), |p| p.as_ptr()),
                keys.as_mut_ptr(),
                key_lengths.as_mut_ptr(),
                iv.map_or(ptr::null_mut(), |b| b.as_mut_ptr()),
                pub_keys.as_ptr() as *mut _,
                pub_keys_len,
            ),
        )?;
    }
    for (buf, len) in encrypted_keys.iter_mut().zip(key_lengths) {
        buf.truncate(len as usize);
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: open_init,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in open_init:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 263, End Line: 291
/// Initializes the context to perform envelope decryption.
///
/// Normally this is called once with all of the arguments present. However, this process may be split up by first
/// providing the cipher alone and then after providing the rest of the arguments in a second call.
///
/// # Panics
///
/// Panics if the IV buffer is smaller than the cipher's required IV size or if the IV is provided before the
/// cipher.
#[corresponds(EVP_OpenInit)]
#[cfg(not(boringssl))]
pub fn open_init<T>(
    &mut self,
    type_: Option<&CipherRef>,
    encrypted_key: &[u8],
    iv: Option<&[u8]>,
    priv_key: Option<&PKeyRef<T>>,
) -> Result<(), ErrorStack>
where
    T: HasPrivate,
{
    if priv_key.is_some() {
        let iv_len = type_.map_or_else(|| self.iv_length(), |c| c.iv_length());
        assert!(iv.map_or(0, | b | b.len()) >= iv_len);
    }
    let len = c_int::try_from(encrypted_key.len()).unwrap();
    unsafe {
        cvt(
            ffi::EVP_OpenInit(
                self.as_ptr(),
                type_.map_or(ptr::null(), |p| p.as_ptr()),
                encrypted_key.as_ptr(),
                len,
                iv.map_or(ptr::null(), |b| b.as_ptr()),
                priv_key.map_or(ptr::null_mut(), ForeignTypeRef::as_ptr),
            ),
        )?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: assert_cipher,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in assert_cipher:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 293, End Line: 297
fn assert_cipher(&self) {
    unsafe {
        assert!(! EVP_CIPHER_CTX_get0_cipher(self.as_ptr()).is_null());
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: block_size,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in block_size:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 307, End Line: 311
/// Returns the block size of the context's cipher.
///
/// Stream ciphers will report a block size of 1.
///
/// # Panics
///
/// Panics if the context has not been initialized with a cipher.
#[corresponds(EVP_CIPHER_CTX_block_size)]
pub fn block_size(&self) -> usize {
    self.assert_cipher();
    unsafe { ffi::EVP_CIPHER_CTX_block_size(self.as_ptr()) as usize }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: key_length,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in key_length:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 319, End Line: 323
/// Returns the key length of the context's cipher.
///
/// # Panics
///
/// Panics if the context has not been initialized with a cipher.
#[corresponds(EVP_CIPHER_CTX_key_length)]
pub fn key_length(&self) -> usize {
    self.assert_cipher();
    unsafe { ffi::EVP_CIPHER_CTX_key_length(self.as_ptr()) as usize }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: rand_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in rand_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 337, End Line: 348
/// Generates a random key based on the configured cipher.
///
/// # Panics
///
/// Panics if the context has not been initialized with a cipher or if the buffer is smaller than the cipher's key
/// length.
///
/// This corresponds to [`EVP_CIPHER_CTX_rand_key`].
///
/// [`EVP_CIPHER_CTX_rand_key`]: https://www.openssl.org/docs/manmaster/man3/EVP_CIPHER_CTX_rand_key.html
#[corresponds(EVP_CIPHER_CTX_rand_key)]
#[cfg(not(boringssl))]
pub fn rand_key(&self, buf: &mut [u8]) -> Result<(), ErrorStack> {
    assert!(buf.len() >= self.key_length());
    unsafe {
        cvt(ffi::EVP_CIPHER_CTX_rand_key(self.as_ptr(), buf.as_mut_ptr()))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_key_length,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in set_key_length:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 358, End Line: 369
/// Sets the length of the key expected by the context.
///
/// Only some ciphers support configurable key lengths.
///
/// # Panics
///
/// Panics if the context has not been initialized with a cipher.
#[corresponds(EVP_CIPHER_CTX_set_key_length)]
pub fn set_key_length(&mut self, len: usize) -> Result<(), ErrorStack> {
    self.assert_cipher();
    unsafe {
        cvt(ffi::EVP_CIPHER_CTX_set_key_length(self.as_ptr(), len.try_into().unwrap()))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: iv_length,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in iv_length:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 379, End Line: 383
/// Returns the length of the IV expected by this context.
///
/// Returns 0 if the cipher does not use an IV.
///
/// # Panics
///
/// Panics if the context has not been initialized with a cipher.
#[corresponds(EVP_CIPHER_CTX_iv_length)]
pub fn iv_length(&self) -> usize {
    self.assert_cipher();
    unsafe { ffi::EVP_CIPHER_CTX_iv_length(self.as_ptr()) as usize }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: num,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in num:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 395, End Line: 399
/// Returns the `num` parameter of the cipher.
///
/// Built-in ciphers typically use this to track how much of the
/// current underlying block has been "used" already.
///
/// # Panics
///
/// Panics if the context has not been initialized with a cipher.
#[corresponds(EVP_CIPHER_CTX_num)]
#[cfg(ossl110)]
pub fn num(&self) -> usize {
    self.assert_cipher();
    unsafe { ffi::EVP_CIPHER_CTX_num(self.as_ptr()) as usize }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_iv_length,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in set_iv_length:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 409, End Line: 424
/// Sets the length of the IV expected by this context.
///
/// Only some ciphers support configurable IV lengths.
///
/// # Panics
///
/// Panics if the context has not been initialized with a cipher.
#[corresponds(EVP_CIPHER_CTX_ctrl)]
pub fn set_iv_length(&mut self, len: usize) -> Result<(), ErrorStack> {
    self.assert_cipher();
    let len = c_int::try_from(len).unwrap();
    unsafe {
        cvt(
            ffi::EVP_CIPHER_CTX_ctrl(
                self.as_ptr(),
                ffi::EVP_CTRL_GCM_SET_IVLEN,
                len,
                ptr::null_mut(),
            ),
        )?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: tag_length,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in tag_length:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 437, End Line: 441
/// Returns the length of the authentication tag expected by this context.
///
/// Returns 0 if the cipher is not authenticated.
///
/// # Panics
///
/// Panics if the context has not been initialized with a cipher.
///
/// Requires OpenSSL 3.0.0 or newer.
#[corresponds(EVP_CIPHER_CTX_get_tag_length)]
#[cfg(ossl300)]
pub fn tag_length(&self) -> usize {
    self.assert_cipher();
    unsafe { ffi::EVP_CIPHER_CTX_get_tag_length(self.as_ptr()) as usize }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: tag,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in tag:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 450, End Line: 463
/// Retrieves the calculated authentication tag from the context.
///
/// This should be called after [`Self::cipher_final`], and is only supported by authenticated ciphers.
///
/// The size of the buffer indicates the size of the tag. While some ciphers support a range of tag sizes, it is
/// recommended to pick the maximum size.
#[corresponds(EVP_CIPHER_CTX_ctrl)]
pub fn tag(&self, tag: &mut [u8]) -> Result<(), ErrorStack> {
    let len = c_int::try_from(tag.len()).unwrap();
    unsafe {
        cvt(
            ffi::EVP_CIPHER_CTX_ctrl(
                self.as_ptr(),
                ffi::EVP_CTRL_GCM_GET_TAG,
                len,
                tag.as_mut_ptr() as *mut _,
            ),
        )?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_tag_length,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in set_tag_length:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 469, End Line: 482
/// Sets the length of the generated authentication tag.
///
/// This must be called when encrypting with a cipher in CCM mode to use a tag size other than the default.
#[corresponds(EVP_CIPHER_CTX_ctrl)]
pub fn set_tag_length(&mut self, len: usize) -> Result<(), ErrorStack> {
    let len = c_int::try_from(len).unwrap();
    unsafe {
        cvt(
            ffi::EVP_CIPHER_CTX_ctrl(
                self.as_ptr(),
                ffi::EVP_CTRL_GCM_SET_TAG,
                len,
                ptr::null_mut(),
            ),
        )?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_tag,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in set_tag:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 486, End Line: 499
/// Sets the authentication tag for verification during decryption.
#[corresponds(EVP_CIPHER_CTX_ctrl)]
pub fn set_tag(&mut self, tag: &[u8]) -> Result<(), ErrorStack> {
    let len = c_int::try_from(tag.len()).unwrap();
    unsafe {
        cvt(
            ffi::EVP_CIPHER_CTX_ctrl(
                self.as_ptr(),
                ffi::EVP_CTRL_GCM_SET_TAG,
                len,
                tag.as_ptr() as *mut _,
            ),
        )?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_padding,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in set_padding:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 505, End Line: 509
/// Enables or disables padding.
///
/// If padding is disabled, the plaintext must be an exact multiple of the cipher's block size.
#[corresponds(EVP_CIPHER_CTX_set_padding)]
pub fn set_padding(&mut self, padding: bool) {
    unsafe {
        ffi::EVP_CIPHER_CTX_set_padding(self.as_ptr(), padding as c_int);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_data_len,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in set_data_len:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 515, End Line: 529
/// Sets the total length of plaintext data.
///
/// This is required for ciphers operating in CCM mode.
#[corresponds(EVP_CipherUpdate)]
pub fn set_data_len(&mut self, len: usize) -> Result<(), ErrorStack> {
    let len = c_int::try_from(len).unwrap();
    unsafe {
        cvt(
            ffi::EVP_CipherUpdate(
                self.as_ptr(),
                ptr::null_mut(),
                &mut 0,
                ptr::null(),
                len,
            ),
        )?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_flags,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in set_flags:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 536, End Line: 540
/// Set ctx flags.
///
/// This function is currently used to enable AES key wrap feature supported by OpenSSL 1.0.2 or newer.
#[corresponds(EVP_CIPHER_CTX_set_flags)]
#[cfg(ossl102)]
pub fn set_flags(&mut self, flags: CipherCtxFlags) {
    unsafe {
        ffi::EVP_CIPHER_CTX_set_flags(self.as_ptr(), flags.bits());
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cipher_update,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in cipher_update:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 553, End Line: 572
/// Writes data into the context.
///
/// Providing no output buffer will cause the input to be considered additional authenticated data (AAD).
///
/// Returns the number of bytes written to `output`.
///
/// # Panics
///
/// Panics if `output` doesn't contain enough space for data to be
/// written.
#[corresponds(EVP_CipherUpdate)]
pub fn cipher_update(
    &mut self,
    input: &[u8],
    output: Option<&mut [u8]>,
) -> Result<usize, ErrorStack> {
    if let Some(output) = &output {
        let mut block_size = self.block_size();
        if block_size == 1 {
            block_size = 0;
        }
        let min_output_size = input.len() + block_size;
        assert!(
            output.len() >= min_output_size,
            "Output buffer size should be at least {} bytes.", min_output_size
        );
    }
    unsafe { self.cipher_update_unchecked(input, output) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cipher_update_inplace,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in cipher_update_inplace:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 640, End Line: 668
/// Like [`Self::cipher_update`] except that it writes output into the
/// `data` buffer. The `inlen` parameter specifies the number of bytes in
/// `data` that are considered the input. For streaming ciphers, the size of
/// `data` must be at least the input size. Otherwise, it must be at least
/// an additional block size larger.
///
/// Note: Use [`Self::cipher_update`] with no output argument to write AAD.
///
/// # Panics
///
/// This function panics if the input size cannot be represented as `int` or
/// exceeds the buffer size, or if the output buffer does not contain enough
/// additional space.
#[corresponds(EVP_CipherUpdate)]
pub fn cipher_update_inplace(
    &mut self,
    data: &mut [u8],
    inlen: usize,
) -> Result<usize, ErrorStack> {
    assert!(inlen <= data.len(), "Input size may not exceed buffer size");
    let block_size = self.block_size();
    if block_size != 1 {
        assert!(
            data.len() >= inlen + block_size,
            "Output buffer size must be at least {} bytes.", inlen + block_size
        );
    }
    let inlen = c_int::try_from(inlen).unwrap();
    let mut outlen = 0;
    unsafe {
        cvt(
            ffi::EVP_CipherUpdate(
                self.as_ptr(),
                data.as_mut_ptr(),
                &mut outlen,
                data.as_ptr(),
                inlen,
            ),
        )
    }?;
    Ok(outlen as usize)
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cipher_final,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs

Found method with unsafe block in cipher_final:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cipher_ctx.rs
Start Line: 680, End Line: 687
/// Finalizes the encryption or decryption process.
///
/// Any remaining data will be written to the output buffer.
///
/// Returns the number of bytes written to `output`.
///
/// # Panics
///
/// Panics if `output` is smaller than the cipher's block size.
#[corresponds(EVP_CipherFinal)]
pub fn cipher_final(&mut self, output: &mut [u8]) -> Result<usize, ErrorStack> {
    let block_size = self.block_size();
    if block_size > 1 {
        assert!(output.len() >= block_size);
    }
    unsafe { self.cipher_final_unchecked(output) }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cms.rs
-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: decrypt,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cms.rs

Found method with unsafe block in decrypt:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cms.rs
Start Line: 76, End Line: 96
/// Given the sender's private key, `pkey` and the recipient's certificate, `cert`,
/// decrypt the data in `self`.
#[corresponds(CMS_decrypt)]
pub fn decrypt<T>(&self, pkey: &PKeyRef<T>, cert: &X509) -> Result<Vec<u8>, ErrorStack>
where
    T: HasPrivate,
{
    unsafe {
        let pkey = pkey.as_ptr();
        let cert = cert.as_ptr();
        let out = MemBio::new()?;
        cvt(
            ffi::CMS_decrypt(self.as_ptr(), pkey, cert, ptr::null_mut(), out.as_ptr(), 0),
        )?;
        Ok(out.get_buf().to_owned())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: decrypt_without_cert_check,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cms.rs

Found method with unsafe block in decrypt_without_cert_check:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cms.rs
Start Line: 104, End Line: 123
/// Given the sender's private key, `pkey`,
/// decrypt the data in `self` without validating the recipient certificate.
///
/// *Warning*: Not checking the recipient certificate may leave you vulnerable to Bleichenbacher's attack on PKCS#1 v1.5 RSA padding.
#[corresponds(CMS_decrypt)]
pub fn decrypt_without_cert_check<T>(
    &self,
    pkey: &PKeyRef<T>,
) -> Result<Vec<u8>, ErrorStack>
where
    T: HasPrivate,
{
    unsafe {
        let pkey = pkey.as_ptr();
        let out = MemBio::new()?;
        cvt(
            ffi::CMS_decrypt(
                self.as_ptr(),
                pkey,
                ptr::null_mut(),
                ptr::null_mut(),
                out.as_ptr(),
                0,
            ),
        )?;
        Ok(out.get_buf().to_owned())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: smime_read_cms,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cms.rs

Found method with unsafe block in smime_read_cms:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cms.rs
Start Line: 143, End Line: 151
/// Parses a smime formatted `vec` of bytes into a `CmsContentInfo`.
#[corresponds(SMIME_read_CMS)]
pub fn smime_read_cms(smime: &[u8]) -> Result<CmsContentInfo, ErrorStack> {
    unsafe {
        let bio = MemBioSlice::new(smime)?;
        let cms = cvt_p(ffi::SMIME_read_CMS(bio.as_ptr(), ptr::null_mut()))?;
        Ok(CmsContentInfo::from_ptr(cms))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 7 statements, Complex: false, With_SAFETY_comment: false, Name: sign,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cms.rs

Found method with unsafe block in sign:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cms.rs
Start Line: 174, End Line: 204
/// Given a signing cert `signcert`, private key `pkey`, a certificate stack `certs`,
/// data `data` and flags `flags`, create a CmsContentInfo struct.
///
/// All arguments are optional.
#[corresponds(CMS_sign)]
pub fn sign<T>(
    signcert: Option<&X509Ref>,
    pkey: Option<&PKeyRef<T>>,
    certs: Option<&StackRef<X509>>,
    data: Option<&[u8]>,
    flags: CMSOptions,
) -> Result<CmsContentInfo, ErrorStack>
where
    T: HasPrivate,
{
    unsafe {
        let signcert = signcert.map_or(ptr::null_mut(), |p| p.as_ptr());
        let pkey = pkey.map_or(ptr::null_mut(), |p| p.as_ptr());
        let data_bio = match data {
            Some(data) => Some(MemBioSlice::new(data)?),
            None => None,
        };
        let data_bio_ptr = data_bio.as_ref().map_or(ptr::null_mut(), |p| p.as_ptr());
        let certs = certs.map_or(ptr::null_mut(), |p| p.as_ptr());
        let cms = cvt_p(
            ffi::CMS_sign(signcert, pkey, certs, data_bio_ptr, flags.bits()),
        )?;
        Ok(CmsContentInfo::from_ptr(cms))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: encrypt,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cms.rs

Found method with unsafe block in encrypt:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cms.rs
Start Line: 213, End Line: 231
/// Given a certificate stack `certs`, data `data`, cipher `cipher` and flags `flags`,
/// create a CmsContentInfo struct.
///
/// OpenSSL documentation at [`CMS_encrypt`]
///
/// [`CMS_encrypt`]: https://www.openssl.org/docs/manmaster/man3/CMS_encrypt.html
#[corresponds(CMS_encrypt)]
pub fn encrypt(
    certs: &StackRef<X509>,
    data: &[u8],
    cipher: Cipher,
    flags: CMSOptions,
) -> Result<CmsContentInfo, ErrorStack> {
    unsafe {
        let data_bio = MemBioSlice::new(data)?;
        let cms = cvt_p(
            ffi::CMS_encrypt(
                certs.as_ptr(),
                data_bio.as_ptr(),
                cipher.as_ptr(),
                flags.bits(),
            ),
        )?;
        Ok(CmsContentInfo::from_ptr(cms))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 8 statements, Complex: true, With_SAFETY_comment: false, Name: verify,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cms.rs

Found method with unsafe block in verify:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\cms.rs
Start Line: 241, End Line: 277
/// Verify this CmsContentInfo's signature,
/// This will search the 'certs' list for the signing certificate.
/// Additional certificates, needed for building the certificate chain, may be
/// given in 'store' as well as additional CRLs.
/// A detached signature may be passed in `detached_data`. The signed content
/// without signature, will be copied into output_data if it is present.
///
#[corresponds(CMS_verify)]
pub fn verify(
    &mut self,
    certs: Option<&StackRef<X509>>,
    store: Option<&X509StoreRef>,
    detached_data: Option<&[u8]>,
    output_data: Option<&mut Vec<u8>>,
    flags: CMSOptions,
) -> Result<(), ErrorStack> {
    unsafe {
        let certs_ptr = certs.map_or(ptr::null_mut(), |p| p.as_ptr());
        let store_ptr = store.map_or(ptr::null_mut(), |p| p.as_ptr());
        let detached_data_bio = match detached_data {
            Some(data) => Some(MemBioSlice::new(data)?),
            None => None,
        };
        let detached_data_bio_ptr = detached_data_bio
            .as_ref()
            .map_or(ptr::null_mut(), |p| p.as_ptr());
        let out_bio = MemBio::new()?;
        cvt(
            ffi::CMS_verify(
                self.as_ptr(),
                certs_ptr,
                store_ptr,
                detached_data_bio_ptr,
                out_bio.as_ptr(),
                flags.bits(),
            ),
        )?;
        if let Some(data) = output_data {
            data.clear();
            data.extend_from_slice(out_bio.get_buf());
        }
        Ok(())
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\conf.rs
-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: default,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\conf.rs

Found method with unsafe block in default:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\conf.rs
Start Line: 24, End Line: 31
/// Retrieve handle to the default OpenSSL configuration file processing function.
#[corresponds(NCONF_default)]
#[allow(clippy::should_implement_trait)]
pub fn default() -> ConfMethod {
    unsafe {
        ffi::init();
        ConfMethod(ffi::NCONF_default())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\conf.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\conf.rs
Start Line: 59, End Line: 61
/// Create a configuration parser.
///
/// # Examples
///
/// ```
/// use openssl::conf::{Conf, ConfMethod};
///
/// let conf = Conf::new(ConfMethod::default());
/// ```
#[corresponds(NCONF_new)]
pub fn new(method: ConfMethod) -> Result<Conf, ErrorStack> {
    unsafe { cvt_p(ffi::NCONF_new(method.as_ptr())).map(Conf) }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\derive.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\derive.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\derive.rs
Start Line: 74, End Line: 83
/// Creates a new `Deriver` using the provided private key.
///
/// This corresponds to [`EVP_PKEY_derive_init`].
///
/// [`EVP_PKEY_derive_init`]: https://www.openssl.org/docs/manmaster/crypto/EVP_PKEY_derive_init.html
pub fn new<T>(key: &'a PKeyRef<T>) -> Result<Deriver<'a>, ErrorStack>
where
    T: HasPrivate,
{
    unsafe {
        cvt_p(ffi::EVP_PKEY_CTX_new(key.as_ptr(), ptr::null_mut()))
            .map(|p| Deriver(p, PhantomData))
            .and_then(|ctx| cvt(ffi::EVP_PKEY_derive_init(ctx.0)).map(|_| ctx))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_peer,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\derive.rs

Found method with unsafe block in set_peer:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\derive.rs
Start Line: 87, End Line: 92
/// Sets the peer key used for secret derivation.
#[corresponds(EVP_PKEY_derive_set_peer)]
pub fn set_peer<T>(&mut self, key: &'a PKeyRef<T>) -> Result<(), ErrorStack>
where
    T: HasPublic,
{
    unsafe { cvt(ffi::EVP_PKEY_derive_set_peer(self.0, key.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_peer_ex,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\derive.rs

Found method with unsafe block in set_peer_ex:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\derive.rs
Start Line: 99, End Line: 115
/// Sets the peer key used for secret derivation along with optionally validating the peer public key.
///
/// Requires OpenSSL 3.0.0 or newer.
#[corresponds(EVP_PKEY_derive_set_peer_ex)]
#[cfg(ossl300)]
pub fn set_peer_ex<T>(
    &mut self,
    key: &'a PKeyRef<T>,
    validate_peer: bool,
) -> Result<(), ErrorStack>
where
    T: HasPublic,
{
    unsafe {
        cvt(ffi::EVP_PKEY_derive_set_peer_ex(self.0, key.as_ptr(), validate_peer as i32))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: len,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\derive.rs

Found method with unsafe block in len:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\derive.rs
Start Line: 125, End Line: 130
/// Returns the size of the shared secret.
///
/// It can be used to size the buffer passed to [`Deriver::derive`].
///
/// This corresponds to [`EVP_PKEY_derive`].
///
/// [`Deriver::derive`]: #method.derive
/// [`EVP_PKEY_derive`]: https://www.openssl.org/docs/manmaster/crypto/EVP_PKEY_derive_init.html
pub fn len(&mut self) -> Result<usize, ErrorStack> {
    unsafe {
        let mut len = 0;
        cvt(ffi::EVP_PKEY_derive(self.0, ptr::null_mut(), &mut len)).map(|_| len)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: derive,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\derive.rs

Found method with unsafe block in derive:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\derive.rs
Start Line: 139, End Line: 149
/// Derives a shared secret between the two keys, writing it into the buffer.
///
/// Returns the number of bytes written.
///
/// This corresponds to [`EVP_PKEY_derive`].
///
/// [`EVP_PKEY_derive`]: https://www.openssl.org/docs/manmaster/crypto/EVP_PKEY_derive_init.html
pub fn derive(&mut self, buf: &mut [u8]) -> Result<usize, ErrorStack> {
    let mut len = buf.len();
    unsafe {
        cvt(ffi::EVP_PKEY_derive(self.0, buf.as_mut_ptr() as *mut _, &mut len))
            .map(|_| len)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: drop,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\derive.rs

Found method with unsafe block in drop:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\derive.rs
Start Line: 167, End Line: 171
fn drop(&mut self) {
    unsafe {
        ffi::EVP_PKEY_CTX_free(self.0);
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs
-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: check_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs

Found method with unsafe block in check_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs
Start Line: 45, End Line: 51
/// Validates DH parameters for correctness
#[corresponds(DH_check_key)]
pub fn check_key(&self) -> Result<bool, ErrorStack> {
    unsafe {
        let mut codes = 0;
        cvt(ffi::DH_check(self.as_ptr(), &mut codes))?;
        Ok(codes == 0)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: from_pqg,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs

Found method with unsafe block in from_pqg:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs
Start Line: 61, End Line: 77
/// Creates a DH instance based upon the given primes and generator params.
#[corresponds(DH_set0_pqg)]
pub fn from_pqg(
    prime_p: BigNum,
    prime_q: Option<BigNum>,
    generator: BigNum,
) -> Result<Dh<Params>, ErrorStack> {
    unsafe {
        let dh = Dh::from_ptr(cvt_p(ffi::DH_new())?);
        cvt(
            DH_set0_pqg(
                dh.0,
                prime_p.as_ptr(),
                prime_q.as_ref().map_or(ptr::null_mut(), |q| q.as_ptr()),
                generator.as_ptr(),
            ),
        )?;
        mem::forget((prime_p, prime_q, generator));
        Ok(dh)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: set_public_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs

Found method with unsafe block in set_public_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs
Start Line: 80, End Line: 87
/// Sets the public key on the DH object.
pub fn set_public_key(self, pub_key: BigNum) -> Result<Dh<Public>, ErrorStack> {
    unsafe {
        let dh_ptr = self.0;
        cvt(DH_set0_key(dh_ptr, pub_key.as_ptr(), ptr::null_mut()))?;
        mem::forget((self, pub_key));
        Ok(Dh::from_ptr(dh_ptr))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 6 statements, Complex: false, With_SAFETY_comment: false, Name: set_private_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs

Found method with unsafe block in set_private_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs
Start Line: 90, End Line: 100
/// Sets the private key on the DH object and recomputes the public key.
pub fn set_private_key(self, priv_key: BigNum) -> Result<Dh<Private>, ErrorStack> {
    unsafe {
        let dh_ptr = self.0;
        cvt(DH_set0_key(dh_ptr, ptr::null_mut(), priv_key.as_ptr()))?;
        mem::forget(priv_key);
        cvt(ffi::DH_generate_key(dh_ptr))?;
        mem::forget(self);
        Ok(Dh::from_ptr(dh_ptr))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: set_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs

Found method with unsafe block in set_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs
Start Line: 103, End Line: 110
/// Sets the public and private keys on the DH object.
pub fn set_key(
    self,
    pub_key: BigNum,
    priv_key: BigNum,
) -> Result<Dh<Private>, ErrorStack> {
    unsafe {
        let dh_ptr = self.0;
        cvt(DH_set0_key(dh_ptr, pub_key.as_ptr(), priv_key.as_ptr()))?;
        mem::forget((self, pub_key, priv_key));
        Ok(Dh::from_ptr(dh_ptr))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: generate_params,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs

Found method with unsafe block in generate_params:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs
Start Line: 114, End Line: 125
/// Generates DH params based on the given `prime_len` and a fixed `generator` value.
#[corresponds(DH_generate_parameters_ex)]
pub fn generate_params(
    prime_len: u32,
    generator: u32,
) -> Result<Dh<Params>, ErrorStack> {
    unsafe {
        let dh = Dh::from_ptr(cvt_p(ffi::DH_new())?);
        cvt(
            ffi::DH_generate_parameters_ex(
                dh.0,
                prime_len as i32,
                generator as i32,
                ptr::null_mut(),
            ),
        )?;
        Ok(dh)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: generate_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs

Found method with unsafe block in generate_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs
Start Line: 129, End Line: 136
/// Generates a public and a private key based on the DH params.
#[corresponds(DH_generate_key)]
pub fn generate_key(self) -> Result<Dh<Private>, ErrorStack> {
    unsafe {
        let dh_ptr = self.0;
        cvt(ffi::DH_generate_key(dh_ptr))?;
        mem::forget(self);
        Ok(Dh::from_ptr(dh_ptr))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: get_1024_160,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs

Found method with unsafe block in get_1024_160:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs
Start Line: 159, End Line: 164
/// Requires OpenSSL 1.0.2 or newer.
#[corresponds(DH_get_1024_160)]
#[cfg(any(ossl102, ossl110))]
pub fn get_1024_160() -> Result<Dh<Params>, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(ffi::DH_get_1024_160()).map(|p| Dh::from_ptr(p))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: get_2048_224,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs

Found method with unsafe block in get_2048_224:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs
Start Line: 169, End Line: 174
/// Requires OpenSSL 1.0.2 or newer.
#[corresponds(DH_get_2048_224)]
#[cfg(any(ossl102, ossl110))]
pub fn get_2048_224() -> Result<Dh<Params>, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(ffi::DH_get_2048_224()).map(|p| Dh::from_ptr(p))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: get_2048_256,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs

Found method with unsafe block in get_2048_256:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs
Start Line: 179, End Line: 184
/// Requires OpenSSL 1.0.2 or newer.
#[corresponds(DH_get_2048_256)]
#[cfg(any(ossl102, ossl110))]
pub fn get_2048_256() -> Result<Dh<Params>, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(ffi::DH_get_2048_256()).map(|p| Dh::from_ptr(p))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: prime_p,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs

Found method with unsafe block in prime_p:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs
Start Line: 193, End Line: 199
/// Returns the prime `p` from the DH instance.
#[corresponds(DH_get0_pqg)]
pub fn prime_p(&self) -> &BigNumRef {
    let mut p = ptr::null();
    unsafe {
        DH_get0_pqg(self.as_ptr(), &mut p, ptr::null_mut(), ptr::null_mut());
        BigNumRef::from_ptr(p as *mut _)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: prime_q,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs

Found method with unsafe block in prime_q:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs
Start Line: 203, End Line: 213
/// Returns the prime `q` from the DH instance.
#[corresponds(DH_get0_pqg)]
pub fn prime_q(&self) -> Option<&BigNumRef> {
    let mut q = ptr::null();
    unsafe {
        DH_get0_pqg(self.as_ptr(), ptr::null_mut(), &mut q, ptr::null_mut());
        if q.is_null() { None } else { Some(BigNumRef::from_ptr(q as *mut _)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: generator,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs

Found method with unsafe block in generator:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs
Start Line: 217, End Line: 223
/// Returns the generator from the DH instance.
#[corresponds(DH_get0_pqg)]
pub fn generator(&self) -> &BigNumRef {
    let mut g = ptr::null();
    unsafe {
        DH_get0_pqg(self.as_ptr(), ptr::null_mut(), ptr::null_mut(), &mut g);
        BigNumRef::from_ptr(g as *mut _)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: public_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs

Found method with unsafe block in public_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs
Start Line: 232, End Line: 238
/// Returns the public key from the DH instance.
#[corresponds(DH_get0_key)]
pub fn public_key(&self) -> &BigNumRef {
    let mut pub_key = ptr::null();
    unsafe {
        DH_get0_key(self.as_ptr(), &mut pub_key, ptr::null_mut());
        BigNumRef::from_ptr(pub_key as *mut _)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: compute_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs

Found method with unsafe block in compute_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs
Start Line: 247, End Line: 258
/// Computes a shared secret from the own private key and the given `public_key`.
#[corresponds(DH_compute_key)]
pub fn compute_key(&self, public_key: &BigNumRef) -> Result<Vec<u8>, ErrorStack> {
    unsafe {
        let key_len = ffi::DH_size(self.as_ptr());
        let mut key = vec![0u8; key_len as usize];
        cvt(ffi::DH_compute_key(key.as_mut_ptr(), public_key.as_ptr(), self.as_ptr()))?;
        Ok(key)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: private_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs

Found method with unsafe block in private_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dh.rs
Start Line: 262, End Line: 268
/// Returns the private key from the DH instance.
#[corresponds(DH_get0_key)]
pub fn private_key(&self) -> &BigNumRef {
    let mut priv_key = ptr::null();
    unsafe {
        DH_get0_key(self.as_ptr(), ptr::null_mut(), &mut priv_key);
        BigNumRef::from_ptr(priv_key as *mut _)
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs
-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: to_owned,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs

Found method with unsafe block in to_owned:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs
Start Line: 74, End Line: 79
fn to_owned(&self) -> Dsa<T> {
    unsafe {
        ffi::DSA_up_ref(self.as_ptr());
        Dsa::from_ptr(self.as_ptr())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: pub_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs

Found method with unsafe block in pub_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs
Start Line: 104, End Line: 110
/// Returns a reference to the public key component of `self`.
#[corresponds(DSA_get0_key)]
pub fn pub_key(&self) -> &BigNumRef {
    unsafe {
        let mut pub_key = ptr::null();
        DSA_get0_key(self.as_ptr(), &mut pub_key, ptr::null_mut());
        BigNumRef::from_const_ptr(pub_key)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: priv_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs

Found method with unsafe block in priv_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs
Start Line: 140, End Line: 146
/// Returns a reference to the private key component of `self`.
#[corresponds(DSA_get0_key)]
pub fn priv_key(&self) -> &BigNumRef {
    unsafe {
        let mut priv_key = ptr::null();
        DSA_get0_key(self.as_ptr(), ptr::null_mut(), &mut priv_key);
        BigNumRef::from_const_ptr(priv_key)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: size,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs

Found method with unsafe block in size:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs
Start Line: 155, End Line: 157
/// Returns the maximum size of the signature output by `self` in bytes.
#[corresponds(DSA_size)]
pub fn size(&self) -> u32 {
    unsafe { ffi::DSA_size(self.as_ptr()) as u32 }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: p,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs

Found method with unsafe block in p:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs
Start Line: 161, End Line: 167
/// Returns the DSA prime parameter of `self`.
#[corresponds(DSA_get0_pqg)]
pub fn p(&self) -> &BigNumRef {
    unsafe {
        let mut p = ptr::null();
        DSA_get0_pqg(self.as_ptr(), &mut p, ptr::null_mut(), ptr::null_mut());
        BigNumRef::from_const_ptr(p)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: q,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs

Found method with unsafe block in q:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs
Start Line: 171, End Line: 177
/// Returns the DSA sub-prime parameter of `self`.
#[corresponds(DSA_get0_pqg)]
pub fn q(&self) -> &BigNumRef {
    unsafe {
        let mut q = ptr::null();
        DSA_get0_pqg(self.as_ptr(), ptr::null_mut(), &mut q, ptr::null_mut());
        BigNumRef::from_const_ptr(q)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: g,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs

Found method with unsafe block in g:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs
Start Line: 181, End Line: 187
/// Returns the DSA base parameter of `self`.
#[corresponds(DSA_get0_pqg)]
pub fn g(&self) -> &BigNumRef {
    unsafe {
        let mut g = ptr::null();
        DSA_get0_pqg(self.as_ptr(), ptr::null_mut(), ptr::null_mut(), &mut g);
        BigNumRef::from_const_ptr(g)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: from_pqg,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs

Found method with unsafe block in from_pqg:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs
Start Line: 197, End Line: 204
/// Creates a DSA params based upon the given parameters.
#[corresponds(DSA_set0_pqg)]
pub fn from_pqg(p: BigNum, q: BigNum, g: BigNum) -> Result<Dsa<Params>, ErrorStack> {
    unsafe {
        let dsa = Dsa::from_ptr(cvt_p(ffi::DSA_new())?);
        cvt(DSA_set0_pqg(dsa.0, p.as_ptr(), q.as_ptr(), g.as_ptr()))?;
        mem::forget((p, q, g));
        Ok(dsa)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: generate_params,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs

Found method with unsafe block in generate_params:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs
Start Line: 208, End Line: 223
/// Generates DSA params based on the given number of bits.
#[corresponds(DSA_generate_parameters_ex)]
pub fn generate_params(bits: u32) -> Result<Dsa<Params>, ErrorStack> {
    ffi::init();
    unsafe {
        let dsa = Dsa::from_ptr(cvt_p(ffi::DSA_new())?);
        cvt(
            ffi::DSA_generate_parameters_ex(
                dsa.0,
                bits as BitType,
                ptr::null(),
                0,
                ptr::null_mut(),
                ptr::null_mut(),
                ptr::null_mut(),
            ),
        )?;
        Ok(dsa)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: generate_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs

Found method with unsafe block in generate_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs
Start Line: 227, End Line: 234
/// Generates a private key based on the DSA params.
#[corresponds(DSA_generate_key)]
pub fn generate_key(self) -> Result<Dsa<Private>, ErrorStack> {
    unsafe {
        let dsa_ptr = self.0;
        cvt(ffi::DSA_generate_key(dsa_ptr))?;
        mem::forget(self);
        Ok(Dsa::from_ptr(dsa_ptr))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 6 statements, Complex: false, With_SAFETY_comment: false, Name: from_private_components,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs

Found method with unsafe block in from_private_components:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs
Start Line: 251, End Line: 267
/// Create a DSA key pair with the given parameters
///
/// `p`, `q` and `g` are the common parameters.
/// `priv_key` is the private component of the key pair.
/// `pub_key` is the public component of the key. Can be computed via `g^(priv_key) mod p`
pub fn from_private_components(
    p: BigNum,
    q: BigNum,
    g: BigNum,
    priv_key: BigNum,
    pub_key: BigNum,
) -> Result<Dsa<Private>, ErrorStack> {
    ffi::init();
    unsafe {
        let dsa = Dsa::from_ptr(cvt_p(ffi::DSA_new())?);
        cvt(DSA_set0_pqg(dsa.0, p.as_ptr(), q.as_ptr(), g.as_ptr()))?;
        mem::forget((p, q, g));
        cvt(DSA_set0_key(dsa.0, pub_key.as_ptr(), priv_key.as_ptr()))?;
        mem::forget((pub_key, priv_key));
        Ok(dsa)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 6 statements, Complex: false, With_SAFETY_comment: false, Name: from_public_components,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs

Found method with unsafe block in from_public_components:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs
Start Line: 293, End Line: 308
/// Create a new DSA key with only public components.
///
/// `p`, `q` and `g` are the common parameters.
/// `pub_key` is the public component of the key.
pub fn from_public_components(
    p: BigNum,
    q: BigNum,
    g: BigNum,
    pub_key: BigNum,
) -> Result<Dsa<Public>, ErrorStack> {
    ffi::init();
    unsafe {
        let dsa = Dsa::from_ptr(cvt_p(ffi::DSA_new())?);
        cvt(DSA_set0_pqg(dsa.0, p.as_ptr(), q.as_ptr(), g.as_ptr()))?;
        mem::forget((p, q, g));
        cvt(DSA_set0_key(dsa.0, pub_key.as_ptr(), ptr::null_mut()))?;
        mem::forget(pub_key);
        Ok(dsa)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: r,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs

Found method with unsafe block in r:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs
Start Line: 477, End Line: 483
/// Returns internal component `r` of an `DsaSig`.
#[corresponds(DSA_SIG_get0)]
pub fn r(&self) -> &BigNumRef {
    unsafe {
        let mut r = ptr::null();
        DSA_SIG_get0(self.as_ptr(), &mut r, ptr::null_mut());
        BigNumRef::from_const_ptr(r)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: s,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs

Found method with unsafe block in s:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\dsa.rs
Start Line: 487, End Line: 493
/// Returns internal component `s` of an `DsaSig`.
#[corresponds(DSA_SIG_get0)]
pub fn s(&self) -> &BigNumRef {
    unsafe {
        let mut s = ptr::null();
        DSA_SIG_get0(self.as_ptr(), ptr::null_mut(), &mut s);
        BigNumRef::from_const_ptr(s)
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: from_curve_name,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in from_curve_name:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 141, End Line: 146
/// Returns the group of a standard named curve.
///
/// # Examples
///
/// ```
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// use openssl::nid::Nid;
/// use openssl::ec::{EcGroup, EcKey};
///
/// let nid = Nid::X9_62_PRIME256V1; // NIST P-256 curve
/// let group = EcGroup::from_curve_name(nid)?;
/// let key = EcKey::generate(&group)?;
/// # Ok(()) }
/// ```
#[corresponds(EC_GROUP_new_by_curve_name)]
pub fn from_curve_name(nid: Nid) -> Result<EcGroup, ErrorStack> {
    unsafe {
        init();
        cvt_p(ffi::EC_GROUP_new_by_curve_name(nid.as_raw())).map(EcGroup)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: from_components,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in from_components:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 150, End Line: 165
/// Returns the group for given parameters
#[corresponds(EC_GROUP_new_curve_GFp)]
pub fn from_components(
    p: BigNum,
    a: BigNum,
    b: BigNum,
    ctx: &mut BigNumContextRef,
) -> Result<EcGroup, ErrorStack> {
    unsafe {
        cvt_p(
                ffi::EC_GROUP_new_curve_GFp(
                    p.as_ptr(),
                    a.as_ptr(),
                    b.as_ptr(),
                    ctx.as_ptr(),
                ),
            )
            .map(EcGroup)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: components_gfp,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in components_gfp:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 172, End Line: 189
/// Places the components of a curve over a prime field in the provided `BigNum`s.
/// The components make up the formula `y^2 mod p = x^3 + ax + b mod p`.
#[corresponds(EC_GROUP_get_curve_GFp)]
pub fn components_gfp(
    &self,
    p: &mut BigNumRef,
    a: &mut BigNumRef,
    b: &mut BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::EC_GROUP_get_curve_GFp(
                    self.as_ptr(),
                    p.as_ptr(),
                    a.as_ptr(),
                    b.as_ptr(),
                    ctx.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: components_gf2m,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in components_gf2m:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 199, End Line: 216
/// Places the components of a curve over a binary field in the provided `BigNum`s.
/// The components make up the formula `y^2 + xy = x^3 + ax^2 + b`.
///
/// In this form `p` relates to the irreducible polynomial.  Each bit represents
/// a term in the polynomial.  It will be set to 3 `1`s or 5 `1`s depending on
/// using a trinomial or pentanomial.
#[corresponds(EC_GROUP_get_curve_GF2m)]
#[cfg(not(osslconf = "OPENSSL_NO_EC2M"))]
pub fn components_gf2m(
    &self,
    p: &mut BigNumRef,
    a: &mut BigNumRef,
    b: &mut BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::EC_GROUP_get_curve_GF2m(
                    self.as_ptr(),
                    p.as_ptr(),
                    a.as_ptr(),
                    b.as_ptr(),
                    ctx.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cofactor,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in cofactor:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 220, End Line: 233
/// Places the cofactor of the group in the provided `BigNum`.
#[corresponds(EC_GROUP_get_cofactor)]
pub fn cofactor(
    &self,
    cofactor: &mut BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EC_GROUP_get_cofactor(self.as_ptr(), cofactor.as_ptr(), ctx.as_ptr()))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: degree,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in degree:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 237, End Line: 239
/// Returns the degree of the curve.
#[corresponds(EC_GROUP_get_degree)]
pub fn degree(&self) -> u32 {
    unsafe { ffi::EC_GROUP_get_degree(self.as_ptr()) as u32 }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: order_bits,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in order_bits:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 244, End Line: 246
/// Returns the number of bits in the group order.
#[corresponds(EC_GROUP_order_bits)]
#[cfg(ossl110)]
pub fn order_bits(&self) -> u32 {
    unsafe { ffi::EC_GROUP_order_bits(self.as_ptr()) as u32 }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: generator,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in generator:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 250, End Line: 255
/// Returns the generator for the given curve as an [`EcPoint`].
#[corresponds(EC_GROUP_get0_generator)]
pub fn generator(&self) -> &EcPointRef {
    unsafe {
        let ptr = ffi::EC_GROUP_get0_generator(self.as_ptr());
        EcPointRef::from_const_ptr(ptr)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_generator,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in set_generator:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 259, End Line: 274
/// Sets the generator point for the given curve
#[corresponds(EC_GROUP_set_generator)]
pub fn set_generator(
    &mut self,
    generator: EcPoint,
    order: BigNum,
    cofactor: BigNum,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::EC_GROUP_set_generator(
                    self.as_ptr(),
                    generator.as_ptr(),
                    order.as_ptr(),
                    cofactor.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: order,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in order:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 278, End Line: 291
/// Places the order of the curve in the provided `BigNum`.
#[corresponds(EC_GROUP_get_order)]
pub fn order(
    &self,
    order: &mut BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EC_GROUP_get_order(self.as_ptr(), order.as_ptr(), ctx.as_ptr()))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_asn1_flag,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in set_asn1_flag:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 299, End Line: 303
/// Sets the flag determining if the group corresponds to a named curve or must be explicitly
/// parameterized.
///
/// This defaults to `EXPLICIT_CURVE` in OpenSSL 1.0.1 and 1.0.2, but `NAMED_CURVE` in OpenSSL
/// 1.1.0.
#[corresponds(EC_GROUP_set_asn1_flag)]
pub fn set_asn1_flag(&mut self, flag: Asn1Flag) {
    unsafe {
        ffi::EC_GROUP_set_asn1_flag(self.as_ptr(), flag.0);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: asn1_flag,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in asn1_flag:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 307, End Line: 309
/// Gets the flag determining if the group corresponds to a named curve.
#[corresponds(EC_GROUP_get_asn1_flag)]
pub fn asn1_flag(&self) -> Asn1Flag {
    unsafe { Asn1Flag(ffi::EC_GROUP_get_asn1_flag(self.as_ptr())) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: curve_name,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in curve_name:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 313, End Line: 320
/// Returns the name of the curve, if a name is associated.
#[corresponds(EC_GROUP_get_curve_name)]
pub fn curve_name(&self) -> Option<Nid> {
    let nid = unsafe { ffi::EC_GROUP_get_curve_name(self.as_ptr()) };
    if nid > 0 { Some(Nid::from_raw(nid)) } else { None }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: add,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in add:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 336, End Line: 353
/// Computes `a + b`, storing the result in `self`.
#[corresponds(EC_POINT_add)]
pub fn add(
    &mut self,
    group: &EcGroupRef,
    a: &EcPointRef,
    b: &EcPointRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::EC_POINT_add(
                    group.as_ptr(),
                    self.as_ptr(),
                    a.as_ptr(),
                    b.as_ptr(),
                    ctx.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: mul,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in mul:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 357, End Line: 376
/// Computes `q * m`, storing the result in `self`.
#[corresponds(EC_POINT_mul)]
pub fn mul(
    &mut self,
    group: &EcGroupRef,
    q: &EcPointRef,
    m: &BigNumRef,
    ctx: &BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::EC_POINT_mul(
                    group.as_ptr(),
                    self.as_ptr(),
                    ptr::null(),
                    q.as_ptr(),
                    m.as_ptr(),
                    ctx.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: mul_generator,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in mul_generator:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 380, End Line: 398
/// Computes `generator * n`, storing the result in `self`.
#[corresponds(EC_POINT_mul)]
pub fn mul_generator(
    &mut self,
    group: &EcGroupRef,
    n: &BigNumRef,
    ctx: &BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::EC_POINT_mul(
                    group.as_ptr(),
                    self.as_ptr(),
                    n.as_ptr(),
                    ptr::null(),
                    ptr::null(),
                    ctx.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: mul_full,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in mul_full:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 402, End Line: 421
/// Computes `generator * n + q * m`, storing the result in `self`.
#[corresponds(EC_POINT_mul)]
pub fn mul_full(
    &mut self,
    group: &EcGroupRef,
    n: &BigNumRef,
    q: &EcPointRef,
    m: &BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::EC_POINT_mul(
                    group.as_ptr(),
                    self.as_ptr(),
                    n.as_ptr(),
                    q.as_ptr(),
                    m.as_ptr(),
                    ctx.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: invert,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in invert:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 426, End Line: 435
/// Inverts `self`.
#[corresponds(EC_POINT_invert)]
pub fn invert(
    &mut self,
    group: &EcGroupRef,
    ctx: &BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EC_POINT_invert(group.as_ptr(), self.as_ptr(), ctx.as_ptr()))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: true, With_SAFETY_comment: false, Name: to_bytes,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in to_bytes:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 439, End Line: 472
/// Serializes the point to a binary representation.
#[corresponds(EC_POINT_point2oct)]
pub fn to_bytes(
    &self,
    group: &EcGroupRef,
    form: PointConversionForm,
    ctx: &mut BigNumContextRef,
) -> Result<Vec<u8>, ErrorStack> {
    unsafe {
        let len = ffi::EC_POINT_point2oct(
            group.as_ptr(),
            self.as_ptr(),
            form.0,
            ptr::null_mut(),
            0,
            ctx.as_ptr(),
        );
        if len == 0 {
            return Err(ErrorStack::get());
        }
        let mut buf = vec![0; len];
        let len = ffi::EC_POINT_point2oct(
            group.as_ptr(),
            self.as_ptr(),
            form.0,
            buf.as_mut_ptr(),
            len,
            ctx.as_ptr(),
        );
        if len == 0 { Err(ErrorStack::get()) } else { Ok(buf) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: to_hex_str,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in to_hex_str:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 477, End Line: 492
/// Serializes the point to a hexadecimal string representation.
#[corresponds(EC_POINT_point2hex)]
#[cfg(not(boringssl))]
pub fn to_hex_str(
    &self,
    group: &EcGroupRef,
    form: PointConversionForm,
    ctx: &mut BigNumContextRef,
) -> Result<OpensslString, ErrorStack> {
    unsafe {
        let buf = cvt_p(
            ffi::EC_POINT_point2hex(group.as_ptr(), self.as_ptr(), form.0, ctx.as_ptr()),
        )?;
        Ok(OpensslString::from_ptr(buf))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: to_owned,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in to_owned:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 496, End Line: 498
/// Creates a new point on the specified curve with the same value.
#[corresponds(EC_POINT_dup)]
pub fn to_owned(&self, group: &EcGroupRef) -> Result<EcPoint, ErrorStack> {
    unsafe { cvt_p(ffi::EC_POINT_dup(self.as_ptr(), group.as_ptr())).map(EcPoint) }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: eq,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in eq:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 502, End Line: 517
/// Determines if this point is equal to another.
#[corresponds(EC_POINT_cmp)]
pub fn eq(
    &self,
    group: &EcGroupRef,
    other: &EcPointRef,
    ctx: &mut BigNumContextRef,
) -> Result<bool, ErrorStack> {
    unsafe {
        let res = cvt_n(
            ffi::EC_POINT_cmp(
                group.as_ptr(),
                self.as_ptr(),
                other.as_ptr(),
                ctx.as_ptr(),
            ),
        )?;
        Ok(res == 0)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: affine_coordinates,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in affine_coordinates:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 523, End Line: 540
/// Places affine coordinates of a curve over a prime field in the provided
/// `x` and `y` `BigNum`s.
#[corresponds(EC_POINT_get_affine_coordinates)]
#[cfg(any(ossl111, boringssl, libressl350))]
pub fn affine_coordinates(
    &self,
    group: &EcGroupRef,
    x: &mut BigNumRef,
    y: &mut BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::EC_POINT_get_affine_coordinates(
                    group.as_ptr(),
                    self.as_ptr(),
                    x.as_ptr(),
                    y.as_ptr(),
                    ctx.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: affine_coordinates_gfp,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in affine_coordinates_gfp:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 545, End Line: 562
/// Places affine coordinates of a curve over a prime field in the provided
/// `x` and `y` `BigNum`s
#[corresponds(EC_POINT_get_affine_coordinates_GFp)]
pub fn affine_coordinates_gfp(
    &self,
    group: &EcGroupRef,
    x: &mut BigNumRef,
    y: &mut BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::EC_POINT_get_affine_coordinates_GFp(
                    group.as_ptr(),
                    self.as_ptr(),
                    x.as_ptr(),
                    y.as_ptr(),
                    ctx.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_affine_coordinates_gfp,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in set_affine_coordinates_gfp:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 567, End Line: 584
/// Sets affine coordinates of a curve over a prime field using the provided
/// `x` and `y` `BigNum`s
#[corresponds(EC_POINT_set_affine_coordinates_GFp)]
pub fn set_affine_coordinates_gfp(
    &mut self,
    group: &EcGroupRef,
    x: &BigNumRef,
    y: &BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::EC_POINT_set_affine_coordinates_GFp(
                    group.as_ptr(),
                    self.as_ptr(),
                    x.as_ptr(),
                    y.as_ptr(),
                    ctx.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: affine_coordinates_gf2m,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in affine_coordinates_gf2m:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 590, End Line: 607
/// Places affine coordinates of a curve over a binary field in the provided
/// `x` and `y` `BigNum`s
#[corresponds(EC_POINT_get_affine_coordinates_GF2m)]
#[cfg(not(osslconf = "OPENSSL_NO_EC2M"))]
pub fn affine_coordinates_gf2m(
    &self,
    group: &EcGroupRef,
    x: &mut BigNumRef,
    y: &mut BigNumRef,
    ctx: &mut BigNumContextRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::EC_POINT_get_affine_coordinates_GF2m(
                    group.as_ptr(),
                    self.as_ptr(),
                    x.as_ptr(),
                    y.as_ptr(),
                    ctx.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: is_infinity,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in is_infinity:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 611, End Line: 616
/// Checks if point is infinity
#[corresponds(EC_POINT_is_at_infinity)]
pub fn is_infinity(&self, group: &EcGroupRef) -> bool {
    unsafe {
        let res = ffi::EC_POINT_is_at_infinity(group.as_ptr(), self.as_ptr());
        res == 1
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: is_on_curve,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in is_on_curve:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 620, End Line: 633
/// Checks if point is on a given curve
#[corresponds(EC_POINT_is_on_curve)]
pub fn is_on_curve(
    &self,
    group: &EcGroupRef,
    ctx: &mut BigNumContextRef,
) -> Result<bool, ErrorStack> {
    unsafe {
        let res = cvt_n(
            ffi::EC_POINT_is_on_curve(group.as_ptr(), self.as_ptr(), ctx.as_ptr()),
        )?;
        Ok(res == 1)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 639, End Line: 641
/// Creates a new point on the specified curve.
#[corresponds(EC_POINT_new)]
pub fn new(group: &EcGroupRef) -> Result<EcPoint, ErrorStack> {
    unsafe { cvt_p(ffi::EC_POINT_new(group.as_ptr())).map(EcPoint) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: from_bytes,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in from_bytes:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 645, End Line: 661
/// Creates point from a binary representation
#[corresponds(EC_POINT_oct2point)]
pub fn from_bytes(
    group: &EcGroupRef,
    buf: &[u8],
    ctx: &mut BigNumContextRef,
) -> Result<EcPoint, ErrorStack> {
    let point = EcPoint::new(group)?;
    unsafe {
        cvt(
            ffi::EC_POINT_oct2point(
                group.as_ptr(),
                point.as_ptr(),
                buf.as_ptr(),
                buf.len(),
                ctx.as_ptr(),
            ),
        )?;
    }
    Ok(point)
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: from_hex_str,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in from_hex_str:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 666, End Line: 682
/// Creates point from a hexadecimal string representation
#[corresponds(EC_POINT_hex2point)]
#[cfg(not(boringssl))]
pub fn from_hex_str(
    group: &EcGroupRef,
    s: &str,
    ctx: &mut BigNumContextRef,
) -> Result<EcPoint, ErrorStack> {
    let point = EcPoint::new(group)?;
    unsafe {
        let c_str = CString::new(s.as_bytes()).unwrap();
        cvt_p(
            ffi::EC_POINT_hex2point(
                group.as_ptr(),
                c_str.as_ptr() as *const _,
                point.as_ptr(),
                ctx.as_ptr(),
            ),
        )?;
    }
    Ok(point)
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: private_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in private_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 722, End Line: 727
/// Returns the private key value.
#[corresponds(EC_KEY_get0_private_key)]
pub fn private_key(&self) -> &BigNumRef {
    unsafe {
        let ptr = ffi::EC_KEY_get0_private_key(self.as_ptr());
        BigNumRef::from_const_ptr(ptr)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: public_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in public_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 736, End Line: 741
/// Returns the public key.
#[corresponds(EC_KEY_get0_public_key)]
pub fn public_key(&self) -> &EcPointRef {
    unsafe {
        let ptr = ffi::EC_KEY_get0_public_key(self.as_ptr());
        EcPointRef::from_const_ptr(ptr)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: group,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in group:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 766, End Line: 771
/// Returns the key's group.
#[corresponds(EC_KEY_get0_group)]
pub fn group(&self) -> &EcGroupRef {
    unsafe {
        let ptr = ffi::EC_KEY_get0_group(self.as_ptr());
        EcGroupRef::from_const_ptr(ptr)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: check_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in check_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 775, End Line: 777
/// Checks the key for validity.
#[corresponds(EC_KEY_check_key)]
pub fn check_key(&self) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::EC_KEY_check_key(self.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: from_group,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in from_group:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 807, End Line: 815
/// Constructs an `EcKey` corresponding to a curve.
#[corresponds(EC_KEY_set_group)]
pub fn from_group(group: &EcGroupRef) -> Result<EcKey<Params>, ErrorStack> {
    unsafe {
        cvt_p(ffi::EC_KEY_new())
            .map(|p| EcKey::from_ptr(p))
            .and_then(|key| {
                cvt(ffi::EC_KEY_set_group(key.as_ptr(), group.as_ptr())).map(|_| key)
            })
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: from_public_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in from_public_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 847, End Line: 865
/// Constructs an `EcKey` from the specified group with the associated [`EcPoint`]: `public_key`.
///
/// This will only have the associated `public_key`.
///
/// # Example
///
/// ```
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// use openssl::bn::BigNumContext;
/// use openssl::ec::*;
/// use openssl::nid::Nid;
/// use openssl::pkey::PKey;
///
/// let group = EcGroup::from_curve_name(Nid::SECP384R1)?;
/// let mut ctx = BigNumContext::new()?;
///
/// // get bytes from somewhere
/// let public_key = // ...
/// # EcKey::generate(&group)?.public_key().to_bytes(&group,
/// # PointConversionForm::COMPRESSED, &mut ctx)?;
///
/// // create an EcKey from the binary form of a EcPoint
/// let point = EcPoint::from_bytes(&group, &public_key, &mut ctx)?;
/// let key = EcKey::from_public_key(&group, &point)?;
/// key.check_key()?;
/// # Ok(()) }
/// ```
#[corresponds(EC_KEY_set_public_key)]
pub fn from_public_key(
    group: &EcGroupRef,
    public_key: &EcPointRef,
) -> Result<EcKey<Public>, ErrorStack> {
    unsafe {
        cvt_p(ffi::EC_KEY_new())
            .map(|p| EcKey::from_ptr(p))
            .and_then(|key| {
                cvt(ffi::EC_KEY_set_group(key.as_ptr(), group.as_ptr())).map(|_| key)
            })
            .and_then(|key| {
                cvt(ffi::EC_KEY_set_public_key(key.as_ptr(), public_key.as_ptr()))
                    .map(|_| key)
            })
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: from_public_key_affine_coordinates,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in from_public_key_affine_coordinates:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 869, End Line: 889
/// Constructs a public key from its affine coordinates.
#[corresponds(EC_KEY_set_public_key_affine_coordinates)]
pub fn from_public_key_affine_coordinates(
    group: &EcGroupRef,
    x: &BigNumRef,
    y: &BigNumRef,
) -> Result<EcKey<Public>, ErrorStack> {
    unsafe {
        cvt_p(ffi::EC_KEY_new())
            .map(|p| EcKey::from_ptr(p))
            .and_then(|key| {
                cvt(ffi::EC_KEY_set_group(key.as_ptr(), group.as_ptr())).map(|_| key)
            })
            .and_then(|key| {
                cvt(
                        ffi::EC_KEY_set_public_key_affine_coordinates(
                            key.as_ptr(),
                            x.as_ptr(),
                            y.as_ptr(),
                        ),
                    )
                    .map(|_| key)
            })
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: generate,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in generate:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 940, End Line: 949
/// Generates a new public/private key pair on the specified curve.
///
/// # Examples
///
/// ```
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// use openssl::bn::BigNumContext;
/// use openssl::nid::Nid;
/// use openssl::ec::{EcGroup, EcKey, PointConversionForm};
///
/// let nid = Nid::X9_62_PRIME256V1; // NIST P-256 curve
/// let group = EcGroup::from_curve_name(nid)?;
/// let key = EcKey::generate(&group)?;
///
/// let mut ctx = BigNumContext::new()?;
///
/// let public_key = &key.public_key().to_bytes(
///     &group,
///     PointConversionForm::COMPRESSED,
///     &mut ctx,
/// )?;
/// assert_eq!(public_key.len(), 33);
/// assert_ne!(public_key[0], 0x04);
///
/// let private_key = key.private_key().to_vec();
/// assert!(private_key.len() >= 31);
/// # Ok(()) }
/// ```
#[corresponds(EC_KEY_generate_key)]
pub fn generate(group: &EcGroupRef) -> Result<EcKey<Private>, ErrorStack> {
    unsafe {
        cvt_p(ffi::EC_KEY_new())
            .map(|p| EcKey::from_ptr(p))
            .and_then(|key| {
                cvt(ffi::EC_KEY_set_group(key.as_ptr(), group.as_ptr())).map(|_| key)
            })
            .and_then(|key| cvt(ffi::EC_KEY_generate_key(key.as_ptr())).map(|_| key))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: from_private_components,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs

Found method with unsafe block in from_private_components:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ec.rs
Start Line: 953, End Line: 979
/// Constructs an public/private key pair given a curve, a private key and a public key point.
#[corresponds(EC_KEY_set_private_key)]
pub fn from_private_components(
    group: &EcGroupRef,
    private_number: &BigNumRef,
    public_key: &EcPointRef,
) -> Result<EcKey<Private>, ErrorStack> {
    unsafe {
        cvt_p(ffi::EC_KEY_new())
            .map(|p| EcKey::from_ptr(p))
            .and_then(|key| {
                cvt(ffi::EC_KEY_set_group(key.as_ptr(), group.as_ptr())).map(|_| key)
            })
            .and_then(|key| {
                cvt(ffi::EC_KEY_set_private_key(key.as_ptr(), private_number.as_ptr()))
                    .map(|_| key)
            })
            .and_then(|key| {
                cvt(ffi::EC_KEY_set_public_key(key.as_ptr(), public_key.as_ptr()))
                    .map(|_| key)
            })
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ecdsa.rs
-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: sign,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ecdsa.rs

Found method with unsafe block in sign:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ecdsa.rs
Start Line: 30, End Line: 43
/// Computes a digital signature of the hash value `data` using the private EC key eckey.
#[corresponds(ECDSA_do_sign)]
pub fn sign<T>(data: &[u8], eckey: &EcKeyRef<T>) -> Result<EcdsaSig, ErrorStack>
where
    T: HasPrivate,
{
    unsafe {
        assert!(data.len() <= c_int::MAX as usize);
        let sig = cvt_p(
            ffi::ECDSA_do_sign(data.as_ptr(), data.len() as LenType, eckey.as_ptr()),
        )?;
        Ok(EcdsaSig::from_ptr(sig))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: from_private_components,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ecdsa.rs

Found method with unsafe block in from_private_components:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ecdsa.rs
Start Line: 47, End Line: 54
/// Returns a new `EcdsaSig` by setting the `r` and `s` values associated with an ECDSA signature.
#[corresponds(ECDSA_SIG_set0)]
pub fn from_private_components(r: BigNum, s: BigNum) -> Result<EcdsaSig, ErrorStack> {
    unsafe {
        let sig = cvt_p(ffi::ECDSA_SIG_new())?;
        ECDSA_SIG_set0(sig, r.as_ptr(), s.as_ptr());
        mem::forget((r, s));
        Ok(EcdsaSig::from_ptr(sig))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: verify,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ecdsa.rs

Found method with unsafe block in verify:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ecdsa.rs
Start Line: 75, End Line: 89
/// Verifies if the signature is a valid ECDSA signature using the given public key.
#[corresponds(ECDSA_do_verify)]
pub fn verify<T>(&self, data: &[u8], eckey: &EcKeyRef<T>) -> Result<bool, ErrorStack>
where
    T: HasPublic,
{
    unsafe {
        assert!(data.len() <= c_int::MAX as usize);
        cvt_n(
                ffi::ECDSA_do_verify(
                    data.as_ptr(),
                    data.len() as LenType,
                    self.as_ptr(),
                    eckey.as_ptr(),
                ),
            )
            .map(|x| x == 1)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: r,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ecdsa.rs

Found method with unsafe block in r:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ecdsa.rs
Start Line: 93, End Line: 99
/// Returns internal component: `r` of an `EcdsaSig`. (See X9.62 or FIPS 186-2)
#[corresponds(ECDSA_SIG_get0)]
pub fn r(&self) -> &BigNumRef {
    unsafe {
        let mut r = ptr::null();
        ECDSA_SIG_get0(self.as_ptr(), &mut r, ptr::null_mut());
        BigNumRef::from_const_ptr(r)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: s,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ecdsa.rs

Found method with unsafe block in s:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ecdsa.rs
Start Line: 103, End Line: 109
/// Returns internal components: `s` of an `EcdsaSig`. (See X9.62 or FIPS 186-2)
#[corresponds(ECDSA_SIG_get0)]
pub fn s(&self) -> &BigNumRef {
    unsafe {
        let mut s = ptr::null();
        ECDSA_SIG_get0(self.as_ptr(), ptr::null_mut(), &mut s);
        BigNumRef::from_const_ptr(s)
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: drop,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs

Found method with unsafe block in drop:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs
Start Line: 63, End Line: 67
fn drop(&mut self) {
    unsafe {
        ffi::EVP_PKEY_CTX_free(self.pctx);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: true, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs
Start Line: 76, End Line: 95
/// Creates a new `Encrypter`.
///
/// OpenSSL documentation at [`EVP_PKEY_encrypt_init`].
///
/// [`EVP_PKEY_encrypt_init`]: https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_encrypt_init.html
pub fn new<T>(pkey: &'a PKeyRef<T>) -> Result<Encrypter<'a>, ErrorStack>
where
    T: HasPublic,
{
    unsafe {
        ffi::init();
        let pctx = cvt_p(ffi::EVP_PKEY_CTX_new(pkey.as_ptr(), ptr::null_mut()))?;
        let r = ffi::EVP_PKEY_encrypt_init(pctx);
        if r != 1 {
            ffi::EVP_PKEY_CTX_free(pctx);
            return Err(ErrorStack::get());
        }
        Ok(Encrypter { pctx, _p: PhantomData })
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: rsa_padding,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs

Found method with unsafe block in rsa_padding:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs
Start Line: 102, End Line: 108
/// Returns the RSA padding mode in use.
///
/// This is only useful for RSA keys.
///
/// This corresponds to `EVP_PKEY_CTX_get_rsa_padding`.
pub fn rsa_padding(&self) -> Result<Padding, ErrorStack> {
    unsafe {
        let mut pad = 0;
        cvt(ffi::EVP_PKEY_CTX_get_rsa_padding(self.pctx, &mut pad))
            .map(|_| Padding::from_raw(pad))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_rsa_padding,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs

Found method with unsafe block in set_rsa_padding:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs
Start Line: 117, End Line: 125
/// Sets the RSA padding mode.
///
/// This is only useful for RSA keys.
///
/// This corresponds to [`EVP_PKEY_CTX_set_rsa_padding`].
///
/// [`EVP_PKEY_CTX_set_rsa_padding`]: https://www.openssl.org/docs/manmaster/crypto/EVP_PKEY_CTX_set_rsa_padding.html
pub fn set_rsa_padding(&mut self, padding: Padding) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_CTX_set_rsa_padding(self.pctx, padding.as_raw())).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_rsa_mgf1_md,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs

Found method with unsafe block in set_rsa_mgf1_md:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs
Start Line: 134, End Line: 142
/// Sets the RSA MGF1 algorithm.
///
/// This is only useful for RSA keys.
///
/// This corresponds to [`EVP_PKEY_CTX_set_rsa_mgf1_md`].
///
/// [`EVP_PKEY_CTX_set_rsa_mgf1_md`]: https://www.openssl.org/docs/manmaster/man7/RSA-PSS.html
pub fn set_rsa_mgf1_md(&mut self, md: MessageDigest) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_CTX_set_rsa_mgf1_md(self.pctx, md.as_ptr() as *mut _))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_rsa_oaep_md,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs

Found method with unsafe block in set_rsa_oaep_md:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs
Start Line: 152, End Line: 160
/// Sets the RSA OAEP algorithm.
///
/// This is only useful for RSA keys.
///
/// This corresponds to [`EVP_PKEY_CTX_set_rsa_oaep_md`].
///
/// [`EVP_PKEY_CTX_set_rsa_oaep_md`]: https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_CTX_set_rsa_oaep_md.html
#[cfg(any(ossl102, libressl310))]
pub fn set_rsa_oaep_md(&mut self, md: MessageDigest) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_CTX_set_rsa_oaep_md(self.pctx, md.as_ptr() as *mut _))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: set_rsa_oaep_label,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs

Found method with unsafe block in set_rsa_oaep_label:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs
Start Line: 170, End Line: 186
/// Sets the RSA OAEP label.
///
/// This is only useful for RSA keys.
///
/// This corresponds to [`EVP_PKEY_CTX_set0_rsa_oaep_label`].
///
/// [`EVP_PKEY_CTX_set0_rsa_oaep_label`]: https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_CTX_set0_rsa_oaep_label.html
#[cfg(any(ossl102, libressl310))]
pub fn set_rsa_oaep_label(&mut self, label: &[u8]) -> Result<(), ErrorStack> {
    unsafe {
        let p = cvt_p(ffi::OPENSSL_malloc(label.len() as _))?;
        ptr::copy_nonoverlapping(label.as_ptr(), p as *mut u8, label.len());
        cvt(ffi::EVP_PKEY_CTX_set0_rsa_oaep_label(self.pctx, p, label.len() as c_int))
            .map(|_| ())
            .map_err(|e| {
                ffi::OPENSSL_free(p);
                e
            })
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: encrypt,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs

Found method with unsafe block in encrypt:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs
Start Line: 221, End Line: 234
/// Performs public key encryption.
///
/// In order to know the size needed for the output buffer, use [`encrypt_len`](Encrypter::encrypt_len).
/// Note that the length of the output buffer can be greater of the length of the encoded data.
/// ```
/// # use openssl::{
/// #   encrypt::Encrypter,
/// #   pkey::PKey,
/// #   rsa::{Rsa, Padding},
/// # };
/// #
/// # let key = include_bytes!("../test/rsa.pem");
/// # let private_key = Rsa::private_key_from_pem(key).unwrap();
/// # let pkey = PKey::from_rsa(private_key).unwrap();
/// # let input = b"hello world".to_vec();
/// #
/// let mut encrypter = Encrypter::new(&pkey).unwrap();
/// encrypter.set_rsa_padding(Padding::PKCS1).unwrap();
///
/// // Get the length of the output buffer
/// let buffer_len = encrypter.encrypt_len(&input).unwrap();
/// let mut encoded = vec![0u8; buffer_len];
///
/// // Encode the data and get its length
/// let encoded_len = encrypter.encrypt(&input, &mut encoded).unwrap();
///
/// // Use only the part of the buffer with the encoded data
/// let encoded = &encoded[..encoded_len];
/// ```
///
/// This corresponds to [`EVP_PKEY_encrypt`].
///
/// [`EVP_PKEY_encrypt`]: https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_encrypt.html
pub fn encrypt(&self, from: &[u8], to: &mut [u8]) -> Result<usize, ErrorStack> {
    let mut written = to.len();
    unsafe {
        cvt(
            ffi::EVP_PKEY_encrypt(
                self.pctx,
                to.as_mut_ptr(),
                &mut written,
                from.as_ptr(),
                from.len(),
            ),
        )?;
    }
    Ok(written)
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: encrypt_len,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs

Found method with unsafe block in encrypt_len:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs
Start Line: 241, End Line: 254
/// Gets the size of the buffer needed to encrypt the input data.
///
/// This corresponds to [`EVP_PKEY_encrypt`] called with a null pointer as output argument.
///
/// [`EVP_PKEY_encrypt`]: https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_encrypt.html
pub fn encrypt_len(&self, from: &[u8]) -> Result<usize, ErrorStack> {
    let mut written = 0;
    unsafe {
        cvt(
            ffi::EVP_PKEY_encrypt(
                self.pctx,
                ptr::null_mut(),
                &mut written,
                from.as_ptr(),
                from.len(),
            ),
        )?;
    }
    Ok(written)
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: decrypt,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs

Found method with unsafe block in decrypt:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs
Start Line: 440, End Line: 453
/// Performs public key decryption.
///
/// In order to know the size needed for the output buffer, use [`decrypt_len`](Decrypter::decrypt_len).
/// Note that the length of the output buffer can be greater of the length of the decoded data.
/// ```
/// # use openssl::{
/// #   encrypt::Decrypter,
/// #   pkey::PKey,
/// #   rsa::{Rsa, Padding},
/// # };
/// #
/// # const INPUT: &[u8] = b"\
/// #     \x26\xa1\xc1\x13\xc5\x7f\xb4\x9f\xa0\xb4\xde\x61\x5e\x2e\xc6\xfb\x76\x5c\xd1\x2b\x5f\
/// #     \x1d\x36\x60\xfa\xf8\xe8\xb3\x21\xf4\x9c\x70\xbc\x03\xea\xea\xac\xce\x4b\xb3\xf6\x45\
/// #     \xcc\xb3\x80\x9e\xa8\xf7\xc3\x5d\x06\x12\x7a\xa3\x0c\x30\x67\xf1\xe7\x94\x6c\xf6\x26\
/// #     \xac\x28\x17\x59\x69\xe1\xdc\xed\x7e\xc0\xe9\x62\x57\x49\xce\xdd\x13\x07\xde\x18\x03\
/// #     \x0f\x9d\x61\x65\xb9\x23\x8c\x78\x4b\xad\x23\x49\x75\x47\x64\xa0\xa0\xa2\x90\xc1\x49\
/// #     \x1b\x05\x24\xc2\xe9\x2c\x0d\x49\x78\x72\x61\x72\xed\x8b\x6f\x8a\xe8\xca\x05\x5c\x58\
/// #     \xd6\x95\xd6\x7b\xe3\x2d\x0d\xaa\x3e\x6d\x3c\x9a\x1c\x1d\xb4\x6c\x42\x9d\x9a\x82\x55\
/// #     \xd9\xde\xc8\x08\x7b\x17\xac\xd7\xaf\x86\x7b\x69\x9e\x3c\xf4\x5e\x1c\x39\x52\x6d\x62\
/// #     \x50\x51\xbd\xa6\xc8\x4e\xe9\x34\xf0\x37\x0d\xa9\xa9\x77\xe6\xf5\xc2\x47\x2d\xa8\xee\
/// #     \x3f\x69\x78\xff\xa9\xdc\x70\x22\x20\x9a\x5c\x9b\x70\x15\x90\xd3\xb4\x0e\x54\x9e\x48\
/// #     \xed\xb6\x2c\x88\xfc\xb4\xa9\x37\x10\xfa\x71\xb2\xec\x75\xe7\xe7\x0e\xf4\x60\x2c\x7b\
/// #     \x58\xaf\xa0\x53\xbd\x24\xf1\x12\xe3\x2e\x99\x25\x0a\x54\x54\x9d\xa1\xdb\xca\x41\x85\
/// #     \xf4\x62\x78\x64";
/// #
/// # let key = include_bytes!("../test/rsa.pem");
/// # let private_key = Rsa::private_key_from_pem(key).unwrap();
/// # let pkey = PKey::from_rsa(private_key).unwrap();
/// # let input = INPUT.to_vec();
/// #
/// let mut decrypter = Decrypter::new(&pkey).unwrap();
/// decrypter.set_rsa_padding(Padding::PKCS1).unwrap();
///
/// // Get the length of the output buffer
/// let buffer_len = decrypter.decrypt_len(&input).unwrap();
/// let mut decoded = vec![0u8; buffer_len];
///
/// // Decrypt the data and get its length
/// let decoded_len = decrypter.decrypt(&input, &mut decoded).unwrap();
///
/// // Use only the part of the buffer with the decrypted data
/// let decoded = &decoded[..decoded_len];
/// ```
///
/// This corresponds to [`EVP_PKEY_decrypt`].
///
/// [`EVP_PKEY_decrypt`]: https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_decrypt.html
pub fn decrypt(&self, from: &[u8], to: &mut [u8]) -> Result<usize, ErrorStack> {
    let mut written = to.len();
    unsafe {
        cvt(
            ffi::EVP_PKEY_decrypt(
                self.pctx,
                to.as_mut_ptr(),
                &mut written,
                from.as_ptr(),
                from.len(),
            ),
        )?;
    }
    Ok(written)
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: decrypt_len,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs

Found method with unsafe block in decrypt_len:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\encrypt.rs
Start Line: 460, End Line: 473
/// Gets the size of the buffer needed to decrypt the input data.
///
/// This corresponds to [`EVP_PKEY_decrypt`] called with a null pointer as output argument.
///
/// [`EVP_PKEY_decrypt`]: https://www.openssl.org/docs/manmaster/man3/EVP_PKEY_decrypt.html
pub fn decrypt_len(&self, from: &[u8]) -> Result<usize, ErrorStack> {
    let mut written = 0;
    unsafe {
        cvt(
            ffi::EVP_PKEY_decrypt(
                self.pctx,
                ptr::null_mut(),
                &mut written,
                from.as_ptr(),
                from.len(),
            ),
        )?;
    }
    Ok(written)
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\envelope.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\envelope.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\envelope.rs
Start Line: 40, End Line: 56
/// Creates a new `Seal`.
pub fn new<T>(cipher: Cipher, pub_keys: &[PKey<T>]) -> Result<Seal, ErrorStack>
where
    T: HasPublic,
{
    let mut iv = cipher.iv_len().map(|len| vec![0; len]);
    let mut enc_keys = vec![vec![]; pub_keys.len()];
    let mut ctx = CipherCtx::new()?;
    ctx.seal_init(
        Some(unsafe { CipherRef::from_ptr(cipher.as_ptr() as *mut _) }),
        pub_keys,
        &mut enc_keys,
        iv.as_deref_mut(),
    )?;
    Ok(Seal { ctx, iv, enc_keys })
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\error.rs
-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: put_error,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\error.rs

Found method with unsafe block in put_error:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\error.rs
Start Line: 193, End Line: 203
#[cfg(ossl300)]
fn put_error(&self) {
    unsafe {
        ffi::ERR_new();
        ffi::ERR_set_debug(
            self.file.as_ptr(),
            self.line,
            self.func.as_ref().map_or(ptr::null(), |s| s.as_ptr()),
        );
        ffi::ERR_set_error(self.library_code(), self.reason_code(), ptr::null());
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: true, With_SAFETY_comment: false, Name: library,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\error.rs

Found method with unsafe block in library:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\error.rs
Start Line: 228, End Line: 237
/// Returns the name of the library reporting the error, if available.
pub fn library(&self) -> Option<&'static str> {
    unsafe {
        let cstr = ffi::ERR_lib_error_string(self.code);
        if cstr.is_null() {
            return None;
        }
        let bytes = CStr::from_ptr(cstr as *const _).to_bytes();
        Some(str::from_utf8(bytes).unwrap())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: library_code,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\error.rs

Found method with unsafe block in library_code:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\error.rs
Start Line: 244, End Line: 246
/// Returns the raw OpenSSL error constant for the library reporting the
/// error.
#[allow(unused_unsafe)]
pub fn library_code(&self) -> libc::c_int {
    unsafe { ffi::ERR_GET_LIB(self.code) }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: true, With_SAFETY_comment: false, Name: reason,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\error.rs

Found method with unsafe block in reason:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\error.rs
Start Line: 254, End Line: 263
/// Returns the reason for the error.
pub fn reason(&self) -> Option<&'static str> {
    unsafe {
        let cstr = ffi::ERR_reason_error_string(self.code);
        if cstr.is_null() {
            return None;
        }
        let bytes = CStr::from_ptr(cstr as *const _).to_bytes();
        Some(str::from_utf8(bytes).unwrap())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: reason_code,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\error.rs

Found method with unsafe block in reason_code:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\error.rs
Start Line: 269, End Line: 271
/// Returns the raw OpenSSL error constant for the reason for the error.
#[allow(unused_unsafe)]
pub fn reason_code(&self) -> libc::c_int {
    unsafe { ffi::ERR_GET_REASON(self.code) }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ex_data.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\fips.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: enable,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\fips.rs

Found function with unsafe block in enable:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\fips.rs
Start Line: 12, End Line: 15
/// Moves the library into or out of the FIPS 140-2 mode of operation.
#[corresponds(FIPS_mode_set)]
pub fn enable(enabled: bool) -> Result<(), ErrorStack> {
    ffi::init();
    unsafe { cvt(ffi::FIPS_mode_set(enabled as _)).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: enabled,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\fips.rs

Found function with unsafe block in enabled:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\fips.rs
Start Line: 19, End Line: 21
/// Determines if the library is running in the FIPS 140-2 mode of operation.
#[corresponds(FIPS_mode)]
pub fn enabled() -> bool {
    unsafe { ffi::FIPS_mode() != 0 }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: from_nid,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in from_nid:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 72, End Line: 81
/// Returns the `MessageDigest` corresponding to an `Nid`.
///
/// This corresponds to [`EVP_get_digestbynid`].
///
/// [`EVP_get_digestbynid`]: https://www.openssl.org/docs/manmaster/crypto/EVP_DigestInit.html
pub fn from_nid(type_: Nid) -> Option<MessageDigest> {
    unsafe {
        let ptr = ffi::EVP_get_digestbynid(type_.as_raw());
        if ptr.is_null() { None } else { Some(MessageDigest(ptr)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: from_name,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in from_name:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 88, End Line: 99
/// Returns the `MessageDigest` corresponding to an algorithm name.
///
/// This corresponds to [`EVP_get_digestbyname`].
///
/// [`EVP_get_digestbyname`]: https://www.openssl.org/docs/manmaster/crypto/EVP_DigestInit.html
pub fn from_name(name: &str) -> Option<MessageDigest> {
    ffi::init();
    let name = CString::new(name).ok()?;
    unsafe {
        let ptr = ffi::EVP_get_digestbyname(name.as_ptr());
        if ptr.is_null() { None } else { Some(MessageDigest(ptr)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: null,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in null:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 102, End Line: 104
#[cfg(not(boringssl))]
pub fn null() -> MessageDigest {
    unsafe { MessageDigest(ffi::EVP_md_null()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: md5,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in md5:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 106, End Line: 108
pub fn md5() -> MessageDigest {
    unsafe { MessageDigest(ffi::EVP_md5()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sha1,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in sha1:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 110, End Line: 112
pub fn sha1() -> MessageDigest {
    unsafe { MessageDigest(ffi::EVP_sha1()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sha224,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in sha224:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 114, End Line: 116
pub fn sha224() -> MessageDigest {
    unsafe { MessageDigest(ffi::EVP_sha224()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sha256,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in sha256:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 118, End Line: 120
pub fn sha256() -> MessageDigest {
    unsafe { MessageDigest(ffi::EVP_sha256()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sha384,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in sha384:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 122, End Line: 124
pub fn sha384() -> MessageDigest {
    unsafe { MessageDigest(ffi::EVP_sha384()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sha512,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in sha512:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 126, End Line: 128
pub fn sha512() -> MessageDigest {
    unsafe { MessageDigest(ffi::EVP_sha512()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sha3_224,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in sha3_224:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 131, End Line: 133
#[cfg(any(ossl111, libressl380))]
pub fn sha3_224() -> MessageDigest {
    unsafe { MessageDigest(ffi::EVP_sha3_224()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sha3_256,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in sha3_256:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 136, End Line: 138
#[cfg(any(ossl111, libressl380))]
pub fn sha3_256() -> MessageDigest {
    unsafe { MessageDigest(ffi::EVP_sha3_256()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sha3_384,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in sha3_384:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 141, End Line: 143
#[cfg(any(ossl111, libressl380))]
pub fn sha3_384() -> MessageDigest {
    unsafe { MessageDigest(ffi::EVP_sha3_384()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sha3_512,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in sha3_512:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 146, End Line: 148
#[cfg(any(ossl111, libressl380))]
pub fn sha3_512() -> MessageDigest {
    unsafe { MessageDigest(ffi::EVP_sha3_512()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: shake_128,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in shake_128:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 151, End Line: 153
#[cfg(ossl111)]
pub fn shake_128() -> MessageDigest {
    unsafe { MessageDigest(ffi::EVP_shake128()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: shake_256,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in shake_256:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 156, End Line: 158
#[cfg(ossl111)]
pub fn shake_256() -> MessageDigest {
    unsafe { MessageDigest(ffi::EVP_shake256()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: ripemd160,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in ripemd160:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 161, End Line: 163
#[cfg(not(osslconf = "OPENSSL_NO_RMD160"))]
pub fn ripemd160() -> MessageDigest {
    unsafe { MessageDigest(ffi::EVP_ripemd160()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sm3,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in sm3:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 166, End Line: 168
#[cfg(all(any(ossl111, libressl291), not(osslconf = "OPENSSL_NO_SM3")))]
pub fn sm3() -> MessageDigest {
    unsafe { MessageDigest(ffi::EVP_sm3()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: block_size,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in block_size:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 177, End Line: 179
/// The block size of the digest in bytes.
#[allow(clippy::trivially_copy_pass_by_ref)]
pub fn block_size(&self) -> usize {
    unsafe { ffi::EVP_MD_block_size(self.0) as usize }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: size,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in size:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 183, End Line: 185
/// The size of the digest in bytes.
#[allow(clippy::trivially_copy_pass_by_ref)]
pub fn size(&self) -> usize {
    unsafe { ffi::EVP_MD_size(self.0) as usize }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: type_,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in type_:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 189, End Line: 191
/// The name of the digest.
#[allow(clippy::trivially_copy_pass_by_ref)]
pub fn type_(&self) -> Nid {
    Nid::from_raw(unsafe { ffi::EVP_MD_type(self.0) })
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 246, End Line: 259
/// Creates a new `Hasher` with the specified hash type.
pub fn new(ty: MessageDigest) -> Result<Hasher, ErrorStack> {
    ffi::init();
    let ctx = unsafe { cvt_p(EVP_MD_CTX_new())? };
    let mut h = Hasher {
        ctx,
        md: ty.as_ptr(),
        type_: ty,
        state: Finalized,
    };
    h.init()?;
    Ok(h)
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: init,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in init:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 261, End Line: 274
fn init(&mut self) -> Result<(), ErrorStack> {
    match self.state {
        Reset => return Ok(()),
        Updated => {
            self.finish()?;
        }
        Finalized => {}
    }
    unsafe {
        cvt(ffi::EVP_DigestInit_ex(self.ctx, self.md, ptr::null_mut()))?;
    }
    self.state = Reset;
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: update,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in update:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 277, End Line: 290
/// Feeds data into the hasher.
pub fn update(&mut self, data: &[u8]) -> Result<(), ErrorStack> {
    if self.state == Finalized {
        self.init()?;
    }
    unsafe {
        cvt(ffi::EVP_DigestUpdate(self.ctx, data.as_ptr() as *mut _, data.len()))?;
    }
    self.state = Updated;
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 6 statements, Complex: false, With_SAFETY_comment: false, Name: finish,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in finish:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 293, End Line: 314
/// Returns the hash of the data written and resets the non-XOF hasher.
pub fn finish(&mut self) -> Result<DigestBytes, ErrorStack> {
    if self.state == Finalized {
        self.init()?;
    }
    unsafe {
        #[cfg(not(boringssl))]
        let mut len = ffi::EVP_MAX_MD_SIZE;
        #[cfg(boringssl)]
        let mut len = ffi::EVP_MAX_MD_SIZE as u32;
        let mut buf = [0; ffi::EVP_MAX_MD_SIZE as usize];
        cvt(ffi::EVP_DigestFinal_ex(self.ctx, buf.as_mut_ptr(), &mut len))?;
        self.state = Finalized;
        Ok(DigestBytes {
            buf,
            len: len as usize,
        })
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: finish_xof,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in finish_xof:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 319, End Line: 332
/// Writes the hash of the data into the supplied buf and resets the XOF hasher.
/// The hash will be as long as the buf.
#[cfg(ossl111)]
pub fn finish_xof(&mut self, buf: &mut [u8]) -> Result<(), ErrorStack> {
    if self.state == Finalized {
        self.init()?;
    }
    unsafe {
        cvt(ffi::EVP_DigestFinalXOF(self.ctx, buf.as_mut_ptr(), buf.len()))?;
        self.state = Finalized;
        Ok(())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: clone,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in clone:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 348, End Line: 362
fn clone(&self) -> Hasher {
    let ctx = unsafe {
        let ctx = EVP_MD_CTX_new();
        assert!(! ctx.is_null());
        let r = ffi::EVP_MD_CTX_copy_ex(ctx, self.ctx);
        assert_eq!(r, 1);
        ctx
    };
    Hasher {
        ctx,
        md: self.md,
        type_: self.type_,
        state: self.state,
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: drop,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs

Found method with unsafe block in drop:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\hash.rs
Start Line: 366, End Line: 373
fn drop(&mut self) {
    unsafe {
        if self.state != Finalized {
            drop(self.finish());
        }
        EVP_MD_CTX_free(self.ctx);
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\lib_ctx.rs
-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\lib_ctx.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\lib_ctx.rs
Start Line: 16, End Line: 21
#[corresponds(OSSL_LIB_CTX_new)]
pub fn new() -> Result<Self, ErrorStack> {
    unsafe {
        let ptr = cvt_p(ffi::OSSL_LIB_CTX_new())?;
        Ok(LibCtx::from_ptr(ptr))
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\macros.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: from_nid,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in from_nid:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 82, End Line: 91
/// Returns the `Md` corresponding to an [`Nid`].
#[corresponds(EVP_get_digestbynid)]
pub fn from_nid(type_: Nid) -> Option<&'static MdRef> {
    unsafe {
        let ptr = ffi::EVP_get_digestbynid(type_.as_raw());
        if ptr.is_null() { None } else { Some(MdRef::from_ptr(ptr as *mut _)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: fetch,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in fetch:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 98, End Line: 115
/// Fetches an `Md` object corresponding to the specified algorithm name and properties.
///
/// Requires OpenSSL 3.0.0 or newer.
#[corresponds(EVP_MD_fetch)]
#[cfg(ossl300)]
pub fn fetch(
    ctx: Option<&LibCtxRef>,
    algorithm: &str,
    properties: Option<&str>,
) -> Result<Self, ErrorStack> {
    let algorithm = CString::new(algorithm).unwrap();
    let properties = properties.map(|s| CString::new(s).unwrap());
    unsafe {
        let ptr = cvt_p(
            ffi::EVP_MD_fetch(
                ctx.map_or(ptr::null_mut(), ForeignTypeRef::as_ptr),
                algorithm.as_ptr(),
                properties.map_or(ptr::null_mut(), |s| s.as_ptr()),
            ),
        )?;
        Ok(Md::from_ptr(ptr))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: null,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in null:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 119, End Line: 121
#[inline]
#[cfg(not(boringssl))]
pub fn null() -> &'static MdRef {
    unsafe { MdRef::from_ptr(ffi::EVP_md_null() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: md5,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in md5:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 124, End Line: 126
#[inline]
pub fn md5() -> &'static MdRef {
    unsafe { MdRef::from_ptr(ffi::EVP_md5() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sha1,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in sha1:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 129, End Line: 131
#[inline]
pub fn sha1() -> &'static MdRef {
    unsafe { MdRef::from_ptr(ffi::EVP_sha1() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sha224,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in sha224:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 134, End Line: 136
#[inline]
pub fn sha224() -> &'static MdRef {
    unsafe { MdRef::from_ptr(ffi::EVP_sha224() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sha256,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in sha256:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 139, End Line: 141
#[inline]
pub fn sha256() -> &'static MdRef {
    unsafe { MdRef::from_ptr(ffi::EVP_sha256() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sha384,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in sha384:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 144, End Line: 146
#[inline]
pub fn sha384() -> &'static MdRef {
    unsafe { MdRef::from_ptr(ffi::EVP_sha384() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sha512,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in sha512:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 149, End Line: 151
#[inline]
pub fn sha512() -> &'static MdRef {
    unsafe { MdRef::from_ptr(ffi::EVP_sha512() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sha3_224,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in sha3_224:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 155, End Line: 157
#[cfg(any(ossl111, libressl380))]
#[inline]
pub fn sha3_224() -> &'static MdRef {
    unsafe { MdRef::from_ptr(ffi::EVP_sha3_224() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sha3_256,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in sha3_256:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 161, End Line: 163
#[cfg(any(ossl111, libressl380))]
#[inline]
pub fn sha3_256() -> &'static MdRef {
    unsafe { MdRef::from_ptr(ffi::EVP_sha3_256() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sha3_384,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in sha3_384:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 167, End Line: 169
#[cfg(any(ossl111, libressl380))]
#[inline]
pub fn sha3_384() -> &'static MdRef {
    unsafe { MdRef::from_ptr(ffi::EVP_sha3_384() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sha3_512,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in sha3_512:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 173, End Line: 175
#[cfg(any(ossl111, libressl380))]
#[inline]
pub fn sha3_512() -> &'static MdRef {
    unsafe { MdRef::from_ptr(ffi::EVP_sha3_512() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: shake128,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in shake128:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 179, End Line: 181
#[cfg(ossl111)]
#[inline]
pub fn shake128() -> &'static MdRef {
    unsafe { MdRef::from_ptr(ffi::EVP_shake128() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: shake256,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in shake256:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 185, End Line: 187
#[cfg(ossl111)]
#[inline]
pub fn shake256() -> &'static MdRef {
    unsafe { MdRef::from_ptr(ffi::EVP_shake256() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: ripemd160,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in ripemd160:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 191, End Line: 193
#[cfg(not(osslconf = "OPENSSL_NO_RMD160"))]
#[inline]
pub fn ripemd160() -> &'static MdRef {
    unsafe { MdRef::from_ptr(ffi::EVP_ripemd160() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sm3,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in sm3:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 197, End Line: 199
#[cfg(all(any(ossl111, libressl291), not(osslconf = "OPENSSL_NO_SM3")))]
#[inline]
pub fn sm3() -> &'static MdRef {
    unsafe { MdRef::from_ptr(ffi::EVP_sm3() as *mut _) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: block_size,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in block_size:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 216, End Line: 218
/// Returns the block size of the digest in bytes.
#[corresponds(EVP_MD_block_size)]
#[inline]
pub fn block_size(&self) -> usize {
    unsafe { ffi::EVP_MD_block_size(self.as_ptr()) as usize }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: size,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in size:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 223, End Line: 225
/// Returns the size of the digest in bytes.
#[corresponds(EVP_MD_size)]
#[inline]
pub fn size(&self) -> usize {
    unsafe { ffi::EVP_MD_size(self.as_ptr()) as usize }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: type_,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs

Found method with unsafe block in type_:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md.rs
Start Line: 230, End Line: 232
/// Returns the [`Nid`] of the digest.
#[corresponds(EVP_MD_type)]
#[inline]
pub fn type_(&self) -> Nid {
    unsafe { Nid::from_raw(ffi::EVP_MD_type(self.as_ptr())) }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs
-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs
Start Line: 116, End Line: 123
/// Creates a new context.
#[corresponds(EVP_MD_CTX_new)]
#[inline]
pub fn new() -> Result<Self, ErrorStack> {
    ffi::init();
    unsafe {
        let ptr = cvt_p(EVP_MD_CTX_new())?;
        Ok(MdCtx::from_ptr(ptr))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: digest_init,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs

Found method with unsafe block in digest_init:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs
Start Line: 130, End Line: 140
/// Initializes the context to compute the digest of data.
#[corresponds(EVP_DigestInit_ex)]
#[inline]
pub fn digest_init(&mut self, digest: &MdRef) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_DigestInit_ex(self.as_ptr(), digest.as_ptr(), ptr::null_mut()))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: digest_sign_init,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs

Found method with unsafe block in digest_sign_init:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs
Start Line: 147, End Line: 166
/// Initializes the context to compute the signature of data.
///
/// A reference to the context's inner `PkeyCtx` is returned, allowing signature settings to be configured.
#[corresponds(EVP_DigestSignInit)]
#[inline]
pub fn digest_sign_init<'a, T>(
    &'a mut self,
    digest: Option<&MdRef>,
    pkey: &PKeyRef<T>,
) -> Result<&'a mut PkeyCtxRef<T>, ErrorStack>
where
    T: HasPrivate,
{
    unsafe {
        let mut p = ptr::null_mut();
        cvt(
            ffi::EVP_DigestSignInit(
                self.as_ptr(),
                &mut p,
                digest.map_or(ptr::null(), |p| p.as_ptr()),
                ptr::null_mut(),
                pkey.as_ptr(),
            ),
        )?;
        Ok(PkeyCtxRef::from_ptr_mut(p))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: digest_verify_init,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs

Found method with unsafe block in digest_verify_init:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs
Start Line: 173, End Line: 192
/// Initializes the context to verify the signature of data.
///
/// A reference to the context's inner `PkeyCtx` is returned, allowing signature settings to be configured.
#[corresponds(EVP_DigestVerifyInit)]
#[inline]
pub fn digest_verify_init<'a, T>(
    &'a mut self,
    digest: Option<&MdRef>,
    pkey: &PKeyRef<T>,
) -> Result<&'a mut PkeyCtxRef<T>, ErrorStack>
where
    T: HasPublic,
{
    unsafe {
        let mut p = ptr::null_mut();
        cvt(
            ffi::EVP_DigestVerifyInit(
                self.as_ptr(),
                &mut p,
                digest.map_or(ptr::null(), |p| p.as_ptr()),
                ptr::null_mut(),
                pkey.as_ptr(),
            ),
        )?;
        Ok(PkeyCtxRef::from_ptr_mut(p))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: digest_update,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs

Found method with unsafe block in digest_update:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs
Start Line: 197, End Line: 207
/// Updates the context with more data.
#[corresponds(EVP_DigestUpdate)]
#[inline]
pub fn digest_update(&mut self, data: &[u8]) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
            ffi::EVP_DigestUpdate(self.as_ptr(), data.as_ptr() as *const _, data.len()),
        )?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: digest_sign_update,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs

Found method with unsafe block in digest_sign_update:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs
Start Line: 212, End Line: 222
/// Updates the context with more data.
#[corresponds(EVP_DigestSignUpdate)]
#[inline]
pub fn digest_sign_update(&mut self, data: &[u8]) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
            ffi::EVP_DigestSignUpdate(
                self.as_ptr(),
                data.as_ptr() as *const _,
                data.len(),
            ),
        )?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: digest_verify_update,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs

Found method with unsafe block in digest_verify_update:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs
Start Line: 227, End Line: 237
/// Updates the context with more data.
#[corresponds(EVP_DigestVerifyUpdate)]
#[inline]
pub fn digest_verify_update(&mut self, data: &[u8]) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
            ffi::EVP_DigestVerifyUpdate(
                self.as_ptr(),
                data.as_ptr() as *const _,
                data.len(),
            ),
        )?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: digest_final,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs

Found method with unsafe block in digest_final:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs
Start Line: 242, End Line: 254
/// Copies the computed digest into the buffer, returning the number of bytes written.
#[corresponds(EVP_DigestFinal)]
#[inline]
pub fn digest_final(&mut self, out: &mut [u8]) -> Result<usize, ErrorStack> {
    let mut len = u32::try_from(out.len()).unwrap_or(u32::MAX);
    unsafe {
        cvt(ffi::EVP_DigestFinal(self.as_ptr(), out.as_mut_ptr(), &mut len))?;
    }
    Ok(len as usize)
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: digest_final_xof,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs

Found method with unsafe block in digest_final_xof:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs
Start Line: 262, End Line: 272
/// Copies the computed digest into the buffer.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(EVP_DigestFinalXOF)]
#[inline]
#[cfg(ossl111)]
pub fn digest_final_xof(&mut self, out: &mut [u8]) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_DigestFinalXOF(self.as_ptr(), out.as_mut_ptr(), out.len()))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: digest_sign_final,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs

Found method with unsafe block in digest_sign_final:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs
Start Line: 280, End Line: 292
/// Signs the computed digest.
///
/// If `out` is set to `None`, an upper bound on the number of bytes required for the output buffer will be
/// returned.
#[corresponds(EVP_DigestSignFinal)]
#[inline]
pub fn digest_sign_final(
    &mut self,
    out: Option<&mut [u8]>,
) -> Result<usize, ErrorStack> {
    let mut len = out.as_ref().map_or(0, |b| b.len());
    unsafe {
        cvt(
            ffi::EVP_DigestSignFinal(
                self.as_ptr(),
                out.map_or(ptr::null_mut(), |b| b.as_mut_ptr()),
                &mut len,
            ),
        )?;
    }
    Ok(len)
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: digest_verify_final,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs

Found method with unsafe block in digest_verify_final:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs
Start Line: 310, End Line: 319
/// Verifies the provided signature.
///
/// Returns `Ok(true)` if the signature is valid, `Ok(false)` if the signature is invalid, and `Err` if an error
/// occurred.
#[corresponds(EVP_DigestVerifyFinal)]
#[inline]
pub fn digest_verify_final(&mut self, signature: &[u8]) -> Result<bool, ErrorStack> {
    unsafe {
        let r = cvt_n(
            ffi::EVP_DigestVerifyFinal(
                self.as_ptr(),
                signature.as_ptr() as *mut _,
                signature.len(),
            ),
        )?;
        Ok(r == 1)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: digest_sign,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs

Found method with unsafe block in digest_sign:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs
Start Line: 330, End Line: 344
/// Computes the signature of the data in `from`.
///
/// If `to` is set to `None`, an upper bound on the number of bytes required for the output buffer will be
/// returned.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(EVP_DigestSign)]
#[cfg(ossl111)]
#[inline]
pub fn digest_sign(
    &mut self,
    from: &[u8],
    to: Option<&mut [u8]>,
) -> Result<usize, ErrorStack> {
    let mut len = to.as_ref().map_or(0, |b| b.len());
    unsafe {
        cvt(
            ffi::EVP_DigestSign(
                self.as_ptr(),
                to.map_or(ptr::null_mut(), |b| b.as_mut_ptr()),
                &mut len,
                from.as_ptr(),
                from.len(),
            ),
        )?;
    }
    Ok(len)
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: digest_verify,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs

Found method with unsafe block in digest_verify:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs
Start Line: 370, End Line: 381
/// Verifies the signature of the data in `data`.
///
/// Returns `Ok(true)` if the signature is valid, `Ok(false)` if the signature is invalid, and `Err` if an error
/// occurred.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(EVP_DigestVerify)]
#[cfg(ossl111)]
#[inline]
pub fn digest_verify(
    &mut self,
    data: &[u8],
    signature: &[u8],
) -> Result<bool, ErrorStack> {
    unsafe {
        let r = cvt(
            ffi::EVP_DigestVerify(
                self.as_ptr(),
                signature.as_ptr(),
                signature.len(),
                data.as_ptr(),
                data.len(),
            ),
        )?;
        Ok(r == 1)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: size,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs

Found method with unsafe block in size:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs
Start Line: 386, End Line: 388
/// Returns the size of the message digest, i.e. the size of the hash
#[corresponds(EVP_MD_CTX_size)]
#[inline]
pub fn size(&self) -> usize {
    unsafe { ffi::EVP_MD_CTX_size(self.as_ptr()) as usize }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: reset,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs

Found method with unsafe block in reset:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\md_ctx.rs
Start Line: 394, End Line: 399
/// Resets the underlying EVP_MD_CTX instance
#[corresponds(EVP_MD_CTX_reset)]
#[cfg(ossl111)]
#[inline]
pub fn reset(&mut self) -> Result<(), ErrorStack> {
    unsafe {
        let _ = cvt(ffi::EVP_MD_CTX_reset(self.as_ptr()))?;
        Ok(())
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\memcmp.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: eq,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\memcmp.rs

Found function with unsafe block in eq:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\memcmp.rs
Start Line: 65, End Line: 75
/// Returns `true` iff `a` and `b` contain the same bytes.
///
/// This operation takes an amount of time dependent on the length of the two
/// arrays given, but is independent of the contents of a and b.
///
/// # Panics
///
/// This function will panic the current task if `a` and `b` do not have the same
/// length.
///
/// # Examples
///
/// To perform a constant-time comparison of two arrays of the same length but different
/// values:
///
/// ```
/// use openssl::memcmp::eq;
///
/// // We want to compare `a` to `b` and `c`, without giving
/// // away through timing analysis that `c` is more similar to `a`
/// // than `b`.
/// let a = [0, 0, 0];
/// let b = [1, 1, 1];
/// let c = [0, 0, 1];
///
/// // These statements will execute in the same amount of time.
/// assert!(!eq(&a, &b));
/// assert!(!eq(&a, &c));
/// ```
#[corresponds(CRYPTO_memcmp)]
pub fn eq(a: &[u8], b: &[u8]) -> bool {
    assert!(a.len() == b.len());
    let ret = unsafe {
        ffi::CRYPTO_memcmp(
            a.as_ptr() as *const _,
            b.as_ptr() as *const _,
            a.len() as size_t,
        )
    };
    ret == 0
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\nid.rs
-----------------------------------------------------------------
Checking unsafe block with 6 statements, Complex: true, With_SAFETY_comment: false, Name: create,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\nid.rs

Found method with unsafe block in create:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\nid.rs
Start Line: 66, End Line: 79
/// Creates a new `Nid` for the `oid` with short name `sn` and long name `ln`.
#[corresponds(OBJ_create)]
pub fn create(oid: &str, sn: &str, ln: &str) -> Result<Nid, ErrorStack> {
    unsafe {
        ffi::init();
        let oid = CString::new(oid).unwrap();
        let sn = CString::new(sn).unwrap();
        let ln = CString::new(ln).unwrap();
        let raw = ffi::OBJ_create(oid.as_ptr(), sn.as_ptr(), ln.as_ptr());
        if raw == ffi::NID_undef { Err(ErrorStack::get()) } else { Ok(Nid(raw)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: true, With_SAFETY_comment: false, Name: signature_algorithms,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\nid.rs

Found method with unsafe block in signature_algorithms:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\nid.rs
Start Line: 86, End Line: 99
/// Returns the `Nid`s of the digest and public key algorithms associated with a signature ID.
///
/// This corresponds to `OBJ_find_sigid_algs`.
#[corresponds(OBJ_find_sigid_algs)]
#[allow(clippy::trivially_copy_pass_by_ref)]
pub fn signature_algorithms(&self) -> Option<SignatureAlgorithms> {
    unsafe {
        let mut digest = 0;
        let mut pkey = 0;
        if ffi::OBJ_find_sigid_algs(self.0, &mut digest, &mut pkey) == 1 {
            Some(SignatureAlgorithms {
                digest: Nid(digest),
                pkey: Nid(pkey),
            })
        } else {
            None
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: long_name,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\nid.rs

Found method with unsafe block in long_name:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\nid.rs
Start Line: 104, End Line: 109
/// Returns the string representation of a `Nid` (long).
#[corresponds(OBJ_nid2ln)]
#[allow(clippy::trivially_copy_pass_by_ref)]
pub fn long_name(&self) -> Result<&'static str, ErrorStack> {
    unsafe {
        cvt_p(ffi::OBJ_nid2ln(self.0) as *mut c_char)
            .map(|nameptr| str::from_utf8(CStr::from_ptr(nameptr).to_bytes()).unwrap())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: short_name,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\nid.rs

Found method with unsafe block in short_name:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\nid.rs
Start Line: 114, End Line: 119
/// Returns the string representation of a `Nid` (short).
#[corresponds(OBJ_nid2sn)]
#[allow(clippy::trivially_copy_pass_by_ref)]
pub fn short_name(&self) -> Result<&'static str, ErrorStack> {
    unsafe {
        cvt_p(ffi::OBJ_nid2sn(self.0) as *mut c_char)
            .map(|nameptr| str::from_utf8(CStr::from_ptr(nameptr).to_bytes()).unwrap())
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: check_validity,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs

Found method with unsafe block in check_validity:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs
Start Line: 134, End Line: 144
/// Checks validity of the `this_update` and `next_update` fields.
///
/// The `nsec` parameter specifies an amount of slack time that will be used when comparing
/// those times with the current time to account for delays and clock skew.
///
/// The `maxsec` parameter limits the maximum age of the `this_update` parameter to prohibit
/// very old responses.
#[corresponds(OCSP_check_validity)]
pub fn check_validity(&self, nsec: u32, maxsec: Option<u32>) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::OCSP_check_validity(
                    self.this_update.as_ptr(),
                    self.next_update.as_ptr(),
                    nsec as c_long,
                    maxsec.map(|n| n as c_long).unwrap_or(-1),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: verify,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs

Found method with unsafe block in verify:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs
Start Line: 161, End Line: 176
/// Verifies the validity of the response.
///
/// The `certs` parameter contains a set of certificates that will be searched when locating the
/// OCSP response signing certificate. Some responders do not include this in the response.
#[corresponds(OCSP_basic_verify)]
pub fn verify(
    &self,
    certs: &StackRef<X509>,
    store: &X509StoreRef,
    flags: OcspFlag,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::OCSP_basic_verify(
                    self.as_ptr(),
                    certs.as_ptr(),
                    store.as_ptr(),
                    flags.bits(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 7 statements, Complex: true, With_SAFETY_comment: false, Name: find_status,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs

Found method with unsafe block in find_status:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs
Start Line: 180, End Line: 211
/// Looks up the status for the specified certificate ID.
#[corresponds(OCSP_resp_find_status)]
pub fn find_status<'a>(&'a self, id: &OcspCertIdRef) -> Option<OcspStatus<'a>> {
    unsafe {
        let mut status = ffi::V_OCSP_CERTSTATUS_UNKNOWN;
        let mut reason = ffi::OCSP_REVOKED_STATUS_NOSTATUS;
        let mut revocation_time = ptr::null_mut();
        let mut this_update = ptr::null_mut();
        let mut next_update = ptr::null_mut();
        let r = ffi::OCSP_resp_find_status(
            self.as_ptr(),
            id.as_ptr(),
            &mut status,
            &mut reason,
            &mut revocation_time,
            &mut this_update,
            &mut next_update,
        );
        if r == 1 {
            let revocation_time = Asn1GeneralizedTimeRef::from_const_ptr_opt(
                revocation_time,
            );
            Some(OcspStatus {
                status: OcspCertStatus(status),
                reason: OcspRevokedStatus(status),
                revocation_time,
                this_update: Asn1GeneralizedTimeRef::from_ptr(this_update),
                next_update: Asn1GeneralizedTimeRef::from_ptr(next_update),
            })
        } else {
            None
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: from_cert,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs

Found method with unsafe block in from_cert:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs
Start Line: 225, End Line: 238
/// Constructs a certificate ID for certificate `subject`.
#[corresponds(OCSP_cert_to_id)]
pub fn from_cert(
    digest: MessageDigest,
    subject: &X509Ref,
    issuer: &X509Ref,
) -> Result<OcspCertId, ErrorStack> {
    unsafe {
        cvt_p(ffi::OCSP_cert_to_id(digest.as_ptr(), subject.as_ptr(), issuer.as_ptr()))
            .map(OcspCertId)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: create,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs

Found method with unsafe block in create:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs
Start Line: 254, End Line: 267
/// Creates an OCSP response from the status and optional body.
///
/// A body should only be provided if `status` is `RESPONSE_STATUS_SUCCESSFUL`.
#[corresponds(OCSP_response_create)]
pub fn create(
    status: OcspResponseStatus,
    body: Option<&OcspBasicResponseRef>,
) -> Result<OcspResponse, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(
                ffi::OCSP_response_create(
                    status.as_raw(),
                    body.map(|r| r.as_ptr()).unwrap_or(ptr::null_mut()),
                ),
            )
            .map(OcspResponse)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: status,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs

Found method with unsafe block in status:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs
Start Line: 288, End Line: 290
/// Returns the status of the response.
#[corresponds(OCSP_response_status)]
pub fn status(&self) -> OcspResponseStatus {
    unsafe { OcspResponseStatus(ffi::OCSP_response_status(self.as_ptr())) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: basic,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs

Found method with unsafe block in basic:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs
Start Line: 296, End Line: 298
/// Returns the basic response.
///
/// This will only succeed if `status()` returns `RESPONSE_STATUS_SUCCESSFUL`.
#[corresponds(OCSP_response_get1_basic)]
pub fn basic(&self) -> Result<OcspBasicResponse, ErrorStack> {
    unsafe { cvt_p(ffi::OCSP_response_get1_basic(self.as_ptr())).map(OcspBasicResponse) }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs
Start Line: 311, End Line: 317
#[corresponds(OCSP_REQUEST_new)]
pub fn new() -> Result<OcspRequest, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(ffi::OCSP_REQUEST_new()).map(OcspRequest)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: add_id,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs

Found method with unsafe block in add_id:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ocsp.rs
Start Line: 337, End Line: 343
#[corresponds(OCSP_request_add0_id)]
pub fn add_id(&mut self, id: OcspCertId) -> Result<&mut OcspOneReqRef, ErrorStack> {
    unsafe {
        let ptr = cvt_p(ffi::OCSP_request_add0_id(self.as_ptr(), id.as_ptr()))?;
        mem::forget(id);
        Ok(OcspOneReqRef::from_ptr_mut(ptr))
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs12.rs
-----------------------------------------------------------------
Checking unsafe block with 9 statements, Complex: false, With_SAFETY_comment: false, Name: parse2,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs12.rs

Found method with unsafe block in parse2:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs12.rs
Start Line: 50, End Line: 72
/// Extracts the contents of the `Pkcs12`.
#[corresponds(PKCS12_parse)]
pub fn parse2(&self, pass: &str) -> Result<ParsedPkcs12_2, ErrorStack> {
    unsafe {
        let pass = CString::new(pass.as_bytes()).unwrap();
        let mut pkey = ptr::null_mut();
        let mut cert = ptr::null_mut();
        let mut ca = ptr::null_mut();
        cvt(
            ffi::PKCS12_parse(
                self.as_ptr(),
                pass.as_ptr(),
                &mut pkey,
                &mut cert,
                &mut ca,
            ),
        )?;
        let pkey = PKey::from_ptr_opt(pkey);
        let cert = X509::from_ptr_opt(cert);
        let ca = Stack::from_ptr_opt(ca);
        Ok(ParsedPkcs12_2 { pkey, cert, ca })
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: pkey,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs12.rs

Found method with unsafe block in pkey:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs12.rs
Start Line: 147, End Line: 154
/// The private key.
pub fn pkey<T>(&mut self, pkey: &PKeyRef<T>) -> &mut Self
where
    T: HasPrivate,
{
    let new_pkey = unsafe { PKeyRef::from_ptr(pkey.as_ptr()) };
    self.pkey = Some(new_pkey.to_owned());
    self
}



-----------------------------------------------------------------
Checking unsafe block with 12 statements, Complex: false, With_SAFETY_comment: false, Name: build2,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs12.rs

Found method with unsafe block in build2:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs12.rs
Start Line: 226, End Line: 282
/// Builds the PKCS#12 object.
#[corresponds(PKCS12_create)]
pub fn build2(&self, password: &str) -> Result<Pkcs12, ErrorStack> {
    unsafe {
        let pass = CString::new(password).unwrap();
        let pass = pass.as_ptr();
        let friendly_name = self.name.as_ref().map_or(ptr::null(), |p| p.as_ptr());
        let pkey = self.pkey.as_ref().map_or(ptr::null(), |p| p.as_ptr());
        let cert = self.cert.as_ref().map_or(ptr::null(), |p| p.as_ptr());
        let ca = self.ca.as_ref().map(|ca| ca.as_ptr()).unwrap_or(ptr::null_mut());
        let nid_key = self.nid_key.as_raw();
        let nid_cert = self.nid_cert.as_raw();
        let keytype = 0;
        let pkcs12 = cvt_p(
                ffi::PKCS12_create(
                    pass as *mut _,
                    friendly_name as *mut _,
                    pkey as *mut _,
                    cert as *mut _,
                    ca,
                    nid_key,
                    nid_cert,
                    self.iter,
                    self.mac_iter,
                    keytype,
                ),
            )
            .map(Pkcs12)?;
        #[cfg(not(boringssl))]
        {
            let md_type = self
                .mac_md
                .map(|md_type| md_type.as_ptr())
                .unwrap_or(ptr::null());
            cvt(
                ffi::PKCS12_set_mac(
                    pkcs12.as_ptr(),
                    pass,
                    -1,
                    ptr::null_mut(),
                    0,
                    self.mac_iter,
                    md_type,
                ),
            )?;
        }
        Ok(pkcs12)
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs5.rs
-----------------------------------------------------------------
Checking unsafe block with 11 statements, Complex: false, With_SAFETY_comment: false, Name: bytes_to_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs5.rs

Found function with unsafe block in bytes_to_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs5.rs
Start Line: 33, End Line: 87
/// Derives a key and an IV from various parameters.
///
/// If specified, `salt` must be 8 bytes in length.
///
/// If the total key and IV length is less than 16 bytes and MD5 is used then
/// the algorithm is compatible with the key derivation algorithm from PKCS#5
/// v1.5 or PBKDF1 from PKCS#5 v2.0.
///
/// New applications should not use this and instead use
/// `pbkdf2_hmac` or another more modern key derivation algorithm.
#[corresponds(EVP_BytesToKey)]
#[allow(clippy::useless_conversion)]
#[cfg(not(boringssl))]
pub fn bytes_to_key(
    cipher: Cipher,
    digest: MessageDigest,
    data: &[u8],
    salt: Option<&[u8]>,
    count: i32,
) -> Result<KeyIvPair, ErrorStack> {
    unsafe {
        assert!(data.len() <= c_int::MAX as usize);
        let salt_ptr = match salt {
            Some(salt) => {
                assert_eq!(salt.len(), ffi::PKCS5_SALT_LEN as usize);
                salt.as_ptr()
            }
            None => ptr::null(),
        };
        ffi::init();
        let mut iv = cipher.iv_len().map(|l| vec![0; l]);
        let cipher = cipher.as_ptr();
        let digest = digest.as_ptr();
        let len = cvt(
            ffi::EVP_BytesToKey(
                cipher,
                digest,
                salt_ptr,
                ptr::null(),
                data.len() as c_int,
                count.into(),
                ptr::null_mut(),
                ptr::null_mut(),
            ),
        )?;
        let mut key = vec![0; len as usize];
        let iv_ptr = iv.as_mut().map(|v| v.as_mut_ptr()).unwrap_or(ptr::null_mut());
        cvt(
            ffi::EVP_BytesToKey(
                cipher,
                digest,
                salt_ptr,
                data.as_ptr(),
                data.len() as c_int,
                count as c_int,
                key.as_mut_ptr(),
                iv_ptr,
            ),
        )?;
        Ok(KeyIvPair { key, iv })
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: pbkdf2_hmac,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs5.rs

Found function with unsafe block in pbkdf2_hmac:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs5.rs
Start Line: 91, End Line: 112
/// Derives a key from a password and salt using the PBKDF2-HMAC algorithm with a digest function.
#[corresponds(PKCS5_PBKDF2_HMAC)]
pub fn pbkdf2_hmac(
    pass: &[u8],
    salt: &[u8],
    iter: usize,
    hash: MessageDigest,
    key: &mut [u8],
) -> Result<(), ErrorStack> {
    unsafe {
        ffi::init();
        cvt(
                ffi::PKCS5_PBKDF2_HMAC(
                    pass.as_ptr() as *const _,
                    pass.len().try_into().unwrap(),
                    salt.as_ptr(),
                    salt.len().try_into().unwrap(),
                    iter.try_into().unwrap(),
                    hash.as_ptr(),
                    key.len().try_into().unwrap(),
                    key.as_mut_ptr(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: scrypt,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs5.rs

Found function with unsafe block in scrypt:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs5.rs
Start Line: 120, End Line: 145
/// Derives a key from a password and salt using the scrypt algorithm.
///
/// Requires OpenSSL 1.1.0 or newer.
#[corresponds(EVP_PBE_scrypt)]
#[cfg(all(any(ossl110, boringssl), not(osslconf = "OPENSSL_NO_SCRYPT")))]
#[allow(clippy::useless_conversion)]
pub fn scrypt(
    pass: &[u8],
    salt: &[u8],
    n: u64,
    r: u64,
    p: u64,
    maxmem: u64,
    key: &mut [u8],
) -> Result<(), ErrorStack> {
    unsafe {
        ffi::init();
        cvt(
                ffi::EVP_PBE_scrypt(
                    pass.as_ptr() as *const _,
                    pass.len(),
                    salt.as_ptr() as *const _,
                    salt.len(),
                    n,
                    r,
                    p,
                    maxmem.try_into().unwrap(),
                    key.as_mut_ptr() as *mut _,
                    key.len(),
                ),
            )
            .map(|_| ())
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs
-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: from_smime,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs

Found method with unsafe block in from_smime:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs
Start Line: 107, End Line: 123
/// Parses a message in S/MIME format.
///
/// Returns the loaded signature, along with the cleartext message (if
/// available).
#[corresponds(SMIME_read_PKCS7)]
pub fn from_smime(input: &[u8]) -> Result<(Pkcs7, Option<Vec<u8>>), ErrorStack> {
    ffi::init();
    let input_bio = MemBioSlice::new(input)?;
    let mut bcont_bio = ptr::null_mut();
    unsafe {
        let pkcs7 = cvt_p(ffi::SMIME_read_PKCS7(input_bio.as_ptr(), &mut bcont_bio))
            .map(Pkcs7)?;
        let out = if !bcont_bio.is_null() {
            let bcont_bio = MemBio::from_ptr(bcont_bio);
            Some(bcont_bio.get_buf().to_vec())
        } else {
            None
        };
        Ok((pkcs7, out))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: encrypt,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs

Found method with unsafe block in encrypt:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs
Start Line: 131, End Line: 148
/// Creates and returns a PKCS#7 `envelopedData` structure.
///
/// `certs` is a list of recipient certificates. `input` is the content to be
/// encrypted. `cipher` is the symmetric cipher to use. `flags` is an optional
/// set of flags.
#[corresponds(PKCS7_encrypt)]
pub fn encrypt(
    certs: &StackRef<X509>,
    input: &[u8],
    cipher: Cipher,
    flags: Pkcs7Flags,
) -> Result<Pkcs7, ErrorStack> {
    let input_bio = MemBioSlice::new(input)?;
    unsafe {
        cvt_p(
                ffi::PKCS7_encrypt(
                    certs.as_ptr(),
                    input_bio.as_ptr(),
                    cipher.as_ptr(),
                    flags.bits(),
                ),
            )
            .map(Pkcs7)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sign,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs

Found method with unsafe block in sign:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs
Start Line: 157, End Line: 178
/// Creates and returns a PKCS#7 `signedData` structure.
///
/// `signcert` is the certificate to sign with, `pkey` is the corresponding
/// private key. `certs` is an optional additional set of certificates to
/// include in the PKCS#7 structure (for example any intermediate CAs in the
/// chain).
#[corresponds(PKCS7_sign)]
pub fn sign<PT>(
    signcert: &X509Ref,
    pkey: &PKeyRef<PT>,
    certs: &StackRef<X509>,
    input: &[u8],
    flags: Pkcs7Flags,
) -> Result<Pkcs7, ErrorStack>
where
    PT: HasPrivate,
{
    let input_bio = MemBioSlice::new(input)?;
    unsafe {
        cvt_p(
                ffi::PKCS7_sign(
                    signcert.as_ptr(),
                    pkey.as_ptr(),
                    certs.as_ptr(),
                    input_bio.as_ptr(),
                    flags.bits(),
                ),
            )
            .map(Pkcs7)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: to_smime,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs

Found method with unsafe block in to_smime:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs
Start Line: 184, End Line: 196
/// Converts PKCS#7 structure to S/MIME format
#[corresponds(SMIME_write_PKCS7)]
pub fn to_smime(&self, input: &[u8], flags: Pkcs7Flags) -> Result<Vec<u8>, ErrorStack> {
    let input_bio = MemBioSlice::new(input)?;
    let output = MemBio::new()?;
    unsafe {
        cvt(
                ffi::SMIME_write_PKCS7(
                    output.as_ptr(),
                    self.as_ptr(),
                    input_bio.as_ptr(),
                    flags.bits(),
                ),
            )
            .map(|_| output.get_buf().to_owned())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: decrypt,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs

Found method with unsafe block in decrypt:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs
Start Line: 221, End Line: 242
/// Decrypts data using the provided private key.
///
/// `pkey` is the recipient's private key, and `cert` is the recipient's
/// certificate.
///
/// Returns the decrypted message.
#[corresponds(PKCS7_decrypt)]
pub fn decrypt<PT>(
    &self,
    pkey: &PKeyRef<PT>,
    cert: &X509Ref,
    flags: Pkcs7Flags,
) -> Result<Vec<u8>, ErrorStack>
where
    PT: HasPrivate,
{
    let output = MemBio::new()?;
    unsafe {
        cvt(
                ffi::PKCS7_decrypt(
                    self.as_ptr(),
                    pkey.as_ptr(),
                    cert.as_ptr(),
                    output.as_ptr(),
                    flags.bits(),
                ),
            )
            .map(|_| output.get_buf().to_owned())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: verify,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs

Found method with unsafe block in verify:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs
Start Line: 251, End Line: 285
/// Verifies the PKCS#7 `signedData` structure contained by `&self`.
///
/// `certs` is a set of certificates in which to search for the signer's
/// certificate. `store` is a trusted certificate store (used for chain
/// verification). `indata` is the signed data if the content is not present
/// in `&self`. The content is written to `out` if it is not `None`.
#[corresponds(PKCS7_verify)]
pub fn verify(
    &self,
    certs: &StackRef<X509>,
    store: &X509StoreRef,
    indata: Option<&[u8]>,
    out: Option<&mut Vec<u8>>,
    flags: Pkcs7Flags,
) -> Result<(), ErrorStack> {
    let out_bio = MemBio::new()?;
    let indata_bio = match indata {
        Some(data) => Some(MemBioSlice::new(data)?),
        None => None,
    };
    let indata_bio_ptr = indata_bio.as_ref().map_or(ptr::null_mut(), |p| p.as_ptr());
    unsafe {
        cvt(
                ffi::PKCS7_verify(
                    self.as_ptr(),
                    certs.as_ptr(),
                    store.as_ptr(),
                    indata_bio_ptr,
                    out_bio.as_ptr(),
                    flags.bits(),
                ),
            )
            .map(|_| ())?
    }
    if let Some(data) = out {
        data.clear();
        data.extend_from_slice(out_bio.get_buf());
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: true, With_SAFETY_comment: false, Name: signers,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs

Found method with unsafe block in signers:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs
Start Line: 289, End Line: 311
/// Retrieve the signer's certificates from the PKCS#7 structure without verifying them.
#[corresponds(PKCS7_get0_signers)]
pub fn signers(
    &self,
    certs: &StackRef<X509>,
    flags: Pkcs7Flags,
) -> Result<Stack<X509>, ErrorStack> {
    unsafe {
        let ptr = cvt_p(
            ffi::PKCS7_get0_signers(self.as_ptr(), certs.as_ptr(), flags.bits()),
        )?;
        let stack = Stack::<X509>::from_ptr(ptr);
        for cert in &stack {
            mem::forget(cert.to_owned());
        }
        Ok(stack)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: type_,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs

Found method with unsafe block in type_:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs
Start Line: 314, End Line: 319
/// Return the type of a PKCS#7 structure as an Asn1Object
pub fn type_(&self) -> Option<&Asn1ObjectRef> {
    unsafe {
        let ptr = (*self.as_ptr()).type_;
        Asn1ObjectRef::from_const_ptr_opt(ptr)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: true, With_SAFETY_comment: false, Name: signed,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs

Found method with unsafe block in signed:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs
Start Line: 322, End Line: 330
/// Get the signed data of a PKCS#7 structure of type PKCS7_SIGNED
pub fn signed(&self) -> Option<&Pkcs7SignedRef> {
    unsafe {
        if self.type_().map(|x| x.nid()) != Some(Nid::PKCS7_SIGNED) {
            return None;
        }
        let signed_data = (*self.as_ptr()).d.sign;
        Pkcs7SignedRef::from_const_ptr_opt(signed_data)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: certificates,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs

Found method with unsafe block in certificates:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkcs7.rs
Start Line: 335, End Line: 342
/// Get the stack of certificates from the PKCS7_SIGNED object
pub fn certificates(&self) -> Option<&StackRef<X509>> {
    unsafe {
        self.as_ptr()
            .as_ref()
            .and_then(|x| x.cert.as_mut())
            .and_then(|x| StackRef::<X509>::from_const_ptr_opt(x))
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: to_owned,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in to_owned:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 153, End Line: 158
fn to_owned(&self) -> PKey<T> {
    unsafe {
        EVP_PKEY_up_ref(self.as_ptr());
        PKey::from_ptr(self.as_ptr())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: rsa,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in rsa:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 164, End Line: 169
/// Returns a copy of the internal RSA key.
#[corresponds(EVP_PKEY_get1_RSA)]
pub fn rsa(&self) -> Result<Rsa<T>, ErrorStack> {
    unsafe {
        let rsa = cvt_p(ffi::EVP_PKEY_get1_RSA(self.as_ptr()))?;
        Ok(Rsa::from_ptr(rsa))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: dsa,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in dsa:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 173, End Line: 178
/// Returns a copy of the internal DSA key.
#[corresponds(EVP_PKEY_get1_DSA)]
pub fn dsa(&self) -> Result<Dsa<T>, ErrorStack> {
    unsafe {
        let dsa = cvt_p(ffi::EVP_PKEY_get1_DSA(self.as_ptr()))?;
        Ok(Dsa::from_ptr(dsa))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: dh,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in dh:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 182, End Line: 187
/// Returns a copy of the internal DH key.
#[corresponds(EVP_PKEY_get1_DH)]
pub fn dh(&self) -> Result<Dh<T>, ErrorStack> {
    unsafe {
        let dh = cvt_p(ffi::EVP_PKEY_get1_DH(self.as_ptr()))?;
        Ok(Dh::from_ptr(dh))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: ec_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in ec_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 191, End Line: 196
/// Returns a copy of the internal elliptic curve key.
#[corresponds(EVP_PKEY_get1_EC_KEY)]
pub fn ec_key(&self) -> Result<EcKey<T>, ErrorStack> {
    unsafe {
        let ec_key = cvt_p(ffi::EVP_PKEY_get1_EC_KEY(self.as_ptr()))?;
        Ok(EcKey::from_ptr(ec_key))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: id,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in id:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 200, End Line: 202
/// Returns the `Id` that represents the type of this key.
#[corresponds(EVP_PKEY_id)]
pub fn id(&self) -> Id {
    unsafe { Id::from_raw(ffi::EVP_PKEY_id(self.as_ptr())) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: size,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in size:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 206, End Line: 208
/// Returns the maximum size of a signature in bytes.
#[corresponds(EVP_PKEY_size)]
pub fn size(&self) -> usize {
    unsafe { ffi::EVP_PKEY_size(self.as_ptr()) as usize }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: bits,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in bits:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 236, End Line: 238
/// Returns the size of the key.
///
/// This corresponds to the bit length of the modulus of an RSA key, and the bit length of the
/// group order for an elliptic curve key, for example.
#[corresponds(EVP_PKEY_bits)]
pub fn bits(&self) -> u32 {
    unsafe { ffi::EVP_PKEY_bits(self.as_ptr()) as u32 }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: security_bits,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in security_bits:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 245, End Line: 247
///Returns the number of security bits.
///
///Bits of security is defined in NIST SP800-57.
#[corresponds(EVP_PKEY_security_bits)]
#[cfg(any(ossl110, libressl360))]
pub fn security_bits(&self) -> u32 {
    unsafe { ffi::EVP_PKEY_security_bits(self.as_ptr()) as u32 }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: public_eq,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in public_eq:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 251, End Line: 260
/// Compares the public component of this key with another.
#[corresponds(EVP_PKEY_cmp)]
pub fn public_eq<U>(&self, other: &PKeyRef<U>) -> bool
where
    U: HasPublic,
{
    let res = unsafe { ffi::EVP_PKEY_cmp(self.as_ptr(), other.as_ptr()) == 1 };
    let _ = ErrorStack::get();
    res
}



-----------------------------------------------------------------
Checking unsafe block with 6 statements, Complex: false, With_SAFETY_comment: false, Name: raw_public_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in raw_public_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 268, End Line: 285
/// Raw byte representation of a public key.
///
/// This function only works for algorithms that support raw public keys.
/// Currently this is: [`Id::X25519`], [`Id::ED25519`], [`Id::X448`] or [`Id::ED448`].
#[corresponds(EVP_PKEY_get_raw_public_key)]
#[cfg(any(ossl111, boringssl, libressl370))]
pub fn raw_public_key(&self) -> Result<Vec<u8>, ErrorStack> {
    unsafe {
        let mut len = 0;
        cvt(ffi::EVP_PKEY_get_raw_public_key(self.as_ptr(), ptr::null_mut(), &mut len))?;
        let mut buf = vec![0u8; len];
        cvt(
            ffi::EVP_PKEY_get_raw_public_key(self.as_ptr(), buf.as_mut_ptr(), &mut len),
        )?;
        buf.truncate(len);
        Ok(buf)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 6 statements, Complex: false, With_SAFETY_comment: false, Name: raw_private_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in raw_private_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 319, End Line: 336
/// Raw byte representation of a private key.
///
/// This function only works for algorithms that support raw private keys.
/// Currently this is: [`Id::HMAC`], [`Id::X25519`], [`Id::ED25519`], [`Id::X448`] or [`Id::ED448`].
#[corresponds(EVP_PKEY_get_raw_private_key)]
#[cfg(any(ossl111, boringssl, libressl370))]
pub fn raw_private_key(&self) -> Result<Vec<u8>, ErrorStack> {
    unsafe {
        let mut len = 0;
        cvt(
            ffi::EVP_PKEY_get_raw_private_key(self.as_ptr(), ptr::null_mut(), &mut len),
        )?;
        let mut buf = vec![0u8; len];
        cvt(
            ffi::EVP_PKEY_get_raw_private_key(self.as_ptr(), buf.as_mut_ptr(), &mut len),
        )?;
        buf.truncate(len);
        Ok(buf)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: private_key_to_pkcs8,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in private_key_to_pkcs8:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 340, End Line: 355
/// Serializes a private key into an unencrypted DER-formatted PKCS#8
#[corresponds(i2d_PKCS8PrivateKey_bio)]
pub fn private_key_to_pkcs8(&self) -> Result<Vec<u8>, ErrorStack> {
    unsafe {
        let bio = MemBio::new()?;
        cvt(
            ffi::i2d_PKCS8PrivateKey_bio(
                bio.as_ptr(),
                self.as_ptr(),
                ptr::null(),
                ptr::null_mut(),
                0,
                None,
                ptr::null_mut(),
            ),
        )?;
        Ok(bio.get_buf().to_owned())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: private_key_to_pkcs8_passphrase,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in private_key_to_pkcs8_passphrase:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 360, End Line: 379
/// Serializes a private key into a DER-formatted PKCS#8, using the supplied password to
/// encrypt the key.
#[corresponds(i2d_PKCS8PrivateKey_bio)]
pub fn private_key_to_pkcs8_passphrase(
    &self,
    cipher: Cipher,
    passphrase: &[u8],
) -> Result<Vec<u8>, ErrorStack> {
    unsafe {
        let bio = MemBio::new()?;
        cvt(
            ffi::i2d_PKCS8PrivateKey_bio(
                bio.as_ptr(),
                self.as_ptr(),
                cipher.as_ptr(),
                passphrase.as_ptr() as *const _ as *mut _,
                passphrase.len().try_into().unwrap(),
                None,
                ptr::null_mut(),
            ),
        )?;
        Ok(bio.get_buf().to_owned())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: from_rsa,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in from_rsa:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 411, End Line: 419
/// Creates a new `PKey` containing an RSA key.
#[corresponds(EVP_PKEY_assign_RSA)]
pub fn from_rsa(rsa: Rsa<T>) -> Result<PKey<T>, ErrorStack> {
    unsafe {
        let evp = cvt_p(ffi::EVP_PKEY_new())?;
        let pkey = PKey::from_ptr(evp);
        cvt(ffi::EVP_PKEY_assign_RSA(pkey.0, rsa.as_ptr()))?;
        mem::forget(rsa);
        Ok(pkey)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: from_dsa,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in from_dsa:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 423, End Line: 431
/// Creates a new `PKey` containing a DSA key.
#[corresponds(EVP_PKEY_assign_DSA)]
pub fn from_dsa(dsa: Dsa<T>) -> Result<PKey<T>, ErrorStack> {
    unsafe {
        let evp = cvt_p(ffi::EVP_PKEY_new())?;
        let pkey = PKey::from_ptr(evp);
        cvt(ffi::EVP_PKEY_assign_DSA(pkey.0, dsa.as_ptr()))?;
        mem::forget(dsa);
        Ok(pkey)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: from_dh,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in from_dh:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 436, End Line: 444
/// Creates a new `PKey` containing a Diffie-Hellman key.
#[corresponds(EVP_PKEY_assign_DH)]
#[cfg(not(boringssl))]
pub fn from_dh(dh: Dh<T>) -> Result<PKey<T>, ErrorStack> {
    unsafe {
        let evp = cvt_p(ffi::EVP_PKEY_new())?;
        let pkey = PKey::from_ptr(evp);
        cvt(ffi::EVP_PKEY_assign_DH(pkey.0, dh.as_ptr()))?;
        mem::forget(dh);
        Ok(pkey)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: from_dhx,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in from_dhx:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 448, End Line: 460
/// Creates a new `PKey` containing a Diffie-Hellman key with type DHX.
#[cfg(all(not(boringssl), ossl110))]
pub fn from_dhx(dh: Dh<T>) -> Result<PKey<T>, ErrorStack> {
    unsafe {
        let evp = cvt_p(ffi::EVP_PKEY_new())?;
        let pkey = PKey::from_ptr(evp);
        cvt(ffi::EVP_PKEY_assign(pkey.0, ffi::EVP_PKEY_DHX, dh.as_ptr().cast()))?;
        mem::forget(dh);
        Ok(pkey)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: from_ec_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in from_ec_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 464, End Line: 472
/// Creates a new `PKey` containing an elliptic curve key.
#[corresponds(EVP_PKEY_assign_EC_KEY)]
pub fn from_ec_key(ec_key: EcKey<T>) -> Result<PKey<T>, ErrorStack> {
    unsafe {
        let evp = cvt_p(ffi::EVP_PKEY_new())?;
        let pkey = PKey::from_ptr(evp);
        cvt(ffi::EVP_PKEY_assign_EC_KEY(pkey.0, ec_key.as_ptr()))?;
        mem::forget(ec_key);
        Ok(pkey)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: hmac,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in hmac:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 483, End Line: 494
/// Creates a new `PKey` containing an HMAC key.
///
/// # Note
///
/// To compute HMAC values, use the `sign` module.
#[corresponds(EVP_PKEY_new_mac_key)]
#[cfg(not(boringssl))]
pub fn hmac(key: &[u8]) -> Result<PKey<Private>, ErrorStack> {
    unsafe {
        assert!(key.len() <= c_int::MAX as usize);
        let key = cvt_p(
            ffi::EVP_PKEY_new_mac_key(
                ffi::EVP_PKEY_HMAC,
                ptr::null_mut(),
                key.as_ptr() as *const _,
                key.len() as c_int,
            ),
        )?;
        Ok(PKey::from_ptr(key))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cmac,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in cmac:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 505, End Line: 511
/// Creates a new `PKey` containing a CMAC key.
///
/// Requires OpenSSL 1.1.0 or newer.
///
/// # Note
///
/// To compute CMAC values, use the `sign` module.
#[cfg(all(not(boringssl), ossl110))]
#[allow(clippy::trivially_copy_pass_by_ref)]
pub fn cmac(cipher: &Cipher, key: &[u8]) -> Result<PKey<Private>, ErrorStack> {
    let mut ctx = PkeyCtx::new_id(Id::CMAC)?;
    ctx.keygen_init()?;
    ctx.set_keygen_cipher(unsafe { CipherRef::from_ptr(cipher.as_ptr() as *mut _) })?;
    ctx.set_keygen_mac_key(key)?;
    ctx.keygen()
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: ec_gen,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in ec_gen:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 633, End Line: 641
/// Generates a new EC key using the provided curve.
///
/// Requires OpenSSL 3.0.0 or newer.
#[corresponds(EVP_EC_gen)]
#[cfg(ossl300)]
pub fn ec_gen(curve: &str) -> Result<PKey<Private>, ErrorStack> {
    ffi::init();
    let curve = CString::new(curve).unwrap();
    unsafe {
        let ptr = cvt_p(ffi::EVP_EC_gen(curve.as_ptr()))?;
        Ok(PKey::from_ptr(ptr))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 6 statements, Complex: false, With_SAFETY_comment: false, Name: private_key_from_pkcs8,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in private_key_from_pkcs8:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 676, End Line: 689
/// Deserializes a DER-formatted PKCS#8 unencrypted private key.
///
/// This method is mainly for interoperability reasons. Encrypted keyfiles should be preferred.
pub fn private_key_from_pkcs8(der: &[u8]) -> Result<PKey<Private>, ErrorStack> {
    unsafe {
        ffi::init();
        let len = der.len().min(c_long::MAX as usize) as c_long;
        let p8inf = cvt_p(
            ffi::d2i_PKCS8_PRIV_KEY_INFO(ptr::null_mut(), &mut der.as_ptr(), len),
        )?;
        let res = cvt_p(ffi::EVP_PKCS82PKEY(p8inf)).map(|p| PKey::from_ptr(p));
        ffi::PKCS8_PRIV_KEY_INFO_free(p8inf);
        res
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: private_key_from_pkcs8_callback,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in private_key_from_pkcs8_callback:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 697, End Line: 716
/// Deserializes a DER-formatted PKCS#8 private key, using a callback to retrieve the password
/// if the key is encrypted.
///
/// The callback should copy the password into the provided buffer and return the number of
/// bytes written.
#[corresponds(d2i_PKCS8PrivateKey_bio)]
pub fn private_key_from_pkcs8_callback<F>(
    der: &[u8],
    callback: F,
) -> Result<PKey<Private>, ErrorStack>
where
    F: FnOnce(&mut [u8]) -> Result<usize, ErrorStack>,
{
    unsafe {
        ffi::init();
        let mut cb = CallbackState::new(callback);
        let bio = MemBioSlice::new(der)?;
        cvt_p(
                ffi::d2i_PKCS8PrivateKey_bio(
                    bio.as_ptr(),
                    ptr::null_mut(),
                    Some(invoke_passwd_cb::<F>),
                    &mut cb as *mut _ as *mut _,
                ),
            )
            .map(|p| PKey::from_ptr(p))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: private_key_from_pkcs8_passphrase,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in private_key_from_pkcs8_passphrase:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 725, End Line: 741
/// Deserializes a DER-formatted PKCS#8 private key, using the supplied password if the key is
/// encrypted.
///
/// # Panics
///
/// Panics if `passphrase` contains an embedded null.
#[corresponds(d2i_PKCS8PrivateKey_bio)]
pub fn private_key_from_pkcs8_passphrase(
    der: &[u8],
    passphrase: &[u8],
) -> Result<PKey<Private>, ErrorStack> {
    unsafe {
        ffi::init();
        let bio = MemBioSlice::new(der)?;
        let passphrase = CString::new(passphrase).unwrap();
        cvt_p(
                ffi::d2i_PKCS8PrivateKey_bio(
                    bio.as_ptr(),
                    ptr::null_mut(),
                    None,
                    passphrase.as_ptr() as *const _ as *mut _,
                ),
            )
            .map(|p| PKey::from_ptr(p))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: private_key_from_raw_bytes,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in private_key_from_raw_bytes:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 748, End Line: 762
/// Creates a private key from its raw byte representation
///
/// Algorithm types that support raw private keys are HMAC, X25519, ED25519, X448 or ED448
#[corresponds(EVP_PKEY_new_raw_private_key)]
#[cfg(any(ossl111, boringssl, libressl370))]
pub fn private_key_from_raw_bytes(
    bytes: &[u8],
    key_type: Id,
) -> Result<PKey<Private>, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(
                ffi::EVP_PKEY_new_raw_private_key(
                    key_type.as_raw(),
                    ptr::null_mut(),
                    bytes.as_ptr(),
                    bytes.len(),
                ),
            )
            .map(|p| PKey::from_ptr(p))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: public_key_from_raw_bytes,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs

Found method with unsafe block in public_key_from_raw_bytes:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey.rs
Start Line: 799, End Line: 813
/// Creates a public key from its raw byte representation
///
/// Algorithm types that support raw public keys are X25519, ED25519, X448 or ED448
#[corresponds(EVP_PKEY_new_raw_public_key)]
#[cfg(any(ossl111, boringssl, libressl370))]
pub fn public_key_from_raw_bytes(
    bytes: &[u8],
    key_type: Id,
) -> Result<PKey<Public>, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(
                ffi::EVP_PKEY_new_raw_public_key(
                    key_type.as_raw(),
                    ptr::null_mut(),
                    bytes.as_ptr(),
                    bytes.len(),
                ),
            )
            .map(|p| PKey::from_ptr(p))
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 141, End Line: 146
/// Creates a new pkey context using the provided key.
#[corresponds(EVP_PKEY_CTX_new)]
#[inline]
pub fn new(pkey: &PKeyRef<T>) -> Result<Self, ErrorStack> {
    unsafe {
        let ptr = cvt_p(ffi::EVP_PKEY_CTX_new(pkey.as_ptr(), ptr::null_mut()))?;
        Ok(PkeyCtx::from_ptr(ptr))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: new_id,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in new_id:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 153, End Line: 158
/// Creates a new pkey context for the specified algorithm ID.
#[corresponds(EVP_PKEY_new_id)]
#[inline]
pub fn new_id(id: Id) -> Result<Self, ErrorStack> {
    unsafe {
        let ptr = cvt_p(ffi::EVP_PKEY_CTX_new_id(id.as_raw(), ptr::null_mut()))?;
        Ok(PkeyCtx::from_ptr(ptr))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: encrypt_init,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in encrypt_init:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 168, End Line: 174
/// Prepares the context for encryption using the public key.
#[corresponds(EVP_PKEY_encrypt_init)]
#[inline]
pub fn encrypt_init(&mut self) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_encrypt_init(self.as_ptr()))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: verify_init,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in verify_init:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 179, End Line: 185
/// Prepares the context for signature verification using the public key.
#[corresponds(EVP_PKEY_verify_init)]
#[inline]
pub fn verify_init(&mut self) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_verify_init(self.as_ptr()))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: verify_recover_init,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in verify_recover_init:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 190, End Line: 196
/// Prepares the context for signature recovery using the public key.
#[corresponds(EVP_PKEY_verify_recover_init)]
#[inline]
pub fn verify_recover_init(&mut self) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_verify_recover_init(self.as_ptr()))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: encrypt,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in encrypt:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 204, End Line: 217
/// Encrypts data using the public key.
///
/// If `to` is set to `None`, an upper bound on the number of bytes required for the output buffer will be
/// returned.
#[corresponds(EVP_PKEY_encrypt)]
#[inline]
pub fn encrypt(
    &mut self,
    from: &[u8],
    to: Option<&mut [u8]>,
) -> Result<usize, ErrorStack> {
    let mut written = to.as_ref().map_or(0, |b| b.len());
    unsafe {
        cvt(
            ffi::EVP_PKEY_encrypt(
                self.as_ptr(),
                to.map_or(ptr::null_mut(), |b| b.as_mut_ptr()),
                &mut written,
                from.as_ptr(),
                from.len(),
            ),
        )?;
    }
    Ok(written)
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: true, With_SAFETY_comment: false, Name: verify,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in verify:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 241, End Line: 264
/// Verifies the signature of data using the public key.
///
/// Returns `Ok(true)` if the signature is valid, `Ok(false)` if the signature is invalid, and `Err` if an error
/// occurred.
///
/// # Note
///
/// This verifies the signature of the *raw* data. It is more common to compute and verify the signature of the
/// cryptographic hash of an arbitrary amount of data. The [`MdCtx`](crate::md_ctx::MdCtx) type can be used to do
/// that.
#[corresponds(EVP_PKEY_verify)]
#[inline]
pub fn verify(&mut self, data: &[u8], sig: &[u8]) -> Result<bool, ErrorStack> {
    unsafe {
        let r = ffi::EVP_PKEY_verify(
            self.as_ptr(),
            sig.as_ptr(),
            sig.len(),
            data.as_ptr(),
            data.len(),
        );
        if r <= 0 {
            let errors = ErrorStack::get();
            if !errors.errors().is_empty() {
                return Err(errors);
            }
        }
        Ok(r == 1)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: verify_recover,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in verify_recover:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 273, End Line: 290
/// Recovers the original data signed by the private key. You almost
/// always want `verify` instead.
///
/// Returns the number of bytes written to `to`, or the number of bytes
/// that would be written, if `to` is `None.
#[corresponds(EVP_PKEY_verify_recover)]
#[inline]
pub fn verify_recover(
    &mut self,
    sig: &[u8],
    to: Option<&mut [u8]>,
) -> Result<usize, ErrorStack> {
    let mut written = to.as_ref().map_or(0, |b| b.len());
    unsafe {
        cvt(
            ffi::EVP_PKEY_verify_recover(
                self.as_ptr(),
                to.map_or(ptr::null_mut(), |b| b.as_mut_ptr()),
                &mut written,
                sig.as_ptr(),
                sig.len(),
            ),
        )?;
    }
    Ok(written)
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: decrypt_init,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in decrypt_init:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 300, End Line: 306
/// Prepares the context for decryption using the private key.
#[corresponds(EVP_PKEY_decrypt_init)]
#[inline]
pub fn decrypt_init(&mut self) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_decrypt_init(self.as_ptr()))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sign_init,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in sign_init:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 311, End Line: 317
/// Prepares the context for signing using the private key.
#[corresponds(EVP_PKEY_sign_init)]
#[inline]
pub fn sign_init(&mut self) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_sign_init(self.as_ptr()))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: derive_set_peer,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in derive_set_peer:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 321, End Line: 330
/// Sets the peer key used for secret derivation.
#[corresponds(EVP_PKEY_derive_set_peer)]
pub fn derive_set_peer<U>(&mut self, key: &PKeyRef<U>) -> Result<(), ErrorStack>
where
    U: HasPublic,
{
    unsafe {
        cvt(ffi::EVP_PKEY_derive_set_peer(self.as_ptr(), key.as_ptr()))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: decrypt,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in decrypt:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 338, End Line: 351
/// Decrypts data using the private key.
///
/// If `to` is set to `None`, an upper bound on the number of bytes required for the output buffer will be
/// returned.
#[corresponds(EVP_PKEY_decrypt)]
#[inline]
pub fn decrypt(
    &mut self,
    from: &[u8],
    to: Option<&mut [u8]>,
) -> Result<usize, ErrorStack> {
    let mut written = to.as_ref().map_or(0, |b| b.len());
    unsafe {
        cvt(
            ffi::EVP_PKEY_decrypt(
                self.as_ptr(),
                to.map_or(ptr::null_mut(), |b| b.as_mut_ptr()),
                &mut written,
                from.as_ptr(),
                from.len(),
            ),
        )?;
    }
    Ok(written)
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sign,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in sign:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 374, End Line: 387
/// Signs the contents of `data`.
///
/// If `sig` is set to `None`, an upper bound on the number of bytes required for the output buffer will be
/// returned.
///
/// # Note
///
/// This computes the signature of the *raw* bytes of `data`. It is more common to sign the cryptographic hash of
/// an arbitrary amount of data. The [`MdCtx`](crate::md_ctx::MdCtx) type can be used to do that.
#[corresponds(EVP_PKEY_sign)]
#[inline]
pub fn sign(
    &mut self,
    data: &[u8],
    sig: Option<&mut [u8]>,
) -> Result<usize, ErrorStack> {
    let mut written = sig.as_ref().map_or(0, |b| b.len());
    unsafe {
        cvt(
            ffi::EVP_PKEY_sign(
                self.as_ptr(),
                sig.map_or(ptr::null_mut(), |b| b.as_mut_ptr()),
                &mut written,
                data.as_ptr(),
                data.len(),
            ),
        )?;
    }
    Ok(written)
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: derive_init,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in derive_init:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 404, End Line: 410
/// Prepares the context for shared secret derivation.
#[corresponds(EVP_PKEY_derive_init)]
#[inline]
pub fn derive_init(&mut self) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_derive_init(self.as_ptr()))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: keygen_init,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in keygen_init:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 415, End Line: 421
/// Prepares the context for key generation.
#[corresponds(EVP_PKEY_keygen_init)]
#[inline]
pub fn keygen_init(&mut self) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_keygen_init(self.as_ptr()))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_signature_md,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in set_signature_md:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 429, End Line: 437
/// Sets which algorithm was used to compute the digest used in a
/// signature. With RSA signatures this causes the signature to be wrapped
/// in a `DigestInfo` structure. This is almost always what you want with
/// RSA signatures.
#[corresponds(EVP_PKEY_CTX_set_signature_md)]
#[inline]
pub fn set_signature_md(&self, md: &MdRef) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_CTX_set_signature_md(self.as_ptr(), md.as_ptr()))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: rsa_padding,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in rsa_padding:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 444, End Line: 451
/// Returns the RSA padding mode in use.
///
/// This is only useful for RSA keys.
#[corresponds(EVP_PKEY_CTX_get_rsa_padding)]
#[inline]
pub fn rsa_padding(&self) -> Result<Padding, ErrorStack> {
    let mut pad = 0;
    unsafe {
        cvt(ffi::EVP_PKEY_CTX_get_rsa_padding(self.as_ptr(), &mut pad))?;
    }
    Ok(Padding::from_raw(pad))
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_rsa_padding,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in set_rsa_padding:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 458, End Line: 467
/// Sets the RSA padding mode.
///
/// This is only useful for RSA keys.
#[corresponds(EVP_PKEY_CTX_set_rsa_padding)]
#[inline]
pub fn set_rsa_padding(&mut self, padding: Padding) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_CTX_set_rsa_padding(self.as_ptr(), padding.as_raw()))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_rsa_pss_saltlen,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in set_rsa_pss_saltlen:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 474, End Line: 482
/// Sets the RSA PSS salt length.
///
/// This is only useful for RSA keys.
#[corresponds(EVP_PKEY_CTX_set_rsa_pss_saltlen)]
#[inline]
pub fn set_rsa_pss_saltlen(&mut self, len: RsaPssSaltlen) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_CTX_set_rsa_pss_saltlen(self.as_ptr(), len.as_raw()))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_rsa_mgf1_md,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in set_rsa_mgf1_md:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 489, End Line: 498
/// Sets the RSA MGF1 algorithm.
///
/// This is only useful for RSA keys.
#[corresponds(EVP_PKEY_CTX_set_rsa_mgf1_md)]
#[inline]
pub fn set_rsa_mgf1_md(&mut self, md: &MdRef) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_CTX_set_rsa_mgf1_md(self.as_ptr(), md.as_ptr()))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_rsa_oaep_md,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in set_rsa_oaep_md:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 506, End Line: 515
/// Sets the RSA OAEP algorithm.
///
/// This is only useful for RSA keys.
#[corresponds(EVP_PKEY_CTX_set_rsa_oaep_md)]
#[cfg(any(ossl102, libressl310, boringssl))]
#[inline]
pub fn set_rsa_oaep_md(&mut self, md: &MdRef) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_CTX_set_rsa_oaep_md(self.as_ptr(), md.as_ptr() as *mut _))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: true, With_SAFETY_comment: false, Name: set_rsa_oaep_label,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in set_rsa_oaep_label:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 522, End Line: 542
/// Sets the RSA OAEP label.
///
/// This is only useful for RSA keys.
#[corresponds(EVP_PKEY_CTX_set0_rsa_oaep_label)]
#[cfg(any(ossl102, libressl310, boringssl))]
pub fn set_rsa_oaep_label(&mut self, label: &[u8]) -> Result<(), ErrorStack> {
    use crate::LenType;
    let len = LenType::try_from(label.len()).unwrap();
    unsafe {
        let p = ffi::OPENSSL_malloc(label.len() as _);
        ptr::copy_nonoverlapping(label.as_ptr(), p as *mut _, label.len());
        let r = cvt(
            ffi::EVP_PKEY_CTX_set0_rsa_oaep_label(self.as_ptr(), p as *mut _, len),
        );
        if r.is_err() {
            ffi::OPENSSL_free(p);
        }
        r?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_keygen_cipher,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in set_keygen_cipher:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 548, End Line: 561
/// Sets the cipher used during key generation.
#[cfg(not(boringssl))]
#[corresponds(EVP_PKEY_CTX_ctrl)]
#[inline]
pub fn set_keygen_cipher(&mut self, cipher: &CipherRef) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
            ffi::EVP_PKEY_CTX_ctrl(
                self.as_ptr(),
                -1,
                ffi::EVP_PKEY_OP_KEYGEN,
                ffi::EVP_PKEY_CTRL_CIPHER,
                0,
                cipher.as_ptr() as *mut _,
            ),
        )?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_keygen_mac_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in set_keygen_mac_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 567, End Line: 582
/// Sets the key MAC key used during key generation.
#[cfg(not(boringssl))]
#[corresponds(EVP_PKEY_CTX_ctrl)]
#[inline]
pub fn set_keygen_mac_key(&mut self, key: &[u8]) -> Result<(), ErrorStack> {
    let len = c_int::try_from(key.len()).unwrap();
    unsafe {
        cvt(
            ffi::EVP_PKEY_CTX_ctrl(
                self.as_ptr(),
                -1,
                ffi::EVP_PKEY_OP_KEYGEN,
                ffi::EVP_PKEY_CTRL_SET_MAC_KEY,
                len,
                key.as_ptr() as *mut _,
            ),
        )?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_hkdf_md,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in set_hkdf_md:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 590, End Line: 599
/// Sets the digest used for HKDF derivation.
///
/// Requires OpenSSL 1.1.0 or newer.
#[corresponds(EVP_PKEY_CTX_set_hkdf_md)]
#[cfg(any(ossl110, boringssl, libressl360))]
#[inline]
pub fn set_hkdf_md(&mut self, digest: &MdRef) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_CTX_set_hkdf_md(self.as_ptr(), digest.as_ptr()))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_hkdf_mode,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in set_hkdf_mode:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 613, End Line: 619
/// Sets the HKDF mode of operation.
///
/// Defaults to [`HkdfMode::EXTRACT_THEN_EXPAND`].
///
/// WARNING: Although this API calls it a "mode", HKDF-Extract and HKDF-Expand are distinct
/// operations with distinct inputs and distinct kinds of keys. Callers should not pass input
/// secrets for one operation into the other.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(EVP_PKEY_CTX_set_hkdf_mode)]
#[cfg(any(ossl111, libressl360))]
#[inline]
pub fn set_hkdf_mode(&mut self, mode: HkdfMode) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_CTX_set_hkdf_mode(self.as_ptr(), mode.0))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_hkdf_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in set_hkdf_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 632, End Line: 647
/// Sets the input material for HKDF generation as the "key".
///
/// Which input is the key depends on the "mode" (see [`set_hkdf_mode`][Self::set_hkdf_mode]).
/// If [`HkdfMode::EXTRACT_THEN_EXPAND`] or [`HkdfMode::EXTRACT_ONLY`], this function specifies
/// the input keying material (IKM) for HKDF-Extract. If [`HkdfMode::EXPAND_ONLY`], it instead
/// specifies the pseudorandom key (PRK) for HKDF-Expand.
///
/// Requires OpenSSL 1.1.0 or newer.
#[corresponds(EVP_PKEY_CTX_set1_hkdf_key)]
#[cfg(any(ossl110, boringssl, libressl360))]
#[inline]
pub fn set_hkdf_key(&mut self, key: &[u8]) -> Result<(), ErrorStack> {
    #[cfg(not(boringssl))]
    let len = c_int::try_from(key.len()).unwrap();
    #[cfg(boringssl)]
    let len = key.len();
    unsafe {
        cvt(ffi::EVP_PKEY_CTX_set1_hkdf_key(self.as_ptr(), key.as_ptr(), len))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_hkdf_salt,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in set_hkdf_salt:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 657, End Line: 672
/// Sets the salt value for HKDF generation.
///
/// If performing HKDF-Expand only, this parameter is ignored.
///
/// Requires OpenSSL 1.1.0 or newer.
#[corresponds(EVP_PKEY_CTX_set1_hkdf_salt)]
#[cfg(any(ossl110, boringssl, libressl360))]
#[inline]
pub fn set_hkdf_salt(&mut self, salt: &[u8]) -> Result<(), ErrorStack> {
    #[cfg(not(boringssl))]
    let len = c_int::try_from(salt.len()).unwrap();
    #[cfg(boringssl)]
    let len = salt.len();
    unsafe {
        cvt(ffi::EVP_PKEY_CTX_set1_hkdf_salt(self.as_ptr(), salt.as_ptr(), len))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: add_hkdf_info,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in add_hkdf_info:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 682, End Line: 697
/// Appends info bytes for HKDF generation.
///
/// If performing HKDF-Extract only, this parameter is ignored.
///
/// Requires OpenSSL 1.1.0 or newer.
#[corresponds(EVP_PKEY_CTX_add1_hkdf_info)]
#[cfg(any(ossl110, boringssl, libressl360))]
#[inline]
pub fn add_hkdf_info(&mut self, info: &[u8]) -> Result<(), ErrorStack> {
    #[cfg(not(boringssl))]
    let len = c_int::try_from(info.len()).unwrap();
    #[cfg(boringssl)]
    let len = info.len();
    unsafe {
        cvt(ffi::EVP_PKEY_CTX_add1_hkdf_info(self.as_ptr(), info.as_ptr(), len))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: derive,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in derive:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 703, End Line: 714
/// Derives a shared secret between two keys.
///
/// If `buf` is set to `None`, an upper bound on the number of bytes required for the buffer will be returned.
#[corresponds(EVP_PKEY_derive)]
pub fn derive(&mut self, buf: Option<&mut [u8]>) -> Result<usize, ErrorStack> {
    let mut len = buf.as_ref().map_or(0, |b| b.len());
    unsafe {
        cvt(
            ffi::EVP_PKEY_derive(
                self.as_ptr(),
                buf.map_or(ptr::null_mut(), |b| b.as_mut_ptr()),
                &mut len,
            ),
        )?;
    }
    Ok(len)
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: keygen,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in keygen:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 729, End Line: 735
/// Generates a new public/private keypair.
#[corresponds(EVP_PKEY_keygen)]
#[inline]
pub fn keygen(&mut self) -> Result<PKey<Private>, ErrorStack> {
    unsafe {
        let mut key = ptr::null_mut();
        cvt(ffi::EVP_PKEY_keygen(self.as_ptr(), &mut key))?;
        Ok(PKey::from_ptr(key))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: set_nonce_type,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in set_nonce_type:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 745, End Line: 757
/// Sets the nonce type for a private key context.
///
/// The nonce for DSA and ECDSA can be either random (the default) or deterministic (as defined by RFC 6979).
///
/// This is only useful for DSA and ECDSA.
/// Requires OpenSSL 3.2.0 or newer.
#[cfg(ossl320)]
#[corresponds(EVP_PKEY_CTX_set_params)]
pub fn set_nonce_type(&mut self, nonce_type: NonceType) -> Result<(), ErrorStack> {
    let nonce_field_name = CStr::from_bytes_with_nul(b"nonce-type\0").unwrap();
    let mut nonce_type = nonce_type.0;
    unsafe {
        let param_nonce = ffi::OSSL_PARAM_construct_uint(
            nonce_field_name.as_ptr(),
            &mut nonce_type,
        );
        let param_end = ffi::OSSL_PARAM_construct_end();
        let params = [param_nonce, param_end];
        cvt(ffi::EVP_PKEY_CTX_set_params(self.as_ptr(), params.as_ptr()))?;
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: nonce_type,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs

Found method with unsafe block in nonce_type:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\pkey_ctx.rs
Start Line: 767, End Line: 782
/// Gets the nonce type for a private key context.
///
/// The nonce for DSA and ECDSA can be either random (the default) or deterministic (as defined by RFC 6979).
///
/// This is only useful for DSA and ECDSA.
/// Requires OpenSSL 3.2.0 or newer.
#[cfg(ossl320)]
#[corresponds(EVP_PKEY_CTX_get_params)]
pub fn nonce_type(&mut self) -> Result<NonceType, ErrorStack> {
    let nonce_field_name = CStr::from_bytes_with_nul(b"nonce-type\0").unwrap();
    let mut nonce_type: c_uint = 0;
    unsafe {
        let param_nonce = ffi::OSSL_PARAM_construct_uint(
            nonce_field_name.as_ptr(),
            &mut nonce_type,
        );
        let param_end = ffi::OSSL_PARAM_construct_end();
        let mut params = [param_nonce, param_end];
        cvt(ffi::EVP_PKEY_CTX_get_params(self.as_ptr(), params.as_mut_ptr()))?;
    }
    Ok(NonceType(nonce_type))
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\provider.rs
-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: load,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\provider.rs

Found method with unsafe block in load:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\provider.rs
Start Line: 28, End Line: 38
/// Loads a new provider into the specified library context, disabling the fallback providers.
///
/// If `ctx` is `None`, the provider will be loaded in to the default library context.
#[corresponds(OSSL_provider_load)]
pub fn load(ctx: Option<&LibCtxRef>, name: &str) -> Result<Self, ErrorStack> {
    let name = CString::new(name).unwrap();
    unsafe {
        let p = cvt_p(
            ffi::OSSL_PROVIDER_load(
                ctx.map_or(ptr::null_mut(), ForeignTypeRef::as_ptr),
                name.as_ptr(),
            ),
        )?;
        Ok(Provider::from_ptr(p))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: try_load,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\provider.rs

Found method with unsafe block in try_load:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\provider.rs
Start Line: 45, End Line: 64
/// Loads a new provider into the specified library context, disabling the fallback providers if `retain_fallbacks`
/// is `false` and the load succeeds.
///
/// If `ctx` is `None`, the provider will be loaded into the default library context.
#[corresponds(OSSL_provider_try_load)]
pub fn try_load(
    ctx: Option<&LibCtxRef>,
    name: &str,
    retain_fallbacks: bool,
) -> Result<Self, ErrorStack> {
    let name = CString::new(name).unwrap();
    unsafe {
        let p = cvt_p(
            ffi::OSSL_PROVIDER_try_load(
                ctx.map_or(ptr::null_mut(), ForeignTypeRef::as_ptr),
                name.as_ptr(),
                retain_fallbacks as _,
            ),
        )?;
        let _ = ErrorStack::get();
        Ok(Provider::from_ptr(p))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_default_search_path,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\provider.rs

Found method with unsafe block in set_default_search_path:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\provider.rs
Start Line: 71, End Line: 80
/// Specifies the default search path that is to be used for looking for providers in the specified library context.
/// If left unspecified, an environment variable and a fall back default value will be used instead
///
/// If `ctx` is `None`, the provider will be loaded into the default library context.
#[corresponds(OSSL_PROVIDER_set_default_search_path)]
pub fn set_default_search_path(
    ctx: Option<&LibCtxRef>,
    path: &str,
) -> Result<(), ErrorStack> {
    let path = CString::new(path).unwrap();
    unsafe {
        cvt(
                ffi::OSSL_PROVIDER_set_default_search_path(
                    ctx.map_or(ptr::null_mut(), ForeignTypeRef::as_ptr),
                    path.as_ptr(),
                ),
            )
            .map(|_| ())
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rand.rs
-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: rand_bytes,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rand.rs

Found function with unsafe block in rand_bytes:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rand.rs
Start Line: 32, End Line: 38
/// Fill buffer with cryptographically strong pseudo-random bytes.
///
/// # Examples
///
/// To generate a buffer with cryptographically strong random bytes:
///
/// ```
/// use openssl::rand::rand_bytes;
///
/// let mut buf = [0; 256];
/// rand_bytes(&mut buf).unwrap();
/// ```
#[corresponds(RAND_bytes)]
pub fn rand_bytes(buf: &mut [u8]) -> Result<(), ErrorStack> {
    unsafe {
        ffi::init();
        assert!(buf.len() <= c_int::MAX as usize);
        cvt(ffi::RAND_bytes(buf.as_mut_ptr(), buf.len() as LenType)).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: rand_priv_bytes,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rand.rs

Found function with unsafe block in rand_priv_bytes:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rand.rs
Start Line: 57, End Line: 63
/// Fill buffer with cryptographically strong pseudo-random bytes. It is
/// intended to be used for generating values that should remain private.
///
/// # Examples
///
/// To generate a buffer with cryptographically strong random bytes:
///
/// ```
/// use openssl::rand::rand_priv_bytes;
///
/// let mut buf = [0; 256];
/// rand_priv_bytes(&mut buf).unwrap();
/// ```
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(RAND_priv_bytes)]
#[cfg(ossl111)]
pub fn rand_priv_bytes(buf: &mut [u8]) -> Result<(), ErrorStack> {
    unsafe {
        ffi::init();
        assert!(buf.len() <= c_int::MAX as usize);
        cvt(ffi::RAND_priv_bytes(buf.as_mut_ptr(), buf.len() as LenType)).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: keep_random_devices_open,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rand.rs

Found function with unsafe block in keep_random_devices_open:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rand.rs
Start Line: 70, End Line: 74
/// Controls random device file descriptor behavior.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(RAND_keep_random_devices_open)]
#[cfg(ossl111)]
pub fn keep_random_devices_open(keep: bool) {
    unsafe {
        ffi::RAND_keep_random_devices_open(keep as LenType);
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: to_owned,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in to_owned:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 86, End Line: 91
fn to_owned(&self) -> Rsa<T> {
    unsafe {
        ffi::RSA_up_ref(self.as_ptr());
        Rsa::from_ptr(self.as_ptr())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: private_decrypt,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in private_decrypt:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 126, End Line: 145
/// Decrypts data using the private key, returning the number of decrypted bytes.
///
/// # Panics
///
/// Panics if `self` has no private components, or if `to` is smaller
/// than `self.size()`.
#[corresponds(RSA_private_decrypt)]
pub fn private_decrypt(
    &self,
    from: &[u8],
    to: &mut [u8],
    padding: Padding,
) -> Result<usize, ErrorStack> {
    assert!(from.len() <= i32::MAX as usize);
    assert!(to.len() >= self.size() as usize);
    unsafe {
        let len = cvt_n(
            ffi::RSA_private_decrypt(
                from.len() as LenType,
                from.as_ptr(),
                to.as_mut_ptr(),
                self.as_ptr(),
                padding.0,
            ),
        )?;
        Ok(len as usize)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: private_encrypt,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in private_encrypt:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 154, End Line: 173
/// Encrypts data using the private key, returning the number of encrypted bytes.
///
/// # Panics
///
/// Panics if `self` has no private components, or if `to` is smaller
/// than `self.size()`.
#[corresponds(RSA_private_encrypt)]
pub fn private_encrypt(
    &self,
    from: &[u8],
    to: &mut [u8],
    padding: Padding,
) -> Result<usize, ErrorStack> {
    assert!(from.len() <= i32::MAX as usize);
    assert!(to.len() >= self.size() as usize);
    unsafe {
        let len = cvt_n(
            ffi::RSA_private_encrypt(
                from.len() as LenType,
                from.as_ptr(),
                to.as_mut_ptr(),
                self.as_ptr(),
                padding.0,
            ),
        )?;
        Ok(len as usize)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: d,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in d:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 177, End Line: 183
/// Returns a reference to the private exponent of the key.
#[corresponds(RSA_get0_key)]
pub fn d(&self) -> &BigNumRef {
    unsafe {
        let mut d = ptr::null();
        RSA_get0_key(self.as_ptr(), ptr::null_mut(), ptr::null_mut(), &mut d);
        BigNumRef::from_const_ptr(d)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: p,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in p:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 187, End Line: 193
/// Returns a reference to the first factor of the exponent of the key.
#[corresponds(RSA_get0_factors)]
pub fn p(&self) -> Option<&BigNumRef> {
    unsafe {
        let mut p = ptr::null();
        RSA_get0_factors(self.as_ptr(), &mut p, ptr::null_mut());
        BigNumRef::from_const_ptr_opt(p)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: q,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in q:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 197, End Line: 203
/// Returns a reference to the second factor of the exponent of the key.
#[corresponds(RSA_get0_factors)]
pub fn q(&self) -> Option<&BigNumRef> {
    unsafe {
        let mut q = ptr::null();
        RSA_get0_factors(self.as_ptr(), ptr::null_mut(), &mut q);
        BigNumRef::from_const_ptr_opt(q)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: dmp1,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in dmp1:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 207, End Line: 213
/// Returns a reference to the first exponent used for CRT calculations.
#[corresponds(RSA_get0_crt_params)]
pub fn dmp1(&self) -> Option<&BigNumRef> {
    unsafe {
        let mut dp = ptr::null();
        RSA_get0_crt_params(self.as_ptr(), &mut dp, ptr::null_mut(), ptr::null_mut());
        BigNumRef::from_const_ptr_opt(dp)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: dmq1,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in dmq1:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 217, End Line: 223
/// Returns a reference to the second exponent used for CRT calculations.
#[corresponds(RSA_get0_crt_params)]
pub fn dmq1(&self) -> Option<&BigNumRef> {
    unsafe {
        let mut dq = ptr::null();
        RSA_get0_crt_params(self.as_ptr(), ptr::null_mut(), &mut dq, ptr::null_mut());
        BigNumRef::from_const_ptr_opt(dq)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: iqmp,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in iqmp:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 227, End Line: 233
/// Returns a reference to the coefficient used for CRT calculations.
#[corresponds(RSA_get0_crt_params)]
pub fn iqmp(&self) -> Option<&BigNumRef> {
    unsafe {
        let mut qi = ptr::null();
        RSA_get0_crt_params(self.as_ptr(), ptr::null_mut(), ptr::null_mut(), &mut qi);
        BigNumRef::from_const_ptr_opt(qi)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: check_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in check_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 238, End Line: 247
/// Validates RSA parameters for correctness
#[corresponds(RSA_check_key)]
#[allow(clippy::unnecessary_cast)]
pub fn check_key(&self) -> Result<bool, ErrorStack> {
    unsafe {
        let result = ffi::RSA_check_key(self.as_ptr()) as i32;
        if result == -1 { Err(ErrorStack::get()) } else { Ok(result == 1) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: size,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in size:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 288, End Line: 290
/// Returns the size of the modulus in bytes.
#[corresponds(RSA_size)]
pub fn size(&self) -> u32 {
    unsafe { ffi::RSA_size(self.as_ptr()) as u32 }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: public_decrypt,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in public_decrypt:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 298, End Line: 317
/// Decrypts data using the public key, returning the number of decrypted bytes.
///
/// # Panics
///
/// Panics if `to` is smaller than `self.size()`.
#[corresponds(RSA_public_decrypt)]
pub fn public_decrypt(
    &self,
    from: &[u8],
    to: &mut [u8],
    padding: Padding,
) -> Result<usize, ErrorStack> {
    assert!(from.len() <= i32::MAX as usize);
    assert!(to.len() >= self.size() as usize);
    unsafe {
        let len = cvt_n(
            ffi::RSA_public_decrypt(
                from.len() as LenType,
                from.as_ptr(),
                to.as_mut_ptr(),
                self.as_ptr(),
                padding.0,
            ),
        )?;
        Ok(len as usize)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: public_encrypt,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in public_encrypt:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 325, End Line: 344
/// Encrypts data using the public key, returning the number of encrypted bytes.
///
/// # Panics
///
/// Panics if `to` is smaller than `self.size()`.
#[corresponds(RSA_public_encrypt)]
pub fn public_encrypt(
    &self,
    from: &[u8],
    to: &mut [u8],
    padding: Padding,
) -> Result<usize, ErrorStack> {
    assert!(from.len() <= i32::MAX as usize);
    assert!(to.len() >= self.size() as usize);
    unsafe {
        let len = cvt_n(
            ffi::RSA_public_encrypt(
                from.len() as LenType,
                from.as_ptr(),
                to.as_mut_ptr(),
                self.as_ptr(),
                padding.0,
            ),
        )?;
        Ok(len as usize)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: n,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in n:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 348, End Line: 354
/// Returns a reference to the modulus of the key.
#[corresponds(RSA_get0_key)]
pub fn n(&self) -> &BigNumRef {
    unsafe {
        let mut n = ptr::null();
        RSA_get0_key(self.as_ptr(), &mut n, ptr::null_mut(), ptr::null_mut());
        BigNumRef::from_const_ptr(n)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: e,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in e:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 358, End Line: 364
/// Returns a reference to the public exponent of the key.
#[corresponds(RSA_get0_key)]
pub fn e(&self) -> &BigNumRef {
    unsafe {
        let mut e = ptr::null();
        RSA_get0_key(self.as_ptr(), ptr::null_mut(), &mut e, ptr::null_mut());
        BigNumRef::from_const_ptr(e)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: from_public_components,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in from_public_components:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 377, End Line: 384
/// Creates a new RSA key with only public components.
///
/// `n` is the modulus common to both public and private key.
/// `e` is the public exponent.
///
/// This corresponds to [`RSA_new`] and uses [`RSA_set0_key`].
///
/// [`RSA_new`]: https://www.openssl.org/docs/manmaster/crypto/RSA_new.html
/// [`RSA_set0_key`]: https://www.openssl.org/docs/manmaster/crypto/RSA_set0_key.html
pub fn from_public_components(n: BigNum, e: BigNum) -> Result<Rsa<Public>, ErrorStack> {
    unsafe {
        let rsa = cvt_p(ffi::RSA_new())?;
        RSA_set0_key(rsa, n.as_ptr(), e.as_ptr(), ptr::null_mut());
        mem::forget((n, e));
        Ok(Rsa::from_ptr(rsa))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 437, End Line: 446
/// Creates a new `RsaPrivateKeyBuilder`.
///
/// `n` is the modulus common to both public and private key.
/// `e` is the public exponent and `d` is the private exponent.
///
/// This corresponds to [`RSA_new`] and uses [`RSA_set0_key`].
///
/// [`RSA_new`]: https://www.openssl.org/docs/manmaster/crypto/RSA_new.html
/// [`RSA_set0_key`]: https://www.openssl.org/docs/manmaster/crypto/RSA_set0_key.html
pub fn new(n: BigNum, e: BigNum, d: BigNum) -> Result<RsaPrivateKeyBuilder, ErrorStack> {
    unsafe {
        let rsa = cvt_p(ffi::RSA_new())?;
        RSA_set0_key(rsa, n.as_ptr(), e.as_ptr(), d.as_ptr());
        mem::forget((n, e, d));
        Ok(RsaPrivateKeyBuilder {
            rsa: Rsa::from_ptr(rsa),
        })
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_factors,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in set_factors:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 453, End Line: 459
/// Sets the factors of the Rsa key.
///
/// `p` and `q` are the first and second factors of `n`.
#[corresponds(RSA_set0_factors)]
pub fn set_factors(
    self,
    p: BigNum,
    q: BigNum,
) -> Result<RsaPrivateKeyBuilder, ErrorStack> {
    unsafe {
        RSA_set0_factors(self.rsa.as_ptr(), p.as_ptr(), q.as_ptr());
        mem::forget((p, q));
    }
    Ok(self)
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_crt_params,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in set_crt_params:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 467, End Line: 483
/// Sets the Chinese Remainder Theorem params of the Rsa key.
///
/// `dmp1`, `dmq1`, and `iqmp` are the exponents and coefficient for
/// CRT calculations which is used to speed up RSA operations.
#[corresponds(RSA_set0_crt_params)]
pub fn set_crt_params(
    self,
    dmp1: BigNum,
    dmq1: BigNum,
    iqmp: BigNum,
) -> Result<RsaPrivateKeyBuilder, ErrorStack> {
    unsafe {
        RSA_set0_crt_params(
            self.rsa.as_ptr(),
            dmp1.as_ptr(),
            dmq1.as_ptr(),
            iqmp.as_ptr(),
        );
        mem::forget((dmp1, dmq1, iqmp));
    }
    Ok(self)
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: generate_with_e,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs

Found method with unsafe block in generate_with_e:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\rsa.rs
Start Line: 536, End Line: 547
/// Generates a public/private key pair with the specified size and a custom exponent.
///
/// Unless you have specific needs and know what you're doing, use `Rsa::generate` instead.
#[corresponds(RSA_generate_key_ex)]
pub fn generate_with_e(bits: u32, e: &BigNumRef) -> Result<Rsa<Private>, ErrorStack> {
    unsafe {
        let rsa = Rsa::from_ptr(cvt_p(ffi::RSA_new())?);
        cvt(
            ffi::RSA_generate_key_ex(rsa.0, bits as c_int, e.as_ptr(), ptr::null_mut()),
        )?;
        Ok(rsa)
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sha.rs
-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: sha1,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sha.rs

Found function with unsafe block in sha1:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sha.rs
Start Line: 51, End Line: 57
/// Computes the SHA1 hash of some data.
///
/// # Warning
///
/// SHA1 is known to be insecure - it should not be used unless required for
/// compatibility with existing systems.
#[corresponds(SHA1)]
#[inline]
pub fn sha1(data: &[u8]) -> [u8; 20] {
    unsafe {
        let mut hash = MaybeUninit::<[u8; 20]>::uninit();
        ffi::SHA1(data.as_ptr(), data.len(), hash.as_mut_ptr() as *mut _);
        hash.assume_init()
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: sha224,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sha.rs

Found function with unsafe block in sha224:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sha.rs
Start Line: 62, End Line: 68
/// Computes the SHA224 hash of some data.
#[corresponds(SHA224)]
#[inline]
pub fn sha224(data: &[u8]) -> [u8; 28] {
    unsafe {
        let mut hash = MaybeUninit::<[u8; 28]>::uninit();
        ffi::SHA224(data.as_ptr(), data.len(), hash.as_mut_ptr() as *mut _);
        hash.assume_init()
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: sha256,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sha.rs

Found function with unsafe block in sha256:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sha.rs
Start Line: 73, End Line: 79
/// Computes the SHA256 hash of some data.
#[corresponds(SHA256)]
#[inline]
pub fn sha256(data: &[u8]) -> [u8; 32] {
    unsafe {
        let mut hash = MaybeUninit::<[u8; 32]>::uninit();
        ffi::SHA256(data.as_ptr(), data.len(), hash.as_mut_ptr() as *mut _);
        hash.assume_init()
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: sha384,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sha.rs

Found function with unsafe block in sha384:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sha.rs
Start Line: 84, End Line: 90
/// Computes the SHA384 hash of some data.
#[corresponds(SHA384)]
#[inline]
pub fn sha384(data: &[u8]) -> [u8; 48] {
    unsafe {
        let mut hash = MaybeUninit::<[u8; 48]>::uninit();
        ffi::SHA384(data.as_ptr(), data.len(), hash.as_mut_ptr() as *mut _);
        hash.assume_init()
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: sha512,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sha.rs

Found function with unsafe block in sha512:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sha.rs
Start Line: 95, End Line: 101
/// Computes the SHA512 hash of some data.
#[corresponds(SHA512)]
#[inline]
pub fn sha512(data: &[u8]) -> [u8; 64] {
    unsafe {
        let mut hash = MaybeUninit::<[u8; 64]>::uninit();
        ffi::SHA512(data.as_ptr(), data.len(), hash.as_mut_ptr() as *mut _);
        hash.assume_init()
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: drop,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs

Found method with unsafe block in drop:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs
Start Line: 124, End Line: 129
fn drop(&mut self) {
    unsafe {
        EVP_MD_CTX_free(self.md_ctx);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 7 statements, Complex: true, With_SAFETY_comment: false, Name: new_intern,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs

Found method with unsafe block in new_intern:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs
Start Line: 164, End Line: 196
fn new_intern<'a, T>(
    type_: Option<MessageDigest>,
    pkey: &PKeyRef<T>,
) -> Result<Signer<'a>, ErrorStack>
where
    T: HasPrivate,
{
    unsafe {
        ffi::init();
        let ctx = cvt_p(EVP_MD_CTX_new())?;
        let mut pctx: *mut ffi::EVP_PKEY_CTX = ptr::null_mut();
        let r = ffi::EVP_DigestSignInit(
            ctx,
            &mut pctx,
            type_.map(|t| t.as_ptr()).unwrap_or(ptr::null()),
            ptr::null_mut(),
            pkey.as_ptr(),
        );
        if r != 1 {
            EVP_MD_CTX_free(ctx);
            return Err(ErrorStack::get());
        }
        assert!(! pctx.is_null());
        Ok(Signer {
            md_ctx: ctx,
            pctx,
            _p: PhantomData,
        })
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: rsa_padding,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs

Found method with unsafe block in rsa_padding:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs
Start Line: 203, End Line: 209
/// Returns the RSA padding mode in use.
///
/// This is only useful for RSA keys.
///
/// This corresponds to `EVP_PKEY_CTX_get_rsa_padding`.
pub fn rsa_padding(&self) -> Result<Padding, ErrorStack> {
    unsafe {
        let mut pad = 0;
        cvt(ffi::EVP_PKEY_CTX_get_rsa_padding(self.pctx, &mut pad))
            .map(|_| Padding::from_raw(pad))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_rsa_padding,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs

Found method with unsafe block in set_rsa_padding:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs
Start Line: 218, End Line: 226
/// Sets the RSA padding mode.
///
/// This is only useful for RSA keys.
///
/// This corresponds to [`EVP_PKEY_CTX_set_rsa_padding`].
///
/// [`EVP_PKEY_CTX_set_rsa_padding`]: https://www.openssl.org/docs/manmaster/crypto/EVP_PKEY_CTX_set_rsa_padding.html
pub fn set_rsa_padding(&mut self, padding: Padding) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_CTX_set_rsa_padding(self.pctx, padding.as_raw())).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_rsa_pss_saltlen,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs

Found method with unsafe block in set_rsa_pss_saltlen:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs
Start Line: 235, End Line: 243
/// Sets the RSA PSS salt length.
///
/// This is only useful for RSA keys.
///
/// This corresponds to [`EVP_PKEY_CTX_set_rsa_pss_saltlen`].
///
/// [`EVP_PKEY_CTX_set_rsa_pss_saltlen`]: https://www.openssl.org/docs/manmaster/crypto/EVP_PKEY_CTX_set_rsa_pss_saltlen.html
pub fn set_rsa_pss_saltlen(&mut self, len: RsaPssSaltlen) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_CTX_set_rsa_pss_saltlen(self.pctx, len.as_raw())).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_rsa_mgf1_md,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs

Found method with unsafe block in set_rsa_mgf1_md:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs
Start Line: 252, End Line: 260
/// Sets the RSA MGF1 algorithm.
///
/// This is only useful for RSA keys.
///
/// This corresponds to [`EVP_PKEY_CTX_set_rsa_mgf1_md`].
///
/// [`EVP_PKEY_CTX_set_rsa_mgf1_md`]: https://www.openssl.org/docs/manmaster/man7/RSA-PSS.html
pub fn set_rsa_mgf1_md(&mut self, md: MessageDigest) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_PKEY_CTX_set_rsa_mgf1_md(self.pctx, md.as_ptr() as *mut _))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: update,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs

Found method with unsafe block in update:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs
Start Line: 270, End Line: 279
/// Feeds more data into the `Signer`.
///
/// Please note that PureEdDSA (Ed25519 and Ed448 keys) do not support streaming.
/// Use `sign_oneshot` instead.
///
/// OpenSSL documentation at [`EVP_DigestUpdate`].
///
/// [`EVP_DigestUpdate`]: https://www.openssl.org/docs/manmaster/man3/EVP_DigestInit.html
pub fn update(&mut self, buf: &[u8]) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::EVP_DigestUpdate(self.md_ctx, buf.as_ptr() as *const _, buf.len()))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: len_intern,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs

Found method with unsafe block in len_intern:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs
Start Line: 294, End Line: 304
#[cfg(all(not(ossl111), not(boringssl), not(libressl370)))]
fn len_intern(&self) -> Result<usize, ErrorStack> {
    unsafe {
        let mut len = 0;
        cvt(ffi::EVP_DigestSignFinal(self.md_ctx, ptr::null_mut(), &mut len))?;
        Ok(len)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: sign,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs

Found method with unsafe block in sign:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs
Start Line: 329, End Line: 339
/// Writes the signature into the provided buffer, returning the number of bytes written.
///
/// This method will fail if the buffer is not large enough for the signature. Use the `len`
/// method to get an upper bound on the required size.
///
/// OpenSSL documentation at [`EVP_DigestSignFinal`].
///
/// [`EVP_DigestSignFinal`]: https://www.openssl.org/docs/manmaster/crypto/EVP_DigestSignFinal.html
pub fn sign(&self, buf: &mut [u8]) -> Result<usize, ErrorStack> {
    unsafe {
        let mut len = buf.len();
        cvt(
            ffi::EVP_DigestSignFinal(self.md_ctx, buf.as_mut_ptr() as *mut _, &mut len),
        )?;
        Ok(len)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: sign_oneshot,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs

Found method with unsafe block in sign_oneshot:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs
Start Line: 364, End Line: 380
/// Signs the data in `data_buf` and writes the signature into the buffer `sig_buf`, returning the
/// number of bytes written.
///
/// For PureEdDSA (Ed25519 and Ed448 keys), this is the only way to sign data.
///
/// This method will fail if the buffer is not large enough for the signature. Use the `len`
/// method to get an upper bound on the required size.
///
/// OpenSSL documentation at [`EVP_DigestSign`].
///
/// [`EVP_DigestSign`]: https://www.openssl.org/docs/man1.1.1/man3/EVP_DigestSign.html
#[cfg(any(ossl111, boringssl, libressl370))]
pub fn sign_oneshot(
    &mut self,
    sig_buf: &mut [u8],
    data_buf: &[u8],
) -> Result<usize, ErrorStack> {
    unsafe {
        let mut sig_len = sig_buf.len();
        cvt(
            ffi::EVP_DigestSign(
                self.md_ctx,
                sig_buf.as_mut_ptr() as *mut _,
                &mut sig_len,
                data_buf.as_ptr() as *const _,
                data_buf.len(),
            ),
        )?;
        Ok(sig_len)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: verify,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs

Found method with unsafe block in verify:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs
Start Line: 579, End Line: 592
/// Determines if the data fed into the `Verifier` matches the provided signature.
///
/// OpenSSL documentation at [`EVP_DigestVerifyFinal`].
///
/// [`EVP_DigestVerifyFinal`]: https://www.openssl.org/docs/manmaster/man3/EVP_DigestVerifyFinal.html
pub fn verify(&self, signature: &[u8]) -> Result<bool, ErrorStack> {
    unsafe {
        let r = EVP_DigestVerifyFinal(
            self.md_ctx,
            signature.as_ptr() as *mut _,
            signature.len(),
        );
        match r {
            1 => Ok(true),
            0 => {
                ErrorStack::get();
                Ok(false)
            }
            _ => Err(ErrorStack::get()),
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: verify_oneshot,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs

Found method with unsafe block in verify_oneshot:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\sign.rs
Start Line: 600, End Line: 618
/// Determines if the data given in `buf` matches the provided signature.
///
/// OpenSSL documentation at [`EVP_DigestVerify`].
///
/// [`EVP_DigestVerify`]: https://www.openssl.org/docs/man1.1.1/man3/EVP_DigestVerify.html
#[cfg(any(ossl111, boringssl, libressl370))]
pub fn verify_oneshot(
    &mut self,
    signature: &[u8],
    buf: &[u8],
) -> Result<bool, ErrorStack> {
    unsafe {
        let r = ffi::EVP_DigestVerify(
            self.md_ctx,
            signature.as_ptr() as *const _,
            signature.len(),
            buf.as_ptr() as *const _,
            buf.len(),
        );
        match r {
            1 => Ok(true),
            0 => {
                ErrorStack::get();
                Ok(false)
            }
            _ => Err(ErrorStack::get()),
        }
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\srtp.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: id,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\srtp.rs

Found method with unsafe block in id:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\srtp.rs
Start Line: 24, End Line: 26
pub fn id(&self) -> SrtpProfileId {
    SrtpProfileId::from_raw(unsafe { (*self.as_ptr()).id })
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: name,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\srtp.rs

Found method with unsafe block in name:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\srtp.rs
Start Line: 27, End Line: 31
pub fn name(&self) -> &'static str {
    unsafe { CStr::from_ptr((*self.as_ptr()).name as *const _) }
        .to_str()
        .expect("should be UTF-8")
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\bio.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs
-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: raw_verify,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs

Found function with unsafe block in raw_verify:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs
Start Line: 37, End Line: 57
pub extern "C" fn raw_verify<F>(
    preverify_ok: c_int,
    x509_ctx: *mut ffi::X509_STORE_CTX,
) -> c_int
where
    F: Fn(bool, &mut X509StoreContextRef) -> bool + 'static + Sync + Send,
{
    unsafe {
        let ctx = X509StoreContextRef::from_ptr_mut(x509_ctx);
        let ssl_idx = X509StoreContext::ssl_idx()
            .expect("BUG: store context ssl index missing");
        let verify_idx = SslContext::cached_ex_index::<F>();
        let verify = ctx
            .ex_data(ssl_idx)
            .expect("BUG: store context missing ssl")
            .ssl_context()
            .ex_data(verify_idx)
            .expect("BUG: verify callback missing") as *const F;
        (*verify)(preverify_ok != 0, ctx) as c_int
    }
}



-----------------------------------------------------------------
Checking unsafe block with 7 statements, Complex: false, With_SAFETY_comment: false, Name: raw_client_psk,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs

Found function with unsafe block in raw_client_psk:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs
Start Line: 60, End Line: 99
#[cfg(not(osslconf = "OPENSSL_NO_PSK"))]
pub extern "C" fn raw_client_psk<F>(
    ssl: *mut ffi::SSL,
    hint: *const c_char,
    identity: *mut c_char,
    max_identity_len: c_uint,
    psk: *mut c_uchar,
    max_psk_len: c_uint,
) -> c_uint
where
    F: Fn(&mut SslRef, Option<&[u8]>, &mut [u8], &mut [u8]) -> Result<usize, ErrorStack>
        + 'static + Sync + Send,
{
    unsafe {
        let ssl = SslRef::from_ptr_mut(ssl);
        let callback_idx = SslContext::cached_ex_index::<F>();
        let callback = ssl
            .ssl_context()
            .ex_data(callback_idx)
            .expect("BUG: psk callback missing") as *const F;
        let hint = if !hint.is_null() {
            Some(CStr::from_ptr(hint).to_bytes())
        } else {
            None
        };
        let identity_sl = slice::from_raw_parts_mut(
            identity as *mut u8,
            max_identity_len as usize,
        );
        #[allow(clippy::unnecessary_cast)]
        let psk_sl = slice::from_raw_parts_mut(psk as *mut u8, max_psk_len as usize);
        match (*callback)(ssl, hint, identity_sl, psk_sl) {
            Ok(psk_len) => psk_len as u32,
            Err(e) => {
                e.put();
                0
            }
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 6 statements, Complex: false, With_SAFETY_comment: false, Name: raw_server_psk,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs

Found function with unsafe block in raw_server_psk:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs
Start Line: 102, End Line: 138
#[cfg(not(osslconf = "OPENSSL_NO_PSK"))]
pub extern "C" fn raw_server_psk<F>(
    ssl: *mut ffi::SSL,
    identity: *const c_char,
    psk: *mut c_uchar,
    max_psk_len: c_uint,
) -> c_uint
where
    F: Fn(&mut SslRef, Option<&[u8]>, &mut [u8]) -> Result<usize, ErrorStack> + 'static
        + Sync + Send,
{
    unsafe {
        let ssl = SslRef::from_ptr_mut(ssl);
        let callback_idx = SslContext::cached_ex_index::<F>();
        let callback = ssl
            .ssl_context()
            .ex_data(callback_idx)
            .expect("BUG: psk callback missing") as *const F;
        let identity = if identity.is_null() {
            None
        } else {
            Some(CStr::from_ptr(identity).to_bytes())
        };
        #[allow(clippy::unnecessary_cast)]
        let psk_sl = slice::from_raw_parts_mut(psk as *mut u8, max_psk_len as usize);
        match (*callback)(ssl, identity, psk_sl) {
            Ok(psk_len) => psk_len as u32,
            Err(e) => {
                e.put();
                0
            }
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: ssl_raw_verify,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs

Found function with unsafe block in ssl_raw_verify:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs
Start Line: 140, End Line: 161
pub extern "C" fn ssl_raw_verify<F>(
    preverify_ok: c_int,
    x509_ctx: *mut ffi::X509_STORE_CTX,
) -> c_int
where
    F: Fn(bool, &mut X509StoreContextRef) -> bool + 'static + Sync + Send,
{
    unsafe {
        let ctx = X509StoreContextRef::from_ptr_mut(x509_ctx);
        let ssl_idx = X509StoreContext::ssl_idx()
            .expect("BUG: store context ssl index missing");
        let callback_idx = Ssl::cached_ex_index::<Arc<F>>();
        let callback = ctx
            .ex_data(ssl_idx)
            .expect("BUG: store context missing ssl")
            .ex_data(callback_idx)
            .expect("BUG: ssl verify callback missing")
            .clone();
        callback(preverify_ok != 0, ctx) as c_int
    }
}



-----------------------------------------------------------------
Checking unsafe block with 6 statements, Complex: false, With_SAFETY_comment: false, Name: raw_sni,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs

Found function with unsafe block in raw_sni:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs
Start Line: 163, End Line: 179
pub extern "C" fn raw_sni<F>(
    ssl: *mut ffi::SSL,
    al: *mut c_int,
    arg: *mut c_void,
) -> c_int
where
    F: Fn(&mut SslRef, &mut SslAlert) -> Result<(), SniError> + 'static + Sync + Send,
{
    unsafe {
        let ssl = SslRef::from_ptr_mut(ssl);
        let callback = arg as *const F;
        let mut alert = SslAlert(*al);
        let r = (*callback)(ssl, &mut alert);
        *al = alert.0;
        match r {
            Ok(()) => ffi::SSL_TLSEXT_ERR_OK,
            Err(e) => e.0,
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: raw_alpn_select,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs

Found function with unsafe block in raw_alpn_select:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs
Start Line: 182, End Line: 211
#[cfg(any(ossl102, libressl261))]
pub extern "C" fn raw_alpn_select<F>(
    ssl: *mut ffi::SSL,
    out: *mut *const c_uchar,
    outlen: *mut c_uchar,
    inbuf: *const c_uchar,
    inlen: c_uint,
    _arg: *mut c_void,
) -> c_int
where
    F: for<'a> Fn(&mut SslRef, &'a [u8]) -> Result<&'a [u8], AlpnError> + 'static + Sync
        + Send,
{
    unsafe {
        let ssl = SslRef::from_ptr_mut(ssl);
        let callback = ssl
            .ssl_context()
            .ex_data(SslContext::cached_ex_index::<F>())
            .expect("BUG: alpn callback missing") as *const F;
        #[allow(clippy::unnecessary_cast)]
        let protos = slice::from_raw_parts(inbuf as *const u8, inlen as usize);
        match (*callback)(ssl, protos) {
            Ok(proto) => {
                *out = proto.as_ptr() as *const c_uchar;
                *outlen = proto.len() as c_uchar;
                ffi::SSL_TLSEXT_ERR_OK
            }
            Err(e) => e.0,
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: raw_cookie_generate,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs

Found function with unsafe block in raw_cookie_generate:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs
Start Line: 496, End Line: 526
#[cfg(not(boringssl))]
pub extern "C" fn raw_cookie_generate<F>(
    ssl: *mut ffi::SSL,
    cookie: *mut c_uchar,
    cookie_len: *mut c_uint,
) -> c_int
where
    F: Fn(&mut SslRef, &mut [u8]) -> Result<usize, ErrorStack> + 'static + Sync + Send,
{
    unsafe {
        let ssl = SslRef::from_ptr_mut(ssl);
        let callback = ssl
            .ssl_context()
            .ex_data(SslContext::cached_ex_index::<F>())
            .expect("BUG: cookie generate callback missing") as *const F;
        #[allow(clippy::unnecessary_cast)]
        let slice = slice::from_raw_parts_mut(
            cookie as *mut u8,
            ffi::DTLS1_COOKIE_LENGTH as usize - 1,
        );
        match (*callback)(ssl, slice) {
            Ok(len) => {
                *cookie_len = len as c_uint;
                1
            }
            Err(e) => {
                e.put();
                0
            }
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: raw_cookie_verify,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs

Found function with unsafe block in raw_cookie_verify:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs
Start Line: 538, End Line: 557
#[cfg(not(boringssl))]
pub extern "C" fn raw_cookie_verify<F>(
    ssl: *mut ffi::SSL,
    cookie: CookiePtr,
    cookie_len: c_uint,
) -> c_int
where
    F: Fn(&mut SslRef, &[u8]) -> bool + 'static + Sync + Send,
{
    unsafe {
        let ssl = SslRef::from_ptr_mut(ssl);
        let callback = ssl
            .ssl_context()
            .ex_data(SslContext::cached_ex_index::<F>())
            .expect("BUG: cookie verify callback missing") as *const F;
        #[allow(clippy::unnecessary_cast)]
        let slice = slice::from_raw_parts(
            cookie as *const c_uchar as *const u8,
            cookie_len as usize,
        );
        (*callback)(ssl, slice) as c_int
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: raw_custom_ext_add,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs

Found function with unsafe block in raw_custom_ext_add:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs
Start Line: 563, End Line: 619
#[cfg(ossl111)]
pub extern "C" fn raw_custom_ext_add<F, T>(
    ssl: *mut ffi::SSL,
    _: c_uint,
    context: c_uint,
    out: *mut *const c_uchar,
    outlen: *mut size_t,
    x: *mut ffi::X509,
    chainidx: size_t,
    al: *mut c_int,
    _: *mut c_void,
) -> c_int
where
    F: Fn(
            &mut SslRef,
            ExtensionContext,
            Option<(usize, &X509Ref)>,
        ) -> Result<Option<T>, SslAlert> + 'static + Sync + Send,
    T: AsRef<[u8]> + 'static + Sync + Send,
{
    unsafe {
        let ssl = SslRef::from_ptr_mut(ssl);
        let callback = ssl
            .ssl_context()
            .ex_data(SslContext::cached_ex_index::<F>())
            .expect("BUG: custom ext add callback missing") as *const F;
        let ectx = ExtensionContext::from_bits_truncate(context);
        let cert = if ectx.contains(ExtensionContext::TLS1_3_CERTIFICATE) {
            Some((chainidx, X509Ref::from_ptr(x)))
        } else {
            None
        };
        match (*callback)(ssl, ectx, cert) {
            Ok(None) => 0,
            Ok(Some(buf)) => {
                *outlen = buf.as_ref().len();
                *out = buf.as_ref().as_ptr();
                let idx = Ssl::cached_ex_index::<CustomExtAddState<T>>();
                let mut buf = Some(buf);
                let new = match ssl.ex_data_mut(idx) {
                    Some(state) => {
                        state.0 = buf.take();
                        false
                    }
                    None => true,
                };
                if new {
                    ssl.set_ex_data(idx, CustomExtAddState(buf));
                }
                1
            }
            Err(alert) => {
                *al = alert.0;
                -1
            }
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: true, With_SAFETY_comment: false, Name: raw_custom_ext_free,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs

Found function with unsafe block in raw_custom_ext_free:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs
Start Line: 622, End Line: 638
#[cfg(ossl111)]
pub extern "C" fn raw_custom_ext_free<T>(
    ssl: *mut ffi::SSL,
    _: c_uint,
    _: c_uint,
    _: *const c_uchar,
    _: *mut c_void,
)
where
    T: 'static + Sync + Send,
{
    unsafe {
        let ssl = SslRef::from_ptr_mut(ssl);
        let idx = Ssl::cached_ex_index::<CustomExtAddState<T>>();
        if let Some(state) = ssl.ex_data_mut(idx) {
            state.0 = None;
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 6 statements, Complex: false, With_SAFETY_comment: false, Name: raw_custom_ext_parse,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs

Found function with unsafe block in raw_custom_ext_parse:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\callbacks.rs
Start Line: 641, End Line: 680
#[cfg(ossl111)]
pub extern "C" fn raw_custom_ext_parse<F>(
    ssl: *mut ffi::SSL,
    _: c_uint,
    context: c_uint,
    input: *const c_uchar,
    inlen: size_t,
    x: *mut ffi::X509,
    chainidx: size_t,
    al: *mut c_int,
    _: *mut c_void,
) -> c_int
where
    F: Fn(
            &mut SslRef,
            ExtensionContext,
            &[u8],
            Option<(usize, &X509Ref)>,
        ) -> Result<(), SslAlert> + 'static + Sync + Send,
{
    unsafe {
        let ssl = SslRef::from_ptr_mut(ssl);
        let callback = ssl
            .ssl_context()
            .ex_data(SslContext::cached_ex_index::<F>())
            .expect("BUG: custom ext parse callback missing") as *const F;
        let ectx = ExtensionContext::from_bits_truncate(context);
        #[allow(clippy::unnecessary_cast)]
        let slice = slice::from_raw_parts(input as *const u8, inlen);
        let cert = if ectx.contains(ExtensionContext::TLS1_3_CERTIFICATE) {
            Some((chainidx, X509Ref::from_ptr(x)))
        } else {
            None
        };
        match (*callback)(ssl, ectx, slice, cert) {
            Ok(()) => 1,
            Err(alert) => {
                *al = alert.0;
                0
            }
        }
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\connector.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\error.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: cipher_name,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found function with unsafe block in cipher_name:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 127, End Line: 135
/// Returns the OpenSSL name of a cipher corresponding to an RFC-standard cipher name.
///
/// If the cipher has no corresponding OpenSSL name, the string `(NONE)` is returned.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(OPENSSL_cipher_name)]
#[cfg(ossl111)]
pub fn cipher_name(std_name: &str) -> &'static str {
    unsafe {
        ffi::init();
        let s = CString::new(std_name).unwrap();
        let ptr = ffi::OPENSSL_cipher_name(s.as_ptr());
        CStr::from_ptr(ptr).to_str().unwrap()
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: tls,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in tls:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 345, End Line: 347
/// Support all versions of the TLS protocol.
#[corresponds(TLS_method)]
pub fn tls() -> SslMethod {
    unsafe { SslMethod(TLS_method()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: dtls,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in dtls:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 351, End Line: 353
/// Support all versions of the DTLS protocol.
#[corresponds(DTLS_method)]
pub fn dtls() -> SslMethod {
    unsafe { SslMethod(DTLS_method()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: tls_client,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in tls_client:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 357, End Line: 359
/// Support all versions of the TLS protocol, explicitly as a client.
#[corresponds(TLS_client_method)]
pub fn tls_client() -> SslMethod {
    unsafe { SslMethod(TLS_client_method()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: tls_server,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in tls_server:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 363, End Line: 365
/// Support all versions of the TLS protocol, explicitly as a server.
#[corresponds(TLS_server_method)]
pub fn tls_server() -> SslMethod {
    unsafe { SslMethod(TLS_server_method()) }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: true, With_SAFETY_comment: false, Name: select_next_proto,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found function with unsafe block in select_next_proto:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 698, End Line: 716
/// A standard implementation of protocol selection for Application Layer Protocol Negotiation
/// (ALPN).
///
/// `server` should contain the server's list of supported protocols and `client` the client's. They
/// must both be in the ALPN wire format. See the documentation for
/// [`SslContextBuilder::set_alpn_protos`] for details.
///
/// It will select the first protocol supported by the server which is also supported by the client.
///
/// [`SslContextBuilder::set_alpn_protos`]: struct.SslContextBuilder.html#method.set_alpn_protos
#[corresponds(SSL_select_next_proto)]
pub fn select_next_proto<'a>(server: &[u8], client: &'a [u8]) -> Option<&'a [u8]> {
    unsafe {
        let mut out = ptr::null_mut();
        let mut outlen = 0;
        let r = ffi::SSL_select_next_proto(
            &mut out,
            &mut outlen,
            server.as_ptr(),
            server.len() as c_uint,
            client.as_ptr(),
            client.len() as c_uint,
        );
        if r == ffi::OPENSSL_NPN_NEGOTIATED {
            Some(slice::from_raw_parts(out as *const u8, outlen as usize))
        } else {
            None
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 724, End Line: 731
/// Creates a new `SslContextBuilder`.
#[corresponds(SSL_CTX_new)]
pub fn new(method: SslMethod) -> Result<SslContextBuilder, ErrorStack> {
    unsafe {
        init();
        let ctx = cvt_p(ffi::SSL_CTX_new(method.as_ptr()))?;
        Ok(SslContextBuilder::from_ptr(ctx))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_verify,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_verify:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 749, End Line: 753
/// Configures the certificate verification method for new connections.
#[corresponds(SSL_CTX_set_verify)]
pub fn set_verify(&mut self, mode: SslVerifyMode) {
    unsafe {
        ffi::SSL_CTX_set_verify(self.as_ptr(), mode.bits() as c_int, None);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_verify_callback,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_verify_callback:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 762, End Line: 770
/// Configures the certificate verification method for new connections and
/// registers a verification callback.
///
/// The callback is passed a boolean indicating if OpenSSL's internal verification succeeded as
/// well as a reference to the `X509StoreContext` which can be used to examine the certificate
/// chain. It should return a boolean indicating if verification succeeded.
#[corresponds(SSL_CTX_set_verify)]
pub fn set_verify_callback<F>(&mut self, mode: SslVerifyMode, verify: F)
where
    F: Fn(bool, &mut X509StoreContextRef) -> bool + 'static + Sync + Send,
{
    unsafe {
        self.set_ex_data(SslContext::cached_ex_index::<F>(), verify);
        ffi::SSL_CTX_set_verify(
            self.as_ptr(),
            mode.bits() as c_int,
            Some(raw_verify::<F>),
        );
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: set_servername_callback,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_servername_callback:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 781, End Line: 801
/// Configures the server name indication (SNI) callback for new connections.
///
/// SNI is used to allow a single server to handle requests for multiple domains, each of which
/// has its own certificate chain and configuration.
///
/// Obtain the server name with the `servername` method and then set the corresponding context
/// with `set_ssl_context`
#[corresponds(SSL_CTX_set_tlsext_servername_callback)]
pub fn set_servername_callback<F>(&mut self, callback: F)
where
    F: Fn(&mut SslRef, &mut SslAlert) -> Result<(), SniError> + 'static + Sync + Send,
{
    unsafe {
        let arg = self.set_ex_data_inner(SslContext::cached_ex_index::<F>(), callback);
        ffi::SSL_CTX_set_tlsext_servername_arg(self.as_ptr(), arg);
        #[cfg(boringssl)]
        ffi::SSL_CTX_set_tlsext_servername_callback(self.as_ptr(), Some(raw_sni::<F>));
        #[cfg(not(boringssl))]
        ffi::SSL_CTX_set_tlsext_servername_callback__fixed_rust(
            self.as_ptr(),
            Some(raw_sni::<F>),
        );
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_verify_depth,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_verify_depth:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 807, End Line: 811
/// Sets the certificate verification depth.
///
/// If the peer's certificate chain is longer than this value, verification will fail.
#[corresponds(SSL_CTX_set_verify_depth)]
pub fn set_verify_depth(&mut self, depth: u32) {
    unsafe {
        ffi::SSL_CTX_set_verify_depth(self.as_ptr(), depth as c_int);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: set_verify_cert_store,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_verify_cert_store:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 818, End Line: 826
/// Sets a custom certificate store for verifying peer certificates.
///
/// Requires OpenSSL 1.0.2 or newer.
#[corresponds(SSL_CTX_set0_verify_cert_store)]
#[cfg(ossl102)]
pub fn set_verify_cert_store(
    &mut self,
    cert_store: X509Store,
) -> Result<(), ErrorStack> {
    unsafe {
        let ptr = cert_store.as_ptr();
        cvt(ffi::SSL_CTX_set0_verify_cert_store(self.as_ptr(), ptr) as c_int)?;
        mem::forget(cert_store);
        Ok(())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_cert_store,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_cert_store:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 830, End Line: 835
/// Replaces the context's certificate store.
#[corresponds(SSL_CTX_set_cert_store)]
pub fn set_cert_store(&mut self, cert_store: X509Store) {
    unsafe {
        ffi::SSL_CTX_set_cert_store(self.as_ptr(), cert_store.as_ptr());
        mem::forget(cert_store);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_read_ahead,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_read_ahead:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 844, End Line: 848
/// Controls read ahead behavior.
///
/// If enabled, OpenSSL will read as much data as is available from the underlying stream,
/// instead of a single record at a time.
///
/// It has no effect when used with DTLS.
#[corresponds(SSL_CTX_set_read_ahead)]
pub fn set_read_ahead(&mut self, read_ahead: bool) {
    unsafe {
        ffi::SSL_CTX_set_read_ahead(self.as_ptr(), read_ahead as SslBitType);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_mode,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_mode:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 852, End Line: 857
/// Sets the mode used by the context, returning the previous mode.
#[corresponds(SSL_CTX_set_mode)]
pub fn set_mode(&mut self, mode: SslMode) -> SslMode {
    unsafe {
        let bits = ffi::SSL_CTX_set_mode(self.as_ptr(), mode.bits() as MtuTy)
            as SslBitType;
        SslMode::from_bits_retain(bits)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_tmp_dh,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_tmp_dh:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 861, End Line: 863
/// Sets the parameters to be used during ephemeral Diffie-Hellman key exchange.
#[corresponds(SSL_CTX_set_tmp_dh)]
pub fn set_tmp_dh(&mut self, dh: &DhRef<Params>) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::SSL_CTX_set_tmp_dh(self.as_ptr(), dh.as_ptr()) as c_int).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: set_tmp_dh_callback,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_tmp_dh_callback:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 872, End Line: 884
/// Sets the callback which will generate parameters to be used during ephemeral Diffie-Hellman
/// key exchange.
///
/// The callback is provided with a reference to the `Ssl` for the session, as well as a boolean
/// indicating if the selected cipher is export-grade, and the key length. The export and key
/// length options are archaic and should be ignored in almost all cases.
#[corresponds(SSL_CTX_set_tmp_dh_callback)]
pub fn set_tmp_dh_callback<F>(&mut self, callback: F)
where
    F: Fn(&mut SslRef, bool, u32) -> Result<Dh<Params>, ErrorStack> + 'static + Sync
        + Send,
{
    unsafe {
        self.set_ex_data(SslContext::cached_ex_index::<F>(), callback);
        #[cfg(not(boringssl))]
        ffi::SSL_CTX_set_tmp_dh_callback__fixed_rust(
            self.as_ptr(),
            Some(raw_tmp_dh::<F>),
        );
        #[cfg(boringssl)]
        ffi::SSL_CTX_set_tmp_dh_callback(self.as_ptr(), Some(raw_tmp_dh::<F>));
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_tmp_ecdh,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_tmp_ecdh:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 888, End Line: 890
/// Sets the parameters to be used during ephemeral elliptic curve Diffie-Hellman key exchange.
#[corresponds(SSL_CTX_set_tmp_ecdh)]
pub fn set_tmp_ecdh(&mut self, key: &EcKeyRef<Params>) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::SSL_CTX_set_tmp_ecdh(self.as_ptr(), key.as_ptr()) as c_int).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_tmp_ecdh_callback,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_tmp_ecdh_callback:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 903, End Line: 911
/// Sets the callback which will generate parameters to be used during ephemeral elliptic curve
/// Diffie-Hellman key exchange.
///
/// The callback is provided with a reference to the `Ssl` for the session, as well as a boolean
/// indicating if the selected cipher is export-grade, and the key length. The export and key
/// length options are archaic and should be ignored in almost all cases.
///
/// Requires OpenSSL 1.0.1 or 1.0.2.
#[corresponds(SSL_CTX_set_tmp_ecdh_callback)]
#[cfg(all(ossl101, not(ossl110)))]
#[deprecated(
    note = "this function leaks memory and does not exist on newer OpenSSL versions"
)]
pub fn set_tmp_ecdh_callback<F>(&mut self, callback: F)
where
    F: Fn(&mut SslRef, bool, u32) -> Result<EcKey<Params>, ErrorStack> + 'static + Sync
        + Send,
{
    unsafe {
        self.set_ex_data(SslContext::cached_ex_index::<F>(), callback);
        ffi::SSL_CTX_set_tmp_ecdh_callback__fixed_rust(
            self.as_ptr(),
            Some(raw_tmp_ecdh::<F>),
        );
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_default_verify_paths,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_default_verify_paths:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 918, End Line: 920
/// Use the default locations of trusted certificates for verification.
///
/// These locations are read from the `SSL_CERT_FILE` and `SSL_CERT_DIR` environment variables
/// if present, or defaults specified at OpenSSL build time otherwise.
#[corresponds(SSL_CTX_set_default_verify_paths)]
pub fn set_default_verify_paths(&mut self) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::SSL_CTX_set_default_verify_paths(self.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_ca_file,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_ca_file:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 926, End Line: 936
/// Loads trusted root certificates from a file.
///
/// The file should contain a sequence of PEM-formatted CA certificates.
#[corresponds(SSL_CTX_load_verify_locations)]
pub fn set_ca_file<P: AsRef<Path>>(&mut self, file: P) -> Result<(), ErrorStack> {
    let file = CString::new(file.as_ref().as_os_str().to_str().unwrap()).unwrap();
    unsafe {
        cvt(
                ffi::SSL_CTX_load_verify_locations(
                    self.as_ptr(),
                    file.as_ptr() as *const _,
                    ptr::null(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_client_ca_list,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_client_ca_list:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 943, End Line: 948
/// Sets the list of CA names sent to the client.
///
/// The CA certificates must still be added to the trust root - they are not automatically set
/// as trusted by this method.
#[corresponds(SSL_CTX_set_client_CA_list)]
pub fn set_client_ca_list(&mut self, list: Stack<X509Name>) {
    unsafe {
        ffi::SSL_CTX_set_client_CA_list(self.as_ptr(), list.as_ptr());
        mem::forget(list);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: add_client_ca,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in add_client_ca:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 953, End Line: 955
/// Add the provided CA certificate to the list sent by the server to the client when
/// requesting client-side TLS authentication.
#[corresponds(SSL_CTX_add_client_CA)]
pub fn add_client_ca(&mut self, cacert: &X509Ref) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::SSL_CTX_add_client_CA(self.as_ptr(), cacert.as_ptr())).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_session_id_context,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_session_id_context:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 966, End Line: 976
/// Set the context identifier for sessions.
///
/// This value identifies the server's session cache to clients, telling them when they're
/// able to reuse sessions. It should be set to a unique value per server, unless multiple
/// servers share a session cache.
///
/// This value should be set when using client certificates, or each request will fail its
/// handshake and need to be restarted.
#[corresponds(SSL_CTX_set_session_id_context)]
pub fn set_session_id_context(&mut self, sid_ctx: &[u8]) -> Result<(), ErrorStack> {
    unsafe {
        assert!(sid_ctx.len() <= c_uint::MAX as usize);
        cvt(
                ffi::SSL_CTX_set_session_id_context(
                    self.as_ptr(),
                    sid_ctx.as_ptr(),
                    sid_ctx.len() as SizeTy,
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_certificate_file,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_certificate_file:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 984, End Line: 998
/// Loads a leaf certificate from a file.
///
/// Only a single certificate will be loaded - use `add_extra_chain_cert` to add the remainder
/// of the certificate chain, or `set_certificate_chain_file` to load the entire chain from a
/// single file.
#[corresponds(SSL_CTX_use_certificate_file)]
pub fn set_certificate_file<P: AsRef<Path>>(
    &mut self,
    file: P,
    file_type: SslFiletype,
) -> Result<(), ErrorStack> {
    let file = CString::new(file.as_ref().as_os_str().to_str().unwrap()).unwrap();
    unsafe {
        cvt(
                ffi::SSL_CTX_use_certificate_file(
                    self.as_ptr(),
                    file.as_ptr() as *const _,
                    file_type.as_raw(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_certificate_chain_file,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_certificate_chain_file:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1006, End Line: 1018
/// Loads a certificate chain from a file.
///
/// The file should contain a sequence of PEM-formatted certificates, the first being the leaf
/// certificate, and the remainder forming the chain of certificates up to and including the
/// trusted root certificate.
#[corresponds(SSL_CTX_use_certificate_chain_file)]
pub fn set_certificate_chain_file<P: AsRef<Path>>(
    &mut self,
    file: P,
) -> Result<(), ErrorStack> {
    let file = CString::new(file.as_ref().as_os_str().to_str().unwrap()).unwrap();
    unsafe {
        cvt(
                ffi::SSL_CTX_use_certificate_chain_file(
                    self.as_ptr(),
                    file.as_ptr() as *const _,
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_certificate,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_certificate:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1024, End Line: 1026
/// Sets the leaf certificate.
///
/// Use `add_extra_chain_cert` to add the remainder of the certificate chain.
#[corresponds(SSL_CTX_use_certificate)]
pub fn set_certificate(&mut self, cert: &X509Ref) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::SSL_CTX_use_certificate(self.as_ptr(), cert.as_ptr())).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: add_extra_chain_cert,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in add_extra_chain_cert:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1033, End Line: 1039
/// Appends a certificate to the certificate chain.
///
/// This chain should contain all certificates necessary to go from the certificate specified by
/// `set_certificate` to a trusted root.
#[corresponds(SSL_CTX_add_extra_chain_cert)]
pub fn add_extra_chain_cert(&mut self, cert: X509) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::SSL_CTX_add_extra_chain_cert(self.as_ptr(), cert.as_ptr()) as c_int)?;
        mem::forget(cert);
        Ok(())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_private_key_file,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_private_key_file:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1043, End Line: 1057
/// Loads the private key from a file.
#[corresponds(SSL_CTX_use_PrivateKey_file)]
pub fn set_private_key_file<P: AsRef<Path>>(
    &mut self,
    file: P,
    file_type: SslFiletype,
) -> Result<(), ErrorStack> {
    let file = CString::new(file.as_ref().as_os_str().to_str().unwrap()).unwrap();
    unsafe {
        cvt(
                ffi::SSL_CTX_use_PrivateKey_file(
                    self.as_ptr(),
                    file.as_ptr() as *const _,
                    file_type.as_raw(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_private_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_private_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1061, End Line: 1066
/// Sets the private key.
#[corresponds(SSL_CTX_use_PrivateKey)]
pub fn set_private_key<T>(&mut self, key: &PKeyRef<T>) -> Result<(), ErrorStack>
where
    T: HasPrivate,
{
    unsafe { cvt(ffi::SSL_CTX_use_PrivateKey(self.as_ptr(), key.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_cipher_list,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_cipher_list:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1076, End Line: 1085
/// Sets the list of supported ciphers for protocols before TLSv1.3.
///
/// The `set_ciphersuites` method controls the cipher suites for TLSv1.3.
///
/// See [`ciphers`] for details on the format.
///
/// [`ciphers`]: https://www.openssl.org/docs/manmaster/apps/ciphers.html
#[corresponds(SSL_CTX_set_cipher_list)]
pub fn set_cipher_list(&mut self, cipher_list: &str) -> Result<(), ErrorStack> {
    let cipher_list = CString::new(cipher_list).unwrap();
    unsafe {
        cvt(
                ffi::SSL_CTX_set_cipher_list(
                    self.as_ptr(),
                    cipher_list.as_ptr() as *const _,
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_ciphersuites,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_ciphersuites:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1097, End Line: 1106
/// Sets the list of supported ciphers for the TLSv1.3 protocol.
///
/// The `set_cipher_list` method controls the cipher suites for protocols before TLSv1.3.
///
/// The format consists of TLSv1.3 cipher suite names separated by `:` characters in order of
/// preference.
///
/// Requires OpenSSL 1.1.1 or LibreSSL 3.4.0 or newer.
#[corresponds(SSL_CTX_set_ciphersuites)]
#[cfg(any(ossl111, libressl340))]
pub fn set_ciphersuites(&mut self, cipher_list: &str) -> Result<(), ErrorStack> {
    let cipher_list = CString::new(cipher_list).unwrap();
    unsafe {
        cvt(
                ffi::SSL_CTX_set_ciphersuites(
                    self.as_ptr(),
                    cipher_list.as_ptr() as *const _,
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_ecdh_auto,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_ecdh_auto:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1113, End Line: 1115
/// Enables ECDHE key exchange with an automatically chosen curve list.
///
/// Requires OpenSSL 1.0.2.
#[corresponds(SSL_CTX_set_ecdh_auto)]
#[cfg(any(libressl, all(ossl102, not(ossl110))))]
pub fn set_ecdh_auto(&mut self, onoff: bool) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::SSL_CTX_set_ecdh_auto(self.as_ptr(), onoff as c_int)).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_options,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_options:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1124, End Line: 1128
/// Sets the options used by the context, returning the old set.
///
/// # Note
///
/// This *enables* the specified options, but does not disable unspecified options. Use
/// `clear_options` for that.
#[corresponds(SSL_CTX_set_options)]
pub fn set_options(&mut self, option: SslOptions) -> SslOptions {
    let bits = unsafe { ffi::SSL_CTX_set_options(self.as_ptr(), option.bits()) }
        as SslOptionsRepr;
    SslOptions::from_bits_retain(bits)
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: options,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in options:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1132, End Line: 1135
/// Returns the options used by the context.
#[corresponds(SSL_CTX_get_options)]
pub fn options(&self) -> SslOptions {
    let bits = unsafe { ffi::SSL_CTX_get_options(self.as_ptr()) } as SslOptionsRepr;
    SslOptions::from_bits_retain(bits)
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: clear_options,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in clear_options:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1139, End Line: 1143
/// Clears the options used by the context, returning the old set.
#[corresponds(SSL_CTX_clear_options)]
pub fn clear_options(&mut self, option: SslOptions) -> SslOptions {
    let bits = unsafe { ffi::SSL_CTX_clear_options(self.as_ptr(), option.bits()) }
        as SslOptionsRepr;
    SslOptions::from_bits_retain(bits)
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_min_proto_version,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_min_proto_version:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1153, End Line: 1161
/// Sets the minimum supported protocol version.
///
/// A value of `None` will enable protocol versions down to the lowest version supported by
/// OpenSSL.
///
/// Requires BoringSSL or OpenSSL 1.1.0 or LibreSSL 2.6.1 or newer.
#[corresponds(SSL_CTX_set_min_proto_version)]
#[cfg(any(ossl110, libressl261, boringssl))]
pub fn set_min_proto_version(
    &mut self,
    version: Option<SslVersion>,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::SSL_CTX_set_min_proto_version(
                    self.as_ptr(),
                    version.map_or(0, |v| v.0 as _),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_max_proto_version,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_max_proto_version:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1171, End Line: 1179
/// Sets the maximum supported protocol version.
///
/// A value of `None` will enable protocol versions up to the highest version supported by
/// OpenSSL.
///
/// Requires BoringSSL or OpenSSL 1.1.0 or or LibreSSL 2.6.1 or newer.
#[corresponds(SSL_CTX_set_max_proto_version)]
#[cfg(any(ossl110, libressl261, boringssl))]
pub fn set_max_proto_version(
    &mut self,
    version: Option<SslVersion>,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::SSL_CTX_set_max_proto_version(
                    self.as_ptr(),
                    version.map_or(0, |v| v.0 as _),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: min_proto_version,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in min_proto_version:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1189, End Line: 1198
/// Gets the minimum supported protocol version.
///
/// A value of `None` indicates that all versions down to the lowest version supported by
/// OpenSSL are enabled.
///
/// Requires OpenSSL 1.1.0g or LibreSSL 2.7.0 or newer.
#[corresponds(SSL_CTX_get_min_proto_version)]
#[cfg(any(ossl110g, libressl270))]
pub fn min_proto_version(&mut self) -> Option<SslVersion> {
    unsafe {
        let r = ffi::SSL_CTX_get_min_proto_version(self.as_ptr());
        if r == 0 { None } else { Some(SslVersion(r)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: max_proto_version,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in max_proto_version:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1208, End Line: 1217
/// Gets the maximum supported protocol version.
///
/// A value of `None` indicates that all versions up to the highest version supported by
/// OpenSSL are enabled.
///
/// Requires OpenSSL 1.1.0g or LibreSSL 2.7.0 or newer.
#[corresponds(SSL_CTX_get_max_proto_version)]
#[cfg(any(ossl110g, libressl270))]
pub fn max_proto_version(&mut self) -> Option<SslVersion> {
    unsafe {
        let r = ffi::SSL_CTX_get_max_proto_version(self.as_ptr());
        if r == 0 { None } else { Some(SslVersion(r)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: true, With_SAFETY_comment: false, Name: set_alpn_protos,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_alpn_protos:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1229, End Line: 1244
/// Sets the protocols to sent to the server for Application Layer Protocol Negotiation (ALPN).
///
/// The input must be in ALPN "wire format". It consists of a sequence of supported protocol
/// names prefixed by their byte length. For example, the protocol list consisting of `spdy/1`
/// and `http/1.1` is encoded as `b"\x06spdy/1\x08http/1.1"`. The protocols are ordered by
/// preference.
///
/// Requires BoringSSL or OpenSSL 1.0.2 or LibreSSL 2.6.1 or newer.
#[corresponds(SSL_CTX_set_alpn_protos)]
#[cfg(any(ossl102, libressl261, boringssl))]
pub fn set_alpn_protos(&mut self, protocols: &[u8]) -> Result<(), ErrorStack> {
    unsafe {
        assert!(protocols.len() <= c_uint::MAX as usize);
        let r = ffi::SSL_CTX_set_alpn_protos(
            self.as_ptr(),
            protocols.as_ptr(),
            protocols.len() as _,
        );
        if r == 0 { Ok(()) } else { Err(ErrorStack::get()) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: true, With_SAFETY_comment: false, Name: set_tlsext_use_srtp,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_tlsext_use_srtp:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1248, End Line: 1260
/// Enables the DTLS extension "use_srtp" as defined in RFC5764.
#[corresponds(SSL_CTX_set_tlsext_use_srtp)]
pub fn set_tlsext_use_srtp(&mut self, protocols: &str) -> Result<(), ErrorStack> {
    unsafe {
        let cstr = CString::new(protocols).unwrap();
        let r = ffi::SSL_CTX_set_tlsext_use_srtp(self.as_ptr(), cstr.as_ptr());
        if r == 0 { Ok(()) } else { Err(ErrorStack::get()) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_alpn_select_callback,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_alpn_select_callback:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1276, End Line: 1288
/// Sets the callback used by a server to select a protocol for Application Layer Protocol
/// Negotiation (ALPN).
///
/// The callback is provided with the client's protocol list in ALPN wire format. See the
/// documentation for [`SslContextBuilder::set_alpn_protos`] for details. It should return one
/// of those protocols on success. The [`select_next_proto`] function implements the standard
/// protocol selection algorithm.
///
/// Requires OpenSSL 1.0.2 or LibreSSL 2.6.1 or newer.
///
/// [`SslContextBuilder::set_alpn_protos`]: struct.SslContextBuilder.html#method.set_alpn_protos
/// [`select_next_proto`]: fn.select_next_proto.html
#[corresponds(SSL_CTX_set_alpn_select_cb)]
#[cfg(any(ossl102, libressl261))]
pub fn set_alpn_select_callback<F>(&mut self, callback: F)
where
    F: for<'a> Fn(&mut SslRef, &'a [u8]) -> Result<&'a [u8], AlpnError> + 'static + Sync
        + Send,
{
    unsafe {
        self.set_ex_data(SslContext::cached_ex_index::<F>(), callback);
        ffi::SSL_CTX_set_alpn_select_cb__fixed_rust(
            self.as_ptr(),
            Some(callbacks::raw_alpn_select::<F>),
            ptr::null_mut(),
        );
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: check_private_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in check_private_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1292, End Line: 1294
/// Checks for consistency between the private key and certificate.
#[corresponds(SSL_CTX_check_private_key)]
pub fn check_private_key(&self) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::SSL_CTX_check_private_key(self.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cert_store,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in cert_store:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1298, End Line: 1300
/// Returns a shared reference to the context's certificate store.
#[corresponds(SSL_CTX_get_cert_store)]
pub fn cert_store(&self) -> &X509StoreBuilderRef {
    unsafe { X509StoreBuilderRef::from_ptr(ffi::SSL_CTX_get_cert_store(self.as_ptr())) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cert_store_mut,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in cert_store_mut:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1304, End Line: 1306
/// Returns a mutable reference to the context's certificate store.
#[corresponds(SSL_CTX_get_cert_store)]
pub fn cert_store_mut(&mut self) -> &mut X509StoreBuilderRef {
    unsafe {
        X509StoreBuilderRef::from_ptr_mut(ffi::SSL_CTX_get_cert_store(self.as_ptr()))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: verify_param,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in verify_param:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1313, End Line: 1315
/// Returns a reference to the X509 verification configuration.
///
/// Requires BoringSSL or OpenSSL 1.0.2 or newer.
#[corresponds(SSL_CTX_get0_param)]
#[cfg(any(ossl102, boringssl, libressl261))]
pub fn verify_param(&self) -> &X509VerifyParamRef {
    unsafe { X509VerifyParamRef::from_ptr(ffi::SSL_CTX_get0_param(self.as_ptr())) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: verify_param_mut,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in verify_param_mut:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1322, End Line: 1324
/// Returns a mutable reference to the X509 verification configuration.
///
/// Requires BoringSSL or OpenSSL 1.0.2 or newer.
#[corresponds(SSL_CTX_get0_param)]
#[cfg(any(ossl102, boringssl, libressl261))]
pub fn verify_param_mut(&mut self) -> &mut X509VerifyParamRef {
    unsafe { X509VerifyParamRef::from_ptr_mut(ffi::SSL_CTX_get0_param(self.as_ptr())) }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_status_callback,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_status_callback:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1339, End Line: 1351
/// Sets the callback dealing with OCSP stapling.
///
/// On the client side, this callback is responsible for validating the OCSP status response
/// returned by the server. The status may be retrieved with the `SslRef::ocsp_status` method.
/// A response of `Ok(true)` indicates that the OCSP status is valid, and a response of
/// `Ok(false)` indicates that the OCSP status is invalid and the handshake should be
/// terminated.
///
/// On the server side, this callback is responsible for setting the OCSP status response to be
/// returned to clients. The status may be set with the `SslRef::set_ocsp_status` method. A
/// response of `Ok(true)` indicates that the OCSP status should be returned to the client, and
/// `Ok(false)` indicates that the status should not be returned to the client.
#[corresponds(SSL_CTX_set_tlsext_status_cb)]
pub fn set_status_callback<F>(&mut self, callback: F) -> Result<(), ErrorStack>
where
    F: Fn(&mut SslRef) -> Result<bool, ErrorStack> + 'static + Sync + Send,
{
    unsafe {
        self.set_ex_data(SslContext::cached_ex_index::<F>(), callback);
        cvt(
                ffi::SSL_CTX_set_tlsext_status_cb(
                    self.as_ptr(),
                    Some(raw_tlsext_status::<F>),
                ) as c_int,
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_psk_client_callback,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_psk_client_callback:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1360, End Line: 1371
/// Sets the callback for providing an identity and pre-shared key for a TLS-PSK client.
///
/// The callback will be called with the SSL context, an identity hint if one was provided
/// by the server, a mutable slice for each of the identity and pre-shared key bytes. The
/// identity must be written as a null-terminated C string.
#[corresponds(SSL_CTX_set_psk_client_callback)]
#[cfg(not(osslconf = "OPENSSL_NO_PSK"))]
pub fn set_psk_client_callback<F>(&mut self, callback: F)
where
    F: Fn(&mut SslRef, Option<&[u8]>, &mut [u8], &mut [u8]) -> Result<usize, ErrorStack>
        + 'static + Sync + Send,
{
    unsafe {
        self.set_ex_data(SslContext::cached_ex_index::<F>(), callback);
        ffi::SSL_CTX_set_psk_client_callback(self.as_ptr(), Some(raw_client_psk::<F>));
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_psk_server_callback,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_psk_server_callback:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1392, End Line: 1403
/// Sets the callback for providing an identity and pre-shared key for a TLS-PSK server.
///
/// The callback will be called with the SSL context, an identity provided by the client,
/// and, a mutable slice for the pre-shared key bytes. The callback returns the number of
/// bytes in the pre-shared key.
#[corresponds(SSL_CTX_set_psk_server_callback)]
#[cfg(not(osslconf = "OPENSSL_NO_PSK"))]
pub fn set_psk_server_callback<F>(&mut self, callback: F)
where
    F: Fn(&mut SslRef, Option<&[u8]>, &mut [u8]) -> Result<usize, ErrorStack> + 'static
        + Sync + Send,
{
    unsafe {
        self.set_ex_data(SslContext::cached_ex_index::<F>(), callback);
        ffi::SSL_CTX_set_psk_server_callback(self.as_ptr(), Some(raw_server_psk::<F>));
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_new_session_callback,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_new_session_callback:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1419, End Line: 1427
/// Sets the callback which is called when new sessions are negotiated.
///
/// This can be used by clients to implement session caching. While in TLSv1.2 the session is
/// available to access via [`SslRef::session`] immediately after the handshake completes, this
/// is not the case for TLSv1.3. There, a session is not generally available immediately, and
/// the server may provide multiple session tokens to the client over a single session. The new
/// session callback is a portable way to deal with both cases.
///
/// Note that session caching must be enabled for the callback to be invoked, and it defaults
/// off for clients. [`set_session_cache_mode`] controls that behavior.
///
/// [`SslRef::session`]: struct.SslRef.html#method.session
/// [`set_session_cache_mode`]: #method.set_session_cache_mode
#[corresponds(SSL_CTX_sess_set_new_cb)]
pub fn set_new_session_callback<F>(&mut self, callback: F)
where
    F: Fn(&mut SslRef, SslSession) + 'static + Sync + Send,
{
    unsafe {
        self.set_ex_data(SslContext::cached_ex_index::<F>(), callback);
        ffi::SSL_CTX_sess_set_new_cb(
            self.as_ptr(),
            Some(callbacks::raw_new_session::<F>),
        );
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_remove_session_callback,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_remove_session_callback:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1433, End Line: 1444
/// Sets the callback which is called when sessions are removed from the context.
///
/// Sessions can be removed because they have timed out or because they are considered faulty.
#[corresponds(SSL_CTX_sess_set_remove_cb)]
pub fn set_remove_session_callback<F>(&mut self, callback: F)
where
    F: Fn(&SslContextRef, &SslSessionRef) + 'static + Sync + Send,
{
    unsafe {
        self.set_ex_data(SslContext::cached_ex_index::<F>(), callback);
        ffi::SSL_CTX_sess_set_remove_cb(
            self.as_ptr(),
            Some(callbacks::raw_remove_session::<F>),
        );
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_keylog_callback,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_keylog_callback:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1474, End Line: 1482
/// Sets the TLS key logging callback.
///
/// The callback is invoked whenever TLS key material is generated, and is passed a line of NSS
/// SSLKEYLOGFILE-formatted text. This can be used by tools like Wireshark to decrypt message
/// traffic. The line does not contain a trailing newline.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(SSL_CTX_set_keylog_callback)]
#[cfg(any(ossl111, boringssl))]
pub fn set_keylog_callback<F>(&mut self, callback: F)
where
    F: Fn(&SslRef, &str) + 'static + Sync + Send,
{
    unsafe {
        self.set_ex_data(SslContext::cached_ex_index::<F>(), callback);
        ffi::SSL_CTX_set_keylog_callback(
            self.as_ptr(),
            Some(callbacks::raw_keylog::<F>),
        );
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_session_cache_mode,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_session_cache_mode:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1488, End Line: 1493
/// Sets the session caching mode use for connections made with the context.
///
/// Returns the previous session caching mode.
#[corresponds(SSL_CTX_set_session_cache_mode)]
pub fn set_session_cache_mode(
    &mut self,
    mode: SslSessionCacheMode,
) -> SslSessionCacheMode {
    unsafe {
        let bits = ffi::SSL_CTX_set_session_cache_mode(self.as_ptr(), mode.bits());
        SslSessionCacheMode::from_bits_retain(bits)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_stateless_cookie_generate_cb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_stateless_cookie_generate_cb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1502, End Line: 1513
/// Sets the callback for generating an application cookie for TLS1.3
/// stateless handshakes.
///
/// The callback will be called with the SSL context and a slice into which the cookie
/// should be written. The callback should return the number of bytes written.
#[corresponds(SSL_CTX_set_stateless_cookie_generate_cb)]
#[cfg(ossl111)]
pub fn set_stateless_cookie_generate_cb<F>(&mut self, callback: F)
where
    F: Fn(&mut SslRef, &mut [u8]) -> Result<usize, ErrorStack> + 'static + Sync + Send,
{
    unsafe {
        self.set_ex_data(SslContext::cached_ex_index::<F>(), callback);
        ffi::SSL_CTX_set_stateless_cookie_generate_cb(
            self.as_ptr(),
            Some(raw_stateless_cookie_generate::<F>),
        );
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_stateless_cookie_verify_cb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_stateless_cookie_verify_cb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1525, End Line: 1536
/// Sets the callback for verifying an application cookie for TLS1.3
/// stateless handshakes.
///
/// The callback will be called with the SSL context and the cookie supplied by the
/// client. It should return true if and only if the cookie is valid.
///
/// Note that the OpenSSL implementation independently verifies the integrity of
/// application cookies using an HMAC before invoking the supplied callback.
#[corresponds(SSL_CTX_set_stateless_cookie_verify_cb)]
#[cfg(ossl111)]
pub fn set_stateless_cookie_verify_cb<F>(&mut self, callback: F)
where
    F: Fn(&mut SslRef, &[u8]) -> bool + 'static + Sync + Send,
{
    unsafe {
        self.set_ex_data(SslContext::cached_ex_index::<F>(), callback);
        ffi::SSL_CTX_set_stateless_cookie_verify_cb(
            self.as_ptr(),
            Some(raw_stateless_cookie_verify::<F>),
        )
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_cookie_generate_cb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_cookie_generate_cb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1544, End Line: 1552
/// Sets the callback for generating a DTLSv1 cookie
///
/// The callback will be called with the SSL context and a slice into which the cookie
/// should be written. The callback should return the number of bytes written.
#[corresponds(SSL_CTX_set_cookie_generate_cb)]
#[cfg(not(boringssl))]
pub fn set_cookie_generate_cb<F>(&mut self, callback: F)
where
    F: Fn(&mut SslRef, &mut [u8]) -> Result<usize, ErrorStack> + 'static + Sync + Send,
{
    unsafe {
        self.set_ex_data(SslContext::cached_ex_index::<F>(), callback);
        ffi::SSL_CTX_set_cookie_generate_cb(
            self.as_ptr(),
            Some(raw_cookie_generate::<F>),
        );
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_cookie_verify_cb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_cookie_verify_cb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1560, End Line: 1568
/// Sets the callback for verifying a DTLSv1 cookie
///
/// The callback will be called with the SSL context and the cookie supplied by the
/// client. It should return true if and only if the cookie is valid.
#[corresponds(SSL_CTX_set_cookie_verify_cb)]
#[cfg(not(boringssl))]
pub fn set_cookie_verify_cb<F>(&mut self, callback: F)
where
    F: Fn(&mut SslRef, &[u8]) -> bool + 'static + Sync + Send,
{
    unsafe {
        self.set_ex_data(SslContext::cached_ex_index::<F>(), callback);
        ffi::SSL_CTX_set_cookie_verify_cb(self.as_ptr(), Some(raw_cookie_verify::<F>));
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: set_ex_data_inner,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_ex_data_inner:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1580, End Line: 1592
fn set_ex_data_inner<T>(&mut self, index: Index<SslContext, T>, data: T) -> *mut c_void {
    match self.ex_data_mut(index) {
        Some(v) => {
            *v = data;
            (v as *mut T).cast()
        }
        _ => {
            unsafe {
                let data = Box::into_raw(Box::new(data)) as *mut c_void;
                ffi::SSL_CTX_set_ex_data(self.as_ptr(), index.as_raw(), data);
                data
            }
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: ex_data_mut,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in ex_data_mut:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1594, End Line: 1603
fn ex_data_mut<T>(&mut self, index: Index<SslContext, T>) -> Option<&mut T> {
    unsafe {
        let data = ffi::SSL_CTX_get_ex_data(self.as_ptr(), index.as_raw());
        if data.is_null() { None } else { Some(&mut *data.cast()) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: add_custom_ext,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in add_custom_ext:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1610, End Line: 1657
/// Adds a custom extension for a TLS/DTLS client or server for all supported protocol versions.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(SSL_CTX_add_custom_ext)]
#[cfg(ossl111)]
pub fn add_custom_ext<AddFn, ParseFn, T>(
    &mut self,
    ext_type: u16,
    context: ExtensionContext,
    add_cb: AddFn,
    parse_cb: ParseFn,
) -> Result<(), ErrorStack>
where
    AddFn: Fn(
            &mut SslRef,
            ExtensionContext,
            Option<(usize, &X509Ref)>,
        ) -> Result<Option<T>, SslAlert> + 'static + Sync + Send,
    T: AsRef<[u8]> + 'static + Sync + Send,
    ParseFn: Fn(
            &mut SslRef,
            ExtensionContext,
            &[u8],
            Option<(usize, &X509Ref)>,
        ) -> Result<(), SslAlert> + 'static + Sync + Send,
{
    let ret = unsafe {
        self.set_ex_data(SslContext::cached_ex_index::<AddFn>(), add_cb);
        self.set_ex_data(SslContext::cached_ex_index::<ParseFn>(), parse_cb);
        ffi::SSL_CTX_add_custom_ext(
            self.as_ptr(),
            ext_type as c_uint,
            context.bits(),
            Some(raw_custom_ext_add::<AddFn, T>),
            Some(raw_custom_ext_free::<T>),
            ptr::null_mut(),
            Some(raw_custom_ext_parse::<ParseFn>),
            ptr::null_mut(),
        )
    };
    if ret == 1 { Ok(()) } else { Err(ErrorStack::get()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_max_early_data,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_max_early_data:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1666, End Line: 1672
/// Sets the maximum amount of early data that will be accepted on incoming connections.
///
/// Defaults to 0.
///
/// Requires OpenSSL 1.1.1 or LibreSSL 3.4.0 or newer.
#[corresponds(SSL_CTX_set_max_early_data)]
#[cfg(any(ossl111, libressl340))]
pub fn set_max_early_data(&mut self, bytes: u32) -> Result<(), ErrorStack> {
    if unsafe { ffi::SSL_CTX_set_max_early_data(self.as_ptr(), bytes) } == 1 {
        Ok(())
    } else {
        Err(ErrorStack::get())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_client_hello_callback,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_client_hello_callback:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1679, End Line: 1694
/// Sets a callback which will be invoked just after the client's hello message is received.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(SSL_CTX_set_client_hello_cb)]
#[cfg(ossl111)]
pub fn set_client_hello_callback<F>(&mut self, callback: F)
where
    F: Fn(&mut SslRef, &mut SslAlert) -> Result<ClientHelloResponse, ErrorStack>
        + 'static + Sync + Send,
{
    unsafe {
        let ptr = self.set_ex_data_inner(SslContext::cached_ex_index::<F>(), callback);
        ffi::SSL_CTX_set_client_hello_cb(
            self.as_ptr(),
            Some(callbacks::raw_client_hello::<F>),
            ptr,
        );
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_session_cache_size,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_session_cache_size:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1701, End Line: 1705
/// Sets the context's session cache size limit, returning the previous limit.
///
/// A value of 0 means that the cache size is unbounded.
#[corresponds(SSL_CTX_sess_set_cache_size)]
#[allow(clippy::useless_conversion)]
pub fn set_session_cache_size(&mut self, size: i32) -> i64 {
    unsafe {
        ffi::SSL_CTX_sess_set_cache_size(self.as_ptr(), size as SslCacheSize)
            as SslCacheTy
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_sigalgs_list,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_sigalgs_list:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1712, End Line: 1718
/// Sets the context's supported signature algorithms.
///
/// Requires OpenSSL 1.0.2 or newer.
#[corresponds(SSL_CTX_set1_sigalgs_list)]
#[cfg(ossl102)]
pub fn set_sigalgs_list(&mut self, sigalgs: &str) -> Result<(), ErrorStack> {
    let sigalgs = CString::new(sigalgs).unwrap();
    unsafe {
        cvt(ffi::SSL_CTX_set1_sigalgs_list(self.as_ptr(), sigalgs.as_ptr()) as c_int)
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_groups_list,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_groups_list:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1725, End Line: 1730
/// Sets the context's supported elliptic curve groups.
///
/// Requires BoringSSL or OpenSSL 1.1.1 or LibreSSL 2.5.1 or newer.
#[corresponds(SSL_CTX_set1_groups_list)]
#[cfg(any(ossl111, boringssl, libressl251))]
pub fn set_groups_list(&mut self, groups: &str) -> Result<(), ErrorStack> {
    let groups = CString::new(groups).unwrap();
    unsafe {
        cvt(ffi::SSL_CTX_set1_groups_list(self.as_ptr(), groups.as_ptr()) as c_int)
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_num_tickets,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_num_tickets:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1738, End Line: 1740
/// Sets the number of TLS 1.3 session tickets that will be sent to a client after a full
/// handshake.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(SSL_CTX_set_num_tickets)]
#[cfg(ossl111)]
pub fn set_num_tickets(&mut self, num_tickets: usize) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::SSL_CTX_set_num_tickets(self.as_ptr(), num_tickets)).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_security_level,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_security_level:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1748, End Line: 1750
/// Set the context's security level to a value between 0 and 5, inclusive.
/// A security value of 0 allows allows all parameters and algorithms.
///
/// Requires OpenSSL 1.1.0 or newer.
#[corresponds(SSL_CTX_set_security_level)]
#[cfg(any(ossl110, libressl360))]
pub fn set_security_level(&mut self, level: u32) {
    unsafe { ffi::SSL_CTX_set_security_level(self.as_ptr(), level as c_int) }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: to_owned,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in to_owned:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1783, End Line: 1788
fn to_owned(&self) -> Self::Owned {
    unsafe {
        SSL_CTX_up_ref(self.as_ptr());
        SslContext::from_ptr(self.as_ptr())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: new_ex_index,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in new_ex_index:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1809, End Line: 1821
/// Returns a new extra data index.
///
/// Each invocation of this function is guaranteed to return a distinct index. These can be used
/// to store data in the context that can be retrieved later by callbacks, for example.
#[corresponds(SSL_CTX_get_ex_new_index)]
pub fn new_ex_index<T>() -> Result<Index<SslContext, T>, ErrorStack>
where
    T: 'static + Sync + Send,
{
    unsafe {
        ffi::init();
        #[cfg(boringssl)]
        let idx = cvt_n(get_new_idx(Some(free_data_box::<T>)))?;
        #[cfg(not(boringssl))]
        let idx = cvt_n(get_new_idx(free_data_box::<T>))?;
        Ok(Index::from_raw(idx))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: cached_ex_index,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in cached_ex_index:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1824, End Line: 1836
fn cached_ex_index<T>() -> Index<SslContext, T>
where
    T: 'static + Sync + Send,
{
    unsafe {
        let idx = *INDEXES
            .lock()
            .unwrap_or_else(|e| e.into_inner())
            .entry(TypeId::of::<T>())
            .or_insert_with(|| SslContext::new_ex_index::<T>().unwrap().as_raw());
        Index::from_raw(idx)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: certificate,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in certificate:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1845, End Line: 1850
/// Returns the certificate associated with this `SslContext`, if present.
///
/// Requires OpenSSL 1.0.2 or LibreSSL 2.7.0 or newer.
#[corresponds(SSL_CTX_get0_certificate)]
#[cfg(any(ossl102, libressl270))]
pub fn certificate(&self) -> Option<&X509Ref> {
    unsafe {
        let ptr = ffi::SSL_CTX_get0_certificate(self.as_ptr());
        X509Ref::from_const_ptr_opt(ptr)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: private_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in private_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1857, End Line: 1862
/// Returns the private key associated with this `SslContext`, if present.
///
/// Requires OpenSSL 1.0.2 or LibreSSL 3.4.0 or newer.
#[corresponds(SSL_CTX_get0_privatekey)]
#[cfg(any(ossl102, libressl340))]
pub fn private_key(&self) -> Option<&PKeyRef<Private>> {
    unsafe {
        let ptr = ffi::SSL_CTX_get0_privatekey(self.as_ptr());
        PKeyRef::from_const_ptr_opt(ptr)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: extra_chain_certs,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in extra_chain_certs:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1872, End Line: 1878
/// Returns a shared reference to the stack of certificates making up the chain from the leaf.
#[corresponds(SSL_CTX_get_extra_chain_certs)]
pub fn extra_chain_certs(&self) -> &StackRef<X509> {
    unsafe {
        let mut chain = ptr::null_mut();
        ffi::SSL_CTX_get_extra_chain_certs(self.as_ptr(), &mut chain);
        StackRef::from_const_ptr_opt(chain).expect("extra chain certs must not be null")
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: ex_data,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in ex_data:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1882, End Line: 1891
/// Returns a reference to the extra data at the specified index.
#[corresponds(SSL_CTX_get_ex_data)]
pub fn ex_data<T>(&self, index: Index<SslContext, T>) -> Option<&T> {
    unsafe {
        let data = ffi::SSL_CTX_get_ex_data(self.as_ptr(), index.as_raw());
        if data.is_null() { None } else { Some(&*(data as *const T)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: max_early_data,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in max_early_data:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1898, End Line: 1900
/// Gets the maximum amount of early data that will be accepted on incoming connections.
///
/// Requires OpenSSL 1.1.1 or LibreSSL 3.4.0 or newer.
#[corresponds(SSL_CTX_get_max_early_data)]
#[cfg(any(ossl111, libressl340))]
pub fn max_early_data(&self) -> u32 {
    unsafe { ffi::SSL_CTX_get_max_early_data(self.as_ptr()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: session_cache_size,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in session_cache_size:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1933, End Line: 1935
/// Returns the context's session cache size limit.
///
/// A value of 0 means that the cache size is unbounded.
#[corresponds(SSL_CTX_sess_get_cache_size)]
#[allow(clippy::unnecessary_cast)]
pub fn session_cache_size(&self) -> i64 {
    unsafe { ffi::SSL_CTX_sess_get_cache_size(self.as_ptr()) as i64 }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: verify_mode,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in verify_mode:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1941, End Line: 1944
/// Returns the verify mode that was set on this context from [`SslContextBuilder::set_verify`].
///
/// [`SslContextBuilder::set_verify`]: struct.SslContextBuilder.html#method.set_verify
#[corresponds(SSL_CTX_get_verify_mode)]
pub fn verify_mode(&self) -> SslVerifyMode {
    let mode = unsafe { ffi::SSL_CTX_get_verify_mode(self.as_ptr()) };
    SslVerifyMode::from_bits(mode)
        .expect("SSL_CTX_get_verify_mode returned invalid mode")
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: num_tickets,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in num_tickets:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1952, End Line: 1954
/// Gets the number of TLS 1.3 session tickets that will be sent to a client after a full
/// handshake.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(SSL_CTX_get_num_tickets)]
#[cfg(ossl111)]
pub fn num_tickets(&self) -> usize {
    unsafe { ffi::SSL_CTX_get_num_tickets(self.as_ptr()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: security_level,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in security_level:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 1962, End Line: 1964
/// Get the context's security level, which controls the allowed parameters
/// and algorithms.
///
/// Requires OpenSSL 1.1.0 or newer.
#[corresponds(SSL_CTX_get_security_level)]
#[cfg(any(ossl110, libressl360))]
pub fn security_level(&self) -> u32 {
    unsafe { ffi::SSL_CTX_get_security_level(self.as_ptr()) as u32 }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: deref,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in deref:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2001, End Line: 2003
fn deref(&self) -> &SslCipherRef {
    unsafe { SslCipherRef::from_ptr(self.0) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: deref_mut,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in deref_mut:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2007, End Line: 2009
fn deref_mut(&mut self) -> &mut SslCipherRef {
    unsafe { SslCipherRef::from_ptr_mut(self.0) }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: name,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in name:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2024, End Line: 2029
/// Returns the name of the cipher.
#[corresponds(SSL_CIPHER_get_name)]
pub fn name(&self) -> &'static str {
    unsafe {
        let ptr = ffi::SSL_CIPHER_get_name(self.as_ptr());
        CStr::from_ptr(ptr).to_str().unwrap()
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: standard_name,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in standard_name:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2036, End Line: 2045
/// Returns the RFC-standard name of the cipher, if one exists.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(SSL_CIPHER_standard_name)]
#[cfg(ossl111)]
pub fn standard_name(&self) -> Option<&'static str> {
    unsafe {
        let ptr = ffi::SSL_CIPHER_standard_name(self.as_ptr());
        if ptr.is_null() { None } else { Some(CStr::from_ptr(ptr).to_str().unwrap()) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: version,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in version:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2049, End Line: 2056
/// Returns the SSL/TLS protocol version that first defined the cipher.
#[corresponds(SSL_CIPHER_get_version)]
pub fn version(&self) -> &'static str {
    let version = unsafe {
        let ptr = ffi::SSL_CIPHER_get_version(self.as_ptr());
        CStr::from_ptr(ptr as *const _)
    };
    str::from_utf8(version.to_bytes()).unwrap()
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: bits,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in bits:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2061, End Line: 2070
/// Returns the number of bits used for the cipher.
#[corresponds(SSL_CIPHER_get_bits)]
#[allow(clippy::useless_conversion)]
pub fn bits(&self) -> CipherBits {
    unsafe {
        let mut algo_bits = 0;
        let secret_bits = ffi::SSL_CIPHER_get_bits(self.as_ptr(), &mut algo_bits);
        CipherBits {
            secret: secret_bits.into(),
            algorithm: algo_bits.into(),
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: description,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in description:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2074, End Line: 2081
/// Returns a textual description of the cipher.
#[corresponds(SSL_CIPHER_description)]
pub fn description(&self) -> String {
    unsafe {
        let mut buf = [0; 128];
        let ptr = ffi::SSL_CIPHER_description(self.as_ptr(), buf.as_mut_ptr(), 128);
        String::from_utf8(CStr::from_ptr(ptr as *const _).to_bytes().to_vec()).unwrap()
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: handshake_digest,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in handshake_digest:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2088, End Line: 2097
/// Returns the handshake digest of the cipher.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(SSL_CIPHER_get_handshake_digest)]
#[cfg(ossl111)]
pub fn handshake_digest(&self) -> Option<MessageDigest> {
    unsafe {
        let ptr = ffi::SSL_CIPHER_get_handshake_digest(self.as_ptr());
        if ptr.is_null() { None } else { Some(MessageDigest::from_ptr(ptr)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cipher_nid,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in cipher_nid:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2104, End Line: 2111
/// Returns the NID corresponding to the cipher.
///
/// Requires OpenSSL 1.1.0 or LibreSSL 2.7.0 or newer.
#[corresponds(SSL_CIPHER_get_cipher_nid)]
#[cfg(any(ossl110, libressl270))]
pub fn cipher_nid(&self) -> Option<Nid> {
    let n = unsafe { ffi::SSL_CIPHER_get_cipher_nid(self.as_ptr()) };
    if n == 0 { None } else { Some(Nid::from_raw(n)) }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: id,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in id:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2172, End Line: 2179
/// Returns the SSL session ID.
#[corresponds(SSL_SESSION_get_id)]
pub fn id(&self) -> &[u8] {
    unsafe {
        let mut len = 0;
        let p = ffi::SSL_SESSION_get_id(self.as_ptr(), &mut len);
        #[allow(clippy::unnecessary_cast)]
        slice::from_raw_parts(p as *const u8, len as usize)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: master_key_len,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in master_key_len:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2183, End Line: 2185
/// Returns the length of the master key.
#[corresponds(SSL_SESSION_get_master_key)]
pub fn master_key_len(&self) -> usize {
    unsafe { SSL_SESSION_get_master_key(self.as_ptr(), ptr::null_mut(), 0) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: master_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in master_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2191, End Line: 2193
/// Copies the master key into the provided buffer.
///
/// Returns the number of bytes written, or the size of the master key if the buffer is empty.
#[corresponds(SSL_SESSION_get_master_key)]
pub fn master_key(&self, buf: &mut [u8]) -> usize {
    unsafe { SSL_SESSION_get_master_key(self.as_ptr(), buf.as_mut_ptr(), buf.len()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: time,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in time:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2207, End Line: 2209
/// Returns the time at which the session was established, in seconds since the Unix epoch.
#[corresponds(SSL_SESSION_get_time)]
#[allow(clippy::useless_conversion)]
pub fn time(&self) -> SslTimeTy {
    unsafe { ffi::SSL_SESSION_get_time(self.as_ptr()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: timeout,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in timeout:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2216, End Line: 2218
/// Returns the sessions timeout, in seconds.
///
/// A session older than this time should not be used for session resumption.
#[corresponds(SSL_SESSION_get_timeout)]
#[allow(clippy::useless_conversion)]
pub fn timeout(&self) -> i64 {
    unsafe { ffi::SSL_SESSION_get_timeout(self.as_ptr()).into() }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: protocol_version,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in protocol_version:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2225, End Line: 2230
/// Returns the session's TLS protocol version.
///
/// Requires OpenSSL 1.1.0 or LibreSSL 2.7.0 or newer.
#[corresponds(SSL_SESSION_get_protocol_version)]
#[cfg(any(ossl110, libressl270))]
pub fn protocol_version(&self) -> SslVersion {
    unsafe {
        let version = ffi::SSL_SESSION_get_protocol_version(self.as_ptr());
        SslVersion(version)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: get_raw_rbio,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in get_raw_rbio:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2365, End Line: 2367
fn get_raw_rbio(&self) -> *mut ffi::BIO {
    unsafe { ffi::SSL_get_rbio(self.as_ptr()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: get_error,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in get_error:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2369, End Line: 2371
fn get_error(&self, ret: c_int) -> ErrorCode {
    unsafe { ErrorCode::from_raw(ffi::SSL_get_error(self.as_ptr(), ret)) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_connect_state,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_connect_state:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2375, End Line: 2377
/// Configure as an outgoing stream from a client.
#[corresponds(SSL_set_connect_state)]
pub fn set_connect_state(&mut self) {
    unsafe { ffi::SSL_set_connect_state(self.as_ptr()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_accept_state,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_accept_state:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2381, End Line: 2383
/// Configure as an incoming stream to a server.
#[corresponds(SSL_set_accept_state)]
pub fn set_accept_state(&mut self) {
    unsafe { ffi::SSL_set_accept_state(self.as_ptr()) }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: current_cipher,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in current_cipher:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2504, End Line: 2510
/// Returns the current cipher if the session is active.
#[corresponds(SSL_get_current_cipher)]
pub fn current_cipher(&self) -> Option<&SslCipherRef> {
    unsafe {
        let ptr = ffi::SSL_get_current_cipher(self.as_ptr());
        SslCipherRef::from_const_ptr_opt(ptr)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: state_string,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in state_string:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2514, End Line: 2521
/// Returns a short string describing the state of the session.
#[corresponds(SSL_state_string)]
pub fn state_string(&self) -> &'static str {
    let state = unsafe {
        let ptr = ffi::SSL_state_string(self.as_ptr());
        CStr::from_ptr(ptr as *const _)
    };
    str::from_utf8(state.to_bytes()).unwrap()
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: state_string_long,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in state_string_long:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2525, End Line: 2532
/// Returns a longer string describing the state of the session.
#[corresponds(SSL_state_string_long)]
pub fn state_string_long(&self) -> &'static str {
    let state = unsafe {
        let ptr = ffi::SSL_state_string_long(self.as_ptr());
        CStr::from_ptr(ptr as *const _)
    };
    str::from_utf8(state.to_bytes()).unwrap()
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_hostname,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_hostname:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2538, End Line: 2544
/// Sets the host name to be sent to the server for Server Name Indication (SNI).
///
/// It has no effect for a server-side connection.
#[corresponds(SSL_set_tlsext_host_name)]
pub fn set_hostname(&mut self, hostname: &str) -> Result<(), ErrorStack> {
    let cstr = CString::new(hostname).unwrap();
    unsafe {
        cvt(
                ffi::SSL_set_tlsext_host_name(self.as_ptr(), cstr.as_ptr() as *mut _)
                    as c_int,
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: peer_certificate,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in peer_certificate:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2548, End Line: 2553
/// Returns the peer's certificate, if present.
#[corresponds(SSL_get_peer_certificate)]
pub fn peer_certificate(&self) -> Option<X509> {
    unsafe {
        let ptr = SSL_get1_peer_certificate(self.as_ptr());
        X509::from_ptr_opt(ptr)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: peer_cert_chain,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in peer_cert_chain:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2560, End Line: 2565
/// Returns the certificate chain of the peer, if present.
///
/// On the client side, the chain includes the leaf certificate, but on the server side it does
/// not. Fun!
#[corresponds(SSL_get_peer_cert_chain)]
pub fn peer_cert_chain(&self) -> Option<&StackRef<X509>> {
    unsafe {
        let ptr = ffi::SSL_get_peer_cert_chain(self.as_ptr());
        StackRef::from_const_ptr_opt(ptr)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: verified_chain,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in verified_chain:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2578, End Line: 2583
/// Returns the verified certificate chain of the peer, including the leaf certificate.
///
/// If verification was not successful (i.e. [`verify_result`] does not return
/// [`X509VerifyResult::OK`]), this chain may be incomplete or invalid.
///
/// Requires OpenSSL 1.1.0 or newer.
///
/// [`verify_result`]: #method.verify_result
/// [`X509VerifyResult::OK`]: ../x509/struct.X509VerifyResult.html#associatedconstant.OK
#[corresponds(SSL_get0_verified_chain)]
#[cfg(ossl110)]
pub fn verified_chain(&self) -> Option<&StackRef<X509>> {
    unsafe {
        let ptr = ffi::SSL_get0_verified_chain(self.as_ptr());
        StackRef::from_const_ptr_opt(ptr)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: version2,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in version2:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2612, End Line: 2621
/// Returns the protocol version of the session.
#[corresponds(SSL_version)]
pub fn version2(&self) -> Option<SslVersion> {
    unsafe {
        let r = ffi::SSL_version(self.as_ptr());
        if r == 0 { None } else { Some(SslVersion(r)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: version_str,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in version_str:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2625, End Line: 2632
/// Returns a string describing the protocol version of the session.
#[corresponds(SSL_get_version)]
pub fn version_str(&self) -> &'static str {
    let version = unsafe {
        let ptr = ffi::SSL_get_version(self.as_ptr());
        CStr::from_ptr(ptr as *const _)
    };
    str::from_utf8(version.to_bytes()).unwrap()
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: true, With_SAFETY_comment: false, Name: selected_alpn_protocol,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in selected_alpn_protocol:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2642, End Line: 2656
/// Returns the protocol selected via Application Layer Protocol Negotiation (ALPN).
///
/// The protocol's name is returned is an opaque sequence of bytes. It is up to the client
/// to interpret it.
///
/// Requires BoringSSL or OpenSSL 1.0.2 or LibreSSL 2.6.1 or newer.
#[corresponds(SSL_get0_alpn_selected)]
#[cfg(any(ossl102, libressl261, boringssl))]
pub fn selected_alpn_protocol(&self) -> Option<&[u8]> {
    unsafe {
        let mut data: *const c_uchar = ptr::null();
        let mut len: c_uint = 0;
        ffi::SSL_get0_alpn_selected(self.as_ptr(), &mut data, &mut len);
        if data.is_null() {
            None
        } else {
            Some(slice::from_raw_parts(data, len as usize))
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: srtp_profiles,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in srtp_profiles:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2686, End Line: 2692
/// Gets all SRTP profiles that are enabled for handshake via set_tlsext_use_srtp
///
/// DTLS extension "use_srtp" as defined in RFC5764 has to be enabled.
///
/// This corresponds to [`SSL_get_srtp_profiles`].
///
/// [`SSL_get_srtp_profiles`]: https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_tlsext_use_srtp.html
#[corresponds(SSL_get_srtp_profiles)]
pub fn srtp_profiles(&self) -> Option<&StackRef<SrtpProtectionProfile>> {
    unsafe {
        let chain = ffi::SSL_get_srtp_profiles(self.as_ptr());
        StackRef::from_const_ptr_opt(chain)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: selected_srtp_profile,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in selected_srtp_profile:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2698, End Line: 2704
/// Gets the SRTP profile selected by handshake.
///
/// DTLS extension "use_srtp" as defined in RFC5764 has to be enabled.
#[corresponds(SSL_get_selected_srtp_profile)]
pub fn selected_srtp_profile(&self) -> Option<&SrtpProtectionProfileRef> {
    unsafe {
        let profile = ffi::SSL_get_selected_srtp_profile(self.as_ptr());
        SrtpProtectionProfileRef::from_const_ptr_opt(profile)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: pending,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in pending:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2711, End Line: 2713
/// Returns the number of bytes remaining in the currently processed TLS record.
///
/// If this is greater than 0, the next call to `read` will not call down to the underlying
/// stream.
#[corresponds(SSL_pending)]
pub fn pending(&self) -> usize {
    unsafe { ffi::SSL_pending(self.as_ptr()) as usize }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: servername_raw,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in servername_raw:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2742, End Line: 2751
/// Returns the servername sent by the client via Server Name Indication (SNI).
///
/// It is only useful on the server side.
///
/// # Note
///
/// Unlike `servername`, this method does not require the name be valid UTF-8.
#[corresponds(SSL_get_servername)]
pub fn servername_raw(&self, type_: NameType) -> Option<&[u8]> {
    unsafe {
        let name = ffi::SSL_get_servername(self.as_ptr(), type_.0);
        if name.is_null() {
            None
        } else {
            Some(CStr::from_ptr(name as *const _).to_bytes())
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_ssl_context,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_ssl_context:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2757, End Line: 2759
/// Changes the context corresponding to the current connection.
///
/// It is most commonly used in the Server Name Indication (SNI) callback.
#[corresponds(SSL_set_SSL_CTX)]
pub fn set_ssl_context(&mut self, ctx: &SslContextRef) -> Result<(), ErrorStack> {
    unsafe { cvt_p(ffi::SSL_set_SSL_CTX(self.as_ptr(), ctx.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: ssl_context,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in ssl_context:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2763, End Line: 2768
/// Returns the context corresponding to the current connection.
#[corresponds(SSL_get_SSL_CTX)]
pub fn ssl_context(&self) -> &SslContextRef {
    unsafe {
        let ssl_ctx = ffi::SSL_get_SSL_CTX(self.as_ptr());
        SslContextRef::from_ptr(ssl_ctx)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: param_mut,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in param_mut:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2775, End Line: 2777
/// Returns a mutable reference to the X509 verification configuration.
///
/// Requires BoringSSL or OpenSSL 1.0.2 or newer.
#[corresponds(SSL_get0_param)]
#[cfg(any(ossl102, boringssl, libressl261))]
pub fn param_mut(&mut self) -> &mut X509VerifyParamRef {
    unsafe { X509VerifyParamRef::from_ptr_mut(ffi::SSL_get0_param(self.as_ptr())) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: verify_result,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in verify_result:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2781, End Line: 2783
/// Returns the certificate verification result.
#[corresponds(SSL_get_verify_result)]
pub fn verify_result(&self) -> X509VerifyResult {
    unsafe {
        X509VerifyResult::from_raw(ffi::SSL_get_verify_result(self.as_ptr()) as c_int)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: session,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in session:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2787, End Line: 2792
/// Returns a shared reference to the SSL session.
#[corresponds(SSL_get_session)]
pub fn session(&self) -> Option<&SslSessionRef> {
    unsafe {
        let p = ffi::SSL_get_session(self.as_ptr());
        SslSessionRef::from_const_ptr_opt(p)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: client_random,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in client_random:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2802, End Line: 2806
/// Copies the `client_random` value sent by the client in the TLS handshake into a buffer.
///
/// Returns the number of bytes copied, or if the buffer is empty, the size of the `client_random`
/// value.
///
/// Requires OpenSSL 1.1.0 or LibreSSL 2.7.0 or newer.
#[corresponds(SSL_get_client_random)]
#[cfg(any(ossl110, libressl270))]
pub fn client_random(&self, buf: &mut [u8]) -> usize {
    unsafe {
        ffi::SSL_get_client_random(
            self.as_ptr(),
            buf.as_mut_ptr() as *mut c_uchar,
            buf.len(),
        )
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: server_random,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in server_random:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2816, End Line: 2820
/// Copies the `server_random` value sent by the server in the TLS handshake into a buffer.
///
/// Returns the number of bytes copied, or if the buffer is empty, the size of the `server_random`
/// value.
///
/// Requires OpenSSL 1.1.0 or LibreSSL 2.7.0 or newer.
#[corresponds(SSL_get_server_random)]
#[cfg(any(ossl110, libressl270))]
pub fn server_random(&self, buf: &mut [u8]) -> usize {
    unsafe {
        ffi::SSL_get_server_random(
            self.as_ptr(),
            buf.as_mut_ptr() as *mut c_uchar,
            buf.len(),
        )
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: export_keying_material,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in export_keying_material:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2824, End Line: 2847
/// Derives keying material for application use in accordance to RFC 5705.
#[corresponds(SSL_export_keying_material)]
pub fn export_keying_material(
    &self,
    out: &mut [u8],
    label: &str,
    context: Option<&[u8]>,
) -> Result<(), ErrorStack> {
    unsafe {
        let (context, contextlen, use_context) = match context {
            Some(context) => (context.as_ptr() as *const c_uchar, context.len(), 1),
            None => (ptr::null(), 0, 0),
        };
        cvt(
                ffi::SSL_export_keying_material(
                    self.as_ptr(),
                    out.as_mut_ptr() as *mut c_uchar,
                    out.len(),
                    label.as_ptr() as *const c_char,
                    label.len(),
                    context,
                    contextlen,
                    use_context,
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: export_keying_material_early,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in export_keying_material_early:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2857, End Line: 2875
/// Derives keying material for application use in accordance to RFC 5705.
///
/// This function is only usable with TLSv1.3, wherein there is no distinction between an empty context and no
/// context. Therefore, unlike `export_keying_material`, `context` must always be supplied.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(SSL_export_keying_material_early)]
#[cfg(ossl111)]
pub fn export_keying_material_early(
    &self,
    out: &mut [u8],
    label: &str,
    context: &[u8],
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(
                ffi::SSL_export_keying_material_early(
                    self.as_ptr(),
                    out.as_mut_ptr() as *mut c_uchar,
                    out.len(),
                    label.as_ptr() as *const c_char,
                    label.len(),
                    context.as_ptr() as *const c_uchar,
                    context.len(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: session_reused,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in session_reused:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2894, End Line: 2896
/// Determines if the session provided to `set_session` was successfully reused.
#[corresponds(SSL_session_reused)]
pub fn session_reused(&self) -> bool {
    unsafe { ffi::SSL_session_reused(self.as_ptr()) != 0 }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_status_type,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_status_type:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2900, End Line: 2904
/// Sets the status response a client wishes the server to reply with.
#[corresponds(SSL_set_tlsext_status_type)]
pub fn set_status_type(&mut self, type_: StatusType) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::SSL_set_tlsext_status_type(self.as_ptr(), type_.as_raw()) as c_int)
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: extms_support,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in extms_support:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2911, End Line: 2918
/// Determines if current session used Extended Master Secret
///
/// Returns `None` if the handshake is still in-progress.
#[corresponds(SSL_get_extms_support)]
#[cfg(ossl110)]
pub fn extms_support(&self) -> Option<bool> {
    unsafe {
        match ffi::SSL_get_extms_support(self.as_ptr()) {
            -1 => None,
            ret => Some(ret != 0),
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: true, With_SAFETY_comment: false, Name: ocsp_status,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in ocsp_status:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2923, End Line: 2934
/// Returns the server's OCSP response, if present.
#[corresponds(SSL_get_tlsext_status_ocsp_resp)]
#[cfg(not(boringssl))]
pub fn ocsp_status(&self) -> Option<&[u8]> {
    unsafe {
        let mut p = ptr::null_mut();
        let len = ffi::SSL_get_tlsext_status_ocsp_resp(self.as_ptr(), &mut p);
        if len < 0 {
            None
        } else {
            Some(slice::from_raw_parts(p as *const u8, len as usize))
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: set_ocsp_status,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_ocsp_status:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2939, End Line: 2955
/// Sets the OCSP response to be returned to the client.
#[corresponds(SSL_set_tlsext_status_oscp_resp)]
#[cfg(not(boringssl))]
pub fn set_ocsp_status(&mut self, response: &[u8]) -> Result<(), ErrorStack> {
    unsafe {
        assert!(response.len() <= c_int::MAX as usize);
        let p = cvt_p(ffi::OPENSSL_malloc(response.len() as _))?;
        ptr::copy_nonoverlapping(response.as_ptr(), p as *mut u8, response.len());
        cvt(
                ffi::SSL_set_tlsext_status_ocsp_resp(
                    self.as_ptr(),
                    p as *mut c_uchar,
                    response.len() as c_long,
                ) as c_int,
            )
            .map(|_| ())
            .map_err(|e| {
                ffi::OPENSSL_free(p);
                e
            })
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: is_server,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in is_server:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 2959, End Line: 2961
/// Determines if this `Ssl` is configured for server-side or client-side use.
#[corresponds(SSL_is_server)]
pub fn is_server(&self) -> bool {
    unsafe { SSL_is_server(self.as_ptr()) != 0 }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: finished,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in finished:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3036, End Line: 3038
/// Copies the contents of the last Finished message sent to the peer into the provided buffer.
///
/// The total size of the message is returned, so this can be used to determine the size of the
/// buffer required.
#[corresponds(SSL_get_finished)]
pub fn finished(&self, buf: &mut [u8]) -> usize {
    unsafe {
        ffi::SSL_get_finished(self.as_ptr(), buf.as_mut_ptr() as *mut c_void, buf.len())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: peer_finished,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in peer_finished:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3046, End Line: 3050
/// Copies the contents of the last Finished message received from the peer into the provided
/// buffer.
///
/// The total size of the message is returned, so this can be used to determine the size of the
/// buffer required.
#[corresponds(SSL_get_peer_finished)]
pub fn peer_finished(&self, buf: &mut [u8]) -> usize {
    unsafe {
        ffi::SSL_get_peer_finished(
            self.as_ptr(),
            buf.as_mut_ptr() as *mut c_void,
            buf.len(),
        )
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: is_init_finished,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in is_init_finished:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3055, End Line: 3057
/// Determines if the initial handshake has been completed.
#[corresponds(SSL_is_init_finished)]
#[cfg(ossl110)]
pub fn is_init_finished(&self) -> bool {
    unsafe { ffi::SSL_is_init_finished(self.as_ptr()) != 0 }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: client_hello_isv2,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in client_hello_isv2:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3066, End Line: 3068
/// Determines if the client's hello message is in the SSLv2 format.
///
/// This can only be used inside of the client hello callback. Otherwise, `false` is returned.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(SSL_client_hello_isv2)]
#[cfg(ossl111)]
pub fn client_hello_isv2(&self) -> bool {
    unsafe { ffi::SSL_client_hello_isv2(self.as_ptr()) != 0 }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: client_hello_legacy_version,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in client_hello_legacy_version:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3077, End Line: 3086
/// Returns the legacy version field of the client's hello message.
///
/// This can only be used inside of the client hello callback. Otherwise, `None` is returned.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(SSL_client_hello_get0_legacy_version)]
#[cfg(ossl111)]
pub fn client_hello_legacy_version(&self) -> Option<SslVersion> {
    unsafe {
        let version = ffi::SSL_client_hello_get0_legacy_version(self.as_ptr());
        if version == 0 { None } else { Some(SslVersion(version as c_int)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: true, With_SAFETY_comment: false, Name: client_hello_random,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in client_hello_random:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3095, End Line: 3105
/// Returns the random field of the client's hello message.
///
/// This can only be used inside of the client hello callback. Otherwise, `None` is returned.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(SSL_client_hello_get0_random)]
#[cfg(ossl111)]
pub fn client_hello_random(&self) -> Option<&[u8]> {
    unsafe {
        let mut ptr = ptr::null();
        let len = ffi::SSL_client_hello_get0_random(self.as_ptr(), &mut ptr);
        if len == 0 { None } else { Some(slice::from_raw_parts(ptr, len)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: true, With_SAFETY_comment: false, Name: client_hello_session_id,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in client_hello_session_id:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3114, End Line: 3124
/// Returns the session ID field of the client's hello message.
///
/// This can only be used inside of the client hello callback. Otherwise, `None` is returned.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(SSL_client_hello_get0_session_id)]
#[cfg(ossl111)]
pub fn client_hello_session_id(&self) -> Option<&[u8]> {
    unsafe {
        let mut ptr = ptr::null();
        let len = ffi::SSL_client_hello_get0_session_id(self.as_ptr(), &mut ptr);
        if len == 0 { None } else { Some(slice::from_raw_parts(ptr, len)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: true, With_SAFETY_comment: false, Name: client_hello_ciphers,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in client_hello_ciphers:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3133, End Line: 3143
/// Returns the ciphers field of the client's hello message.
///
/// This can only be used inside of the client hello callback. Otherwise, `None` is returned.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(SSL_client_hello_get0_ciphers)]
#[cfg(ossl111)]
pub fn client_hello_ciphers(&self) -> Option<&[u8]> {
    unsafe {
        let mut ptr = ptr::null();
        let len = ffi::SSL_client_hello_get0_ciphers(self.as_ptr(), &mut ptr);
        if len == 0 { None } else { Some(slice::from_raw_parts(ptr, len)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 6 statements, Complex: true, With_SAFETY_comment: false, Name: bytes_to_cipher_list,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in bytes_to_cipher_list:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3151, End Line: 3178
/// Decodes a slice of wire-format cipher suite specification bytes. Unsupported cipher suites
/// are ignored.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(SSL_bytes_to_cipher_list)]
#[cfg(ossl111)]
pub fn bytes_to_cipher_list(
    &self,
    bytes: &[u8],
    isv2format: bool,
) -> Result<CipherLists, ErrorStack> {
    unsafe {
        let ptr = bytes.as_ptr();
        let len = bytes.len();
        let mut sk = ptr::null_mut();
        let mut scsvs = ptr::null_mut();
        let res = ffi::SSL_bytes_to_cipher_list(
            self.as_ptr(),
            ptr,
            len,
            isv2format as c_int,
            &mut sk,
            &mut scsvs,
        );
        if res == 1 {
            Ok(CipherLists {
                suites: Stack::from_ptr(sk),
                signalling_suites: Stack::from_ptr(scsvs),
            })
        } else {
            Err(ErrorStack::get())
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: true, With_SAFETY_comment: false, Name: client_hello_compression_methods,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in client_hello_compression_methods:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3187, End Line: 3197
/// Returns the compression methods field of the client's hello message.
///
/// This can only be used inside of the client hello callback. Otherwise, `None` is returned.
///
/// Requires OpenSSL 1.1.1 or newer.
#[corresponds(SSL_client_hello_get0_compression_methods)]
#[cfg(ossl111)]
pub fn client_hello_compression_methods(&self) -> Option<&[u8]> {
    unsafe {
        let mut ptr = ptr::null();
        let len = ffi::SSL_client_hello_get0_compression_methods(
            self.as_ptr(),
            &mut ptr,
        );
        if len == 0 { None } else { Some(slice::from_raw_parts(ptr, len)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_mtu,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_mtu:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3201, End Line: 3203
/// Sets the MTU used for DTLS connections.
#[corresponds(SSL_set_mtu)]
pub fn set_mtu(&mut self, mtu: u32) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::SSL_set_mtu(self.as_ptr(), mtu as MtuTy) as c_int).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: psk_identity_hint,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in psk_identity_hint:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3210, End Line: 3219
/// Returns the PSK identity hint used during connection setup.
///
/// May return `None` if no PSK identity hint was used during the connection setup.
#[corresponds(SSL_get_psk_identity_hint)]
#[cfg(not(osslconf = "OPENSSL_NO_PSK"))]
pub fn psk_identity_hint(&self) -> Option<&[u8]> {
    unsafe {
        let ptr = ffi::SSL_get_psk_identity_hint(self.as_ptr());
        if ptr.is_null() { None } else { Some(CStr::from_ptr(ptr).to_bytes()) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: psk_identity,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in psk_identity:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3224, End Line: 3233
/// Returns the PSK identity used during connection setup.
#[corresponds(SSL_get_psk_identity)]
#[cfg(not(osslconf = "OPENSSL_NO_PSK"))]
pub fn psk_identity(&self) -> Option<&[u8]> {
    unsafe {
        let ptr = ffi::SSL_get_psk_identity(self.as_ptr());
        if ptr.is_null() { None } else { Some(CStr::from_ptr(ptr).to_bytes()) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: add_chain_cert,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in add_chain_cert:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3237, End Line: 3243
#[corresponds(SSL_add0_chain_cert)]
#[cfg(ossl102)]
pub fn add_chain_cert(&mut self, chain: X509) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::SSL_add0_chain_cert(self.as_ptr(), chain.as_ptr()) as c_int)
            .map(|_| ())?;
        mem::forget(chain);
    }
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_method,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_method:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3247, End Line: 3252
/// Sets a new default TLS/SSL method for SSL objects
#[cfg(not(boringssl))]
pub fn set_method(&mut self, method: SslMethod) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::SSL_set_ssl_method(self.as_ptr(), method.as_ptr()))?;
    };
    Ok(())
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: peer_tmp_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in peer_tmp_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3462, End Line: 3470
/// Get the temporary key provided by the peer that is used during key
/// exchange.
#[corresponds(SSL_get_peer_tmp_key)]
#[cfg(ossl300)]
pub fn peer_tmp_key(&self) -> Result<PKey<Public>, ErrorStack> {
    unsafe {
        let mut key = ptr::null_mut();
        match cvt_long(ffi::SSL_get_peer_tmp_key(self.as_ptr(), &mut key)) {
            Ok(_) => Ok(PKey::<Public>::from_ptr(key)),
            Err(e) => Err(e),
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: tmp_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in tmp_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3478, End Line: 3486
/// Returns the temporary key from the local end of the connection that is
/// used during key exchange.
#[corresponds(SSL_get_tmp_key)]
#[cfg(ossl300)]
pub fn tmp_key(&self) -> Result<PKey<Private>, ErrorStack> {
    unsafe {
        let mut key = ptr::null_mut();
        match cvt_long(ffi::SSL_get_tmp_key(self.as_ptr(), &mut key)) {
            Ok(_) => Ok(PKey::<Private>::from_ptr(key)),
            Err(e) => Err(e),
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: drop,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in drop:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3556, End Line: 3562
fn drop(&mut self) {
    unsafe {
        ManuallyDrop::drop(&mut self.ssl);
        ManuallyDrop::drop(&mut self.method);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: read_early_data,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in read_early_data:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3625, End Line: 3641
/// Read application data transmitted by a client before handshake completion.
///
/// Useful for reducing latency, but vulnerable to replay attacks. Call
/// [`SslRef::set_accept_state`] first.
///
/// Returns `Ok(0)` if all early data has been read.
///
/// Requires OpenSSL 1.1.1 or LibreSSL 3.4.0 or newer.
#[corresponds(SSL_read_early_data)]
#[cfg(any(ossl111, libressl340))]
pub fn read_early_data(&mut self, buf: &mut [u8]) -> Result<usize, Error> {
    let mut read = 0;
    let ret = unsafe {
        ffi::SSL_read_early_data(
            self.ssl.as_ptr(),
            buf.as_ptr() as *mut c_void,
            buf.len(),
            &mut read,
        )
    };
    match ret {
        ffi::SSL_READ_EARLY_DATA_ERROR => Err(self.make_error(ret)),
        ffi::SSL_READ_EARLY_DATA_SUCCESS => Ok(read),
        ffi::SSL_READ_EARLY_DATA_FINISH => Ok(0),
        _ => unreachable!(),
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: write_early_data,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in write_early_data:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3651, End Line: 3666
/// Send data to the server without blocking on handshake completion.
///
/// Useful for reducing latency, but vulnerable to replay attacks. Call
/// [`SslRef::set_connect_state`] first.
///
/// Requires OpenSSL 1.1.1 or LibreSSL 3.4.0 or newer.
#[corresponds(SSL_write_early_data)]
#[cfg(any(ossl111, libressl340))]
pub fn write_early_data(&mut self, buf: &[u8]) -> Result<usize, Error> {
    let mut written = 0;
    let ret = unsafe {
        ffi::SSL_write_early_data(
            self.ssl.as_ptr(),
            buf.as_ptr() as *const c_void,
            buf.len(),
            &mut written,
        )
    };
    if ret > 0 { Ok(written) } else { Err(self.make_error(ret)) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: do_handshake,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in do_handshake:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3704, End Line: 3711
/// Initiates the handshake.
///
/// This will fail if `set_accept_state` or `set_connect_state` was not called first.
#[corresponds(SSL_do_handshake)]
pub fn do_handshake(&mut self) -> Result<(), Error> {
    let ret = unsafe { ffi::SSL_do_handshake(self.ssl.as_ptr()) };
    if ret > 0 { Ok(()) } else { Err(self.make_error(ret)) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: stateless,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in stateless:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3725, End Line: 3732
/// Perform a stateless server-side handshake.
///
/// Requires that cookie generation and verification callbacks were
/// set on the SSL context.
///
/// Returns `Ok(true)` if a complete ClientHello containing a valid cookie
/// was read, in which case the handshake should be continued via
/// `accept`. If a HelloRetryRequest containing a fresh cookie was
/// transmitted, `Ok(false)` is returned instead. If the handshake cannot
/// proceed at all, `Err` is returned.
#[corresponds(SSL_stateless)]
#[cfg(ossl111)]
pub fn stateless(&mut self) -> Result<bool, ErrorStack> {
    match unsafe { ffi::SSL_stateless(self.ssl.as_ptr()) } {
        1 => Ok(true),
        0 => Ok(false),
        -1 => Err(ErrorStack::get()),
        _ => unreachable!(),
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: ssl_read,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: shutdown,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in shutdown:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3906, End Line: 3912
/// Shuts down the session.
///
/// The shutdown process consists of two steps. The first step sends a close notify message to
/// the peer, after which `ShutdownResult::Sent` is returned. The second step awaits the receipt
/// of a close notify message from the peer, after which `ShutdownResult::Received` is returned.
///
/// While the connection may be closed after the first step, it is recommended to fully shut the
/// session down. In particular, it must be fully shut down if the connection is to be used for
/// further communication in the future.
#[corresponds(SSL_shutdown)]
pub fn shutdown(&mut self) -> Result<ShutdownResult, Error> {
    match unsafe { ffi::SSL_shutdown(self.ssl.as_ptr()) } {
        0 => Ok(ShutdownResult::Sent),
        1 => Ok(ShutdownResult::Received),
        n => Err(self.make_error(n)),
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: get_shutdown,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in get_shutdown:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3916, End Line: 3921
/// Returns the session's shutdown state.
#[corresponds(SSL_get_shutdown)]
pub fn get_shutdown(&mut self) -> ShutdownState {
    unsafe {
        let bits = ffi::SSL_get_shutdown(self.ssl.as_ptr());
        ShutdownState::from_bits_retain(bits)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_shutdown,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_shutdown:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3928, End Line: 3930
/// Sets the session's shutdown state.
///
/// This can be used to tell OpenSSL that the session should be cached even if a full two-way
/// shutdown was not completed.
#[corresponds(SSL_set_shutdown)]
pub fn set_shutdown(&mut self, state: ShutdownState) {
    unsafe { ffi::SSL_set_shutdown(self.ssl.as_ptr(), state.bits()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: check_panic,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in check_panic:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3959, End Line: 3963
fn check_panic(&mut self) {
    if let Some(err) = unsafe { bio::take_panic::<S>(self.ssl.get_raw_rbio()) } {
        resume_unwind(err)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: get_bio_error,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in get_bio_error:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 3965, End Line: 3967
fn get_bio_error(&mut self) -> Option<io::Error> {
    unsafe { bio::take_error::<S>(self.ssl.get_raw_rbio()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: true, Name: read,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_dtls_mtu_size,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs

Found method with unsafe block in set_dtls_mtu_size:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\mod.rs
Start Line: 4224, End Line: 4229
/// Set the DTLS MTU size.
///
/// It will be ignored if the value is smaller than the minimum packet size
/// the DTLS protocol requires.
///
/// # Panics
/// This function panics if the given mtu size can't be represented in a positive `c_long` range
#[deprecated(note = "Use SslRef::set_mtu instead", since = "0.10.30")]
pub fn set_dtls_mtu_size(&mut self, mtu_size: usize) {
    unsafe {
        let bio = self.inner.ssl.get_raw_rbio();
        bio::set_dtls_mtu_size::<S>(bio, mtu_size);
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\test\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\ssl\test\server.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs
-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: drop,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs

Found method with unsafe block in drop:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs
Start Line: 58, End Line: 63
fn drop(&mut self) {
    unsafe {
        while self.pop().is_some() {}
        OPENSSL_sk_free(self.0 as *mut _);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs
Start Line: 67, End Line: 73
pub fn new() -> Result<Stack<T>, ErrorStack> {
    unsafe {
        ffi::init();
        let ptr = cvt_p(OPENSSL_sk_new_null())?;
        Ok(Stack(ptr as *mut _))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: deref,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs

Found method with unsafe block in deref:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs
Start Line: 125, End Line: 127
fn deref(&self) -> &StackRef<T> {
    unsafe { StackRef::from_ptr(self.0) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: deref_mut,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs

Found method with unsafe block in deref_mut:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs
Start Line: 131, End Line: 133
fn deref_mut(&mut self) -> &mut StackRef<T> {
    unsafe { StackRef::from_ptr_mut(self.0) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: next,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs

Found method with unsafe block in next:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs
Start Line: 155, End Line: 161
fn next(&mut self) -> Option<T> {
    unsafe {
        self.idxs
            .next()
            .map(|i| T::from_ptr(OPENSSL_sk_value(self.stack as *mut _, i) as *mut _))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: next_back,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs

Found method with unsafe block in next_back:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs
Start Line: 169, End Line: 175
fn next_back(&mut self) -> Option<T> {
    unsafe {
        self.idxs
            .next_back()
            .map(|i| T::from_ptr(OPENSSL_sk_value(self.stack as *mut _, i) as *mut _))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: len,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs

Found method with unsafe block in len:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs
Start Line: 195, End Line: 197
/// Returns the number of items in the stack.
pub fn len(&self) -> usize {
    unsafe { OPENSSL_sk_num(self.as_stack()) as usize }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: get,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs

Found method with unsafe block in get:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs
Start Line: 220, End Line: 228
/// Returns a reference to the element at the given index in the
/// stack or `None` if the index is out of bounds
pub fn get(&self, idx: usize) -> Option<&T::Ref> {
    unsafe {
        if idx >= self.len() {
            return None;
        }
        Some(T::Ref::from_ptr(self._get(idx)))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: get_mut,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs

Found method with unsafe block in get_mut:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs
Start Line: 232, End Line: 240
/// Returns a mutable reference to the element at the given index in the
/// stack or `None` if the index is out of bounds
pub fn get_mut(&mut self, idx: usize) -> Option<&mut T::Ref> {
    unsafe {
        if idx >= self.len() {
            return None;
        }
        Some(T::Ref::from_ptr_mut(self._get(idx)))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: push,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs

Found method with unsafe block in push:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs
Start Line: 243, End Line: 249
/// Pushes a value onto the top of the stack.
pub fn push(&mut self, data: T) -> Result<(), ErrorStack> {
    unsafe {
        cvt(OPENSSL_sk_push(self.as_stack(), data.as_ptr() as *mut _) as c_int)?;
        mem::forget(data);
        Ok(())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: pop,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs

Found method with unsafe block in pop:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\stack.rs
Start Line: 252, End Line: 257
/// Removes the last element from the stack and returns it.
pub fn pop(&mut self) -> Option<T> {
    unsafe {
        let ptr = OPENSSL_sk_pop(self.as_stack());
        T::from_ptr_opt(ptr as *mut _)
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\string.rs
-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: deref,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\string.rs

Found method with unsafe block in deref:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\string.rs
Start Line: 50, End Line: 55
fn deref(&self) -> &str {
    unsafe {
        let slice = CStr::from_ptr(self.as_ptr()).to_bytes();
        str::from_utf8_unchecked(slice)
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: from_nid,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in from_nid:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 81, End Line: 88
/// Looks up the cipher for a certain nid.
///
/// This corresponds to [`EVP_get_cipherbynid`]
///
/// [`EVP_get_cipherbynid`]: https://www.openssl.org/docs/manmaster/crypto/EVP_get_cipherbyname.html
pub fn from_nid(nid: Nid) -> Option<Cipher> {
    let ptr = unsafe { ffi::EVP_get_cipherbyname(ffi::OBJ_nid2sn(nid.as_raw())) };
    if ptr.is_null() { None } else { Some(Cipher(ptr)) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: nid,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in nid:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 95, End Line: 98
/// Returns the cipher's Nid.
///
/// This corresponds to [`EVP_CIPHER_nid`]
///
/// [`EVP_CIPHER_nid`]: https://www.openssl.org/docs/manmaster/crypto/EVP_CIPHER_nid.html
pub fn nid(&self) -> Nid {
    let nid = unsafe { ffi::EVP_CIPHER_nid(self.0) };
    Nid::from_raw(nid)
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_128_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 100, End Line: 102
pub fn aes_128_ecb() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_128_ecb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_128_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 104, End Line: 106
pub fn aes_128_cbc() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_128_cbc()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_xts,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_128_xts:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 109, End Line: 111
#[cfg(not(boringssl))]
pub fn aes_128_xts() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_128_xts()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_ctr,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_128_ctr:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 113, End Line: 115
pub fn aes_128_ctr() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_128_ctr()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_cfb1,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_128_cfb1:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 118, End Line: 120
#[cfg(not(boringssl))]
pub fn aes_128_cfb1() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_128_cfb1()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_cfb128,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_128_cfb128:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 122, End Line: 124
pub fn aes_128_cfb128() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_128_cfb128()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_cfb8,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_128_cfb8:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 127, End Line: 129
#[cfg(not(boringssl))]
pub fn aes_128_cfb8() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_128_cfb8()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_gcm,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_128_gcm:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 131, End Line: 133
pub fn aes_128_gcm() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_128_gcm()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_ccm,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_128_ccm:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 136, End Line: 138
#[cfg(not(boringssl))]
pub fn aes_128_ccm() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_128_ccm()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_128_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 140, End Line: 142
pub fn aes_128_ofb() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_128_ofb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_128_ocb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_128_ocb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 146, End Line: 148
/// Requires OpenSSL 1.1.0 or newer.
#[cfg(all(ossl110, not(osslconf = "OPENSSL_NO_OCB")))]
pub fn aes_128_ocb() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_128_ocb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_192_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 150, End Line: 152
pub fn aes_192_ecb() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_192_ecb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_192_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 154, End Line: 156
pub fn aes_192_cbc() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_192_cbc()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_ctr,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_192_ctr:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 158, End Line: 160
pub fn aes_192_ctr() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_192_ctr()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_cfb1,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_192_cfb1:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 163, End Line: 165
#[cfg(not(boringssl))]
pub fn aes_192_cfb1() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_192_cfb1()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_cfb128,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_192_cfb128:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 167, End Line: 169
pub fn aes_192_cfb128() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_192_cfb128()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_cfb8,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_192_cfb8:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 172, End Line: 174
#[cfg(not(boringssl))]
pub fn aes_192_cfb8() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_192_cfb8()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_gcm,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_192_gcm:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 176, End Line: 178
pub fn aes_192_gcm() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_192_gcm()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_ccm,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_192_ccm:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 181, End Line: 183
#[cfg(not(boringssl))]
pub fn aes_192_ccm() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_192_ccm()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_192_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 185, End Line: 187
pub fn aes_192_ofb() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_192_ofb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_192_ocb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_192_ocb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 191, End Line: 193
/// Requires OpenSSL 1.1.0 or newer.
#[cfg(all(ossl110, not(osslconf = "OPENSSL_NO_OCB")))]
pub fn aes_192_ocb() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_192_ocb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_256_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 195, End Line: 197
pub fn aes_256_ecb() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_256_ecb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_256_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 199, End Line: 201
pub fn aes_256_cbc() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_256_cbc()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_xts,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_256_xts:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 204, End Line: 206
#[cfg(not(boringssl))]
pub fn aes_256_xts() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_256_xts()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_ctr,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_256_ctr:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 208, End Line: 210
pub fn aes_256_ctr() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_256_ctr()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_cfb1,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_256_cfb1:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 213, End Line: 215
#[cfg(not(boringssl))]
pub fn aes_256_cfb1() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_256_cfb1()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_cfb128,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_256_cfb128:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 217, End Line: 219
pub fn aes_256_cfb128() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_256_cfb128()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_cfb8,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_256_cfb8:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 222, End Line: 224
#[cfg(not(boringssl))]
pub fn aes_256_cfb8() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_256_cfb8()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_gcm,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_256_gcm:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 226, End Line: 228
pub fn aes_256_gcm() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_256_gcm()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_ccm,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_256_ccm:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 231, End Line: 233
#[cfg(not(boringssl))]
pub fn aes_256_ccm() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_256_ccm()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_256_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 235, End Line: 237
pub fn aes_256_ofb() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_256_ofb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: aes_256_ocb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in aes_256_ocb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 241, End Line: 243
/// Requires OpenSSL 1.1.0 or newer.
#[cfg(all(ossl110, not(osslconf = "OPENSSL_NO_OCB")))]
pub fn aes_256_ocb() -> Cipher {
    unsafe { Cipher(ffi::EVP_aes_256_ocb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: bf_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in bf_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 246, End Line: 248
#[cfg(not(osslconf = "OPENSSL_NO_BF"))]
pub fn bf_cbc() -> Cipher {
    unsafe { Cipher(ffi::EVP_bf_cbc()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: bf_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in bf_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 251, End Line: 253
#[cfg(not(osslconf = "OPENSSL_NO_BF"))]
pub fn bf_ecb() -> Cipher {
    unsafe { Cipher(ffi::EVP_bf_ecb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: bf_cfb64,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in bf_cfb64:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 256, End Line: 258
#[cfg(not(osslconf = "OPENSSL_NO_BF"))]
pub fn bf_cfb64() -> Cipher {
    unsafe { Cipher(ffi::EVP_bf_cfb64()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: bf_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in bf_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 261, End Line: 263
#[cfg(not(osslconf = "OPENSSL_NO_BF"))]
pub fn bf_ofb() -> Cipher {
    unsafe { Cipher(ffi::EVP_bf_ofb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: des_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in des_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 265, End Line: 267
pub fn des_cbc() -> Cipher {
    unsafe { Cipher(ffi::EVP_des_cbc()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: des_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in des_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 269, End Line: 271
pub fn des_ecb() -> Cipher {
    unsafe { Cipher(ffi::EVP_des_ecb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: des_ede3,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in des_ede3:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 273, End Line: 275
pub fn des_ede3() -> Cipher {
    unsafe { Cipher(ffi::EVP_des_ede3()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: des_ede3_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in des_ede3_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 277, End Line: 279
pub fn des_ede3_cbc() -> Cipher {
    unsafe { Cipher(ffi::EVP_des_ede3_cbc()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: des_ede3_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in des_ede3_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 281, End Line: 283
pub fn des_ede3_ecb() -> Cipher {
    unsafe { Cipher(ffi::EVP_des_ede3_ecb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: des_ede3_cfb64,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in des_ede3_cfb64:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 286, End Line: 288
#[cfg(not(boringssl))]
pub fn des_ede3_cfb64() -> Cipher {
    unsafe { Cipher(ffi::EVP_des_ede3_cfb64()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: des_ede3_cfb8,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in des_ede3_cfb8:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 291, End Line: 293
#[cfg(not(boringssl))]
pub fn des_ede3_cfb8() -> Cipher {
    unsafe { Cipher(ffi::EVP_des_ede3_cfb8()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: des_ede3_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in des_ede3_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 296, End Line: 298
#[cfg(not(boringssl))]
pub fn des_ede3_ofb() -> Cipher {
    unsafe { Cipher(ffi::EVP_des_ede3_ofb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: rc4,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in rc4:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 301, End Line: 303
#[cfg(not(osslconf = "OPENSSL_NO_RC4"))]
pub fn rc4() -> Cipher {
    unsafe { Cipher(ffi::EVP_rc4()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia_128_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in camellia_128_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 306, End Line: 308
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia_128_cbc() -> Cipher {
    unsafe { Cipher(ffi::EVP_camellia_128_cbc()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia_128_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in camellia_128_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 311, End Line: 313
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia_128_ecb() -> Cipher {
    unsafe { Cipher(ffi::EVP_camellia_128_ecb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia_128_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in camellia_128_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 316, End Line: 318
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia_128_ofb() -> Cipher {
    unsafe { Cipher(ffi::EVP_camellia_128_ofb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia_128_cfb128,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in camellia_128_cfb128:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 321, End Line: 323
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia_128_cfb128() -> Cipher {
    unsafe { Cipher(ffi::EVP_camellia_128_cfb128()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia_192_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in camellia_192_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 326, End Line: 328
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia_192_cbc() -> Cipher {
    unsafe { Cipher(ffi::EVP_camellia_192_cbc()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia_192_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in camellia_192_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 331, End Line: 333
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia_192_ecb() -> Cipher {
    unsafe { Cipher(ffi::EVP_camellia_192_ecb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia_192_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in camellia_192_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 336, End Line: 338
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia_192_ofb() -> Cipher {
    unsafe { Cipher(ffi::EVP_camellia_192_ofb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia_192_cfb128,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in camellia_192_cfb128:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 341, End Line: 343
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia_192_cfb128() -> Cipher {
    unsafe { Cipher(ffi::EVP_camellia_192_cfb128()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia_256_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in camellia_256_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 346, End Line: 348
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia_256_cbc() -> Cipher {
    unsafe { Cipher(ffi::EVP_camellia_256_cbc()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia_256_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in camellia_256_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 351, End Line: 353
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia_256_ecb() -> Cipher {
    unsafe { Cipher(ffi::EVP_camellia_256_ecb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia_256_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in camellia_256_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 356, End Line: 358
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia_256_ofb() -> Cipher {
    unsafe { Cipher(ffi::EVP_camellia_256_ofb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: camellia_256_cfb128,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in camellia_256_cfb128:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 361, End Line: 363
#[cfg(not(osslconf = "OPENSSL_NO_CAMELLIA"))]
pub fn camellia_256_cfb128() -> Cipher {
    unsafe { Cipher(ffi::EVP_camellia_256_cfb128()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cast5_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in cast5_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 366, End Line: 368
#[cfg(not(osslconf = "OPENSSL_NO_CAST"))]
pub fn cast5_cbc() -> Cipher {
    unsafe { Cipher(ffi::EVP_cast5_cbc()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cast5_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in cast5_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 371, End Line: 373
#[cfg(not(osslconf = "OPENSSL_NO_CAST"))]
pub fn cast5_ecb() -> Cipher {
    unsafe { Cipher(ffi::EVP_cast5_ecb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cast5_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in cast5_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 376, End Line: 378
#[cfg(not(osslconf = "OPENSSL_NO_CAST"))]
pub fn cast5_ofb() -> Cipher {
    unsafe { Cipher(ffi::EVP_cast5_ofb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cast5_cfb64,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in cast5_cfb64:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 381, End Line: 383
#[cfg(not(osslconf = "OPENSSL_NO_CAST"))]
pub fn cast5_cfb64() -> Cipher {
    unsafe { Cipher(ffi::EVP_cast5_cfb64()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: chacha20,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in chacha20:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 387, End Line: 389
/// Requires OpenSSL 1.1.0 or newer.
#[cfg(all(any(ossl110, libressl310), not(osslconf = "OPENSSL_NO_CHACHA")))]
pub fn chacha20() -> Cipher {
    unsafe { Cipher(ffi::EVP_chacha20()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: chacha20_poly1305,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in chacha20_poly1305:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 393, End Line: 395
/// Requires OpenSSL 1.1.0 or newer.
#[cfg(all(any(ossl110, libressl360), not(osslconf = "OPENSSL_NO_CHACHA")))]
pub fn chacha20_poly1305() -> Cipher {
    unsafe { Cipher(ffi::EVP_chacha20_poly1305()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: idea_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in idea_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 398, End Line: 400
#[cfg(not(osslconf = "OPENSSL_NO_IDEA"))]
pub fn idea_cbc() -> Cipher {
    unsafe { Cipher(ffi::EVP_idea_cbc()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: idea_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in idea_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 403, End Line: 405
#[cfg(not(osslconf = "OPENSSL_NO_IDEA"))]
pub fn idea_ecb() -> Cipher {
    unsafe { Cipher(ffi::EVP_idea_ecb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: idea_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in idea_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 408, End Line: 410
#[cfg(not(osslconf = "OPENSSL_NO_IDEA"))]
pub fn idea_ofb() -> Cipher {
    unsafe { Cipher(ffi::EVP_idea_ofb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: idea_cfb64,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in idea_cfb64:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 413, End Line: 415
#[cfg(not(osslconf = "OPENSSL_NO_IDEA"))]
pub fn idea_cfb64() -> Cipher {
    unsafe { Cipher(ffi::EVP_idea_cfb64()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: seed_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in seed_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 418, End Line: 420
#[cfg(not(osslconf = "OPENSSL_NO_SEED"))]
pub fn seed_cbc() -> Cipher {
    unsafe { Cipher(ffi::EVP_seed_cbc()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: seed_cfb128,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in seed_cfb128:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 423, End Line: 425
#[cfg(not(osslconf = "OPENSSL_NO_SEED"))]
pub fn seed_cfb128() -> Cipher {
    unsafe { Cipher(ffi::EVP_seed_cfb128()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: seed_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in seed_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 428, End Line: 430
#[cfg(not(osslconf = "OPENSSL_NO_SEED"))]
pub fn seed_ecb() -> Cipher {
    unsafe { Cipher(ffi::EVP_seed_ecb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: seed_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in seed_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 433, End Line: 435
#[cfg(not(osslconf = "OPENSSL_NO_SEED"))]
pub fn seed_ofb() -> Cipher {
    unsafe { Cipher(ffi::EVP_seed_ofb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sm4_ecb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in sm4_ecb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 438, End Line: 440
#[cfg(all(any(ossl111, libressl291), not(osslconf = "OPENSSL_NO_SM4")))]
pub fn sm4_ecb() -> Cipher {
    unsafe { Cipher(ffi::EVP_sm4_ecb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sm4_cbc,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in sm4_cbc:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 443, End Line: 445
#[cfg(all(any(ossl111, libressl291), not(osslconf = "OPENSSL_NO_SM4")))]
pub fn sm4_cbc() -> Cipher {
    unsafe { Cipher(ffi::EVP_sm4_cbc()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sm4_ctr,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in sm4_ctr:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 448, End Line: 450
#[cfg(all(any(ossl111, libressl291), not(osslconf = "OPENSSL_NO_SM4")))]
pub fn sm4_ctr() -> Cipher {
    unsafe { Cipher(ffi::EVP_sm4_ctr()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sm4_cfb128,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in sm4_cfb128:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 453, End Line: 455
#[cfg(all(any(ossl111, libressl291), not(osslconf = "OPENSSL_NO_SM4")))]
pub fn sm4_cfb128() -> Cipher {
    unsafe { Cipher(ffi::EVP_sm4_cfb128()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sm4_ofb,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in sm4_ofb:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 458, End Line: 460
#[cfg(all(any(ossl111, libressl291), not(osslconf = "OPENSSL_NO_SM4")))]
pub fn sm4_ofb() -> Cipher {
    unsafe { Cipher(ffi::EVP_sm4_ofb()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: key_len,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in key_len:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 478, End Line: 480
/// Returns the length of keys used with this cipher.
#[allow(clippy::trivially_copy_pass_by_ref)]
pub fn key_len(&self) -> usize {
    unsafe { EVP_CIPHER_key_length(self.0) as usize }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: iv_len,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in iv_len:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 485, End Line: 494
/// Returns the length of the IV used with this cipher, or `None` if the
/// cipher does not use an IV.
#[allow(clippy::trivially_copy_pass_by_ref)]
pub fn iv_len(&self) -> Option<usize> {
    unsafe {
        let len = EVP_CIPHER_iv_length(self.0) as usize;
        if len == 0 { None } else { Some(len) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: block_size,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in block_size:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 502, End Line: 504
/// Returns the block size of the cipher.
///
/// # Note
///
/// Stream ciphers such as RC4 have a block size of 1.
#[allow(clippy::trivially_copy_pass_by_ref)]
pub fn block_size(&self) -> usize {
    unsafe { EVP_CIPHER_block_size(self.0) as usize }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\symm.rs
Start Line: 607, End Line: 638
/// Creates a new `Crypter`.  The initialisation vector, `iv`, is not necessary for certain
/// types of `Cipher`.
///
/// # Panics
///
/// Panics if an IV is required by the cipher but not provided.  Also make sure that the key
/// and IV size are appropriate for your cipher.
pub fn new(
    t: Cipher,
    mode: Mode,
    key: &[u8],
    iv: Option<&[u8]>,
) -> Result<Crypter, ErrorStack> {
    let mut ctx = CipherCtx::new()?;
    let f = match mode {
        Mode::Encrypt => CipherCtxRef::encrypt_init,
        Mode::Decrypt => CipherCtxRef::decrypt_init,
    };
    f(&mut ctx, Some(unsafe { CipherRef::from_ptr(t.as_ptr() as *mut _) }), None, None)?;
    ctx.set_key_length(key.len())?;
    if let (Some(iv), Some(iv_len)) = (iv, t.iv_len()) {
        if iv.len() != iv_len {
            ctx.set_iv_length(iv.len())?;
        }
    }
    f(&mut ctx, None, Some(key), iv)?;
    Ok(Crypter { ctx })
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\util.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\version.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: number,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\version.rs

Found function with unsafe block in number:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\version.rs
Start Line: 48, End Line: 50
/// OPENSSL_VERSION_NUMBER is a numeric release version identifier:
///
/// `MNNFFPPS: major minor fix patch status`
///
/// The status nibble has one of the values 0 for development, 1 to e for betas 1 to 14, and f for release.
///
/// for example
///
/// `0x000906000 == 0.9.6 dev`
/// `0x000906023 == 0.9.6b beta 3`
/// `0x00090605f == 0.9.6e release`
#[corresponds(OpenSSL_version_num)]
pub fn number() -> i64 {
    unsafe { OpenSSL_version_num() as i64 }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: version,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\version.rs

Found function with unsafe block in version:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\version.rs
Start Line: 54, End Line: 60
/// The text variant of the version number and the release date. For example, "OpenSSL 0.9.5a 1 Apr 2000".
#[corresponds(OpenSSL_version)]
pub fn version() -> &'static str {
    unsafe { CStr::from_ptr(OpenSSL_version(OPENSSL_VERSION)).to_str().unwrap() }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: c_flags,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\version.rs

Found function with unsafe block in c_flags:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\version.rs
Start Line: 65, End Line: 71
/// The compiler flags set for the compilation process in the form "compiler: ..." if available or
/// "compiler: information not available" otherwise.
#[corresponds(OpenSSL_version)]
pub fn c_flags() -> &'static str {
    unsafe { CStr::from_ptr(OpenSSL_version(OPENSSL_CFLAGS)).to_str().unwrap() }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: built_on,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\version.rs

Found function with unsafe block in built_on:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\version.rs
Start Line: 75, End Line: 81
/// The date of the build process in the form "built on: ..." if available or "built on: date not available" otherwise.
#[corresponds(OpenSSL_version)]
pub fn built_on() -> &'static str {
    unsafe { CStr::from_ptr(OpenSSL_version(OPENSSL_BUILT_ON)).to_str().unwrap() }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: platform,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\version.rs

Found function with unsafe block in platform:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\version.rs
Start Line: 85, End Line: 91
/// The "Configure" target of the library build in the form "platform: ..." if available or "platform: information not available" otherwise.
#[corresponds(OpenSSL_version)]
pub fn platform() -> &'static str {
    unsafe { CStr::from_ptr(OpenSSL_version(OPENSSL_PLATFORM)).to_str().unwrap() }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: dir,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\version.rs

Found function with unsafe block in dir:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\version.rs
Start Line: 95, End Line: 101
/// The "OPENSSLDIR" setting of the library build in the form "OPENSSLDIR: "..."" if available or "OPENSSLDIR: N/A" otherwise.
#[corresponds(OpenSSL_version)]
pub fn dir() -> &'static str {
    unsafe { CStr::from_ptr(OpenSSL_version(OPENSSL_DIR)).to_str().unwrap() }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\extension.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: ssl_idx,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in ssl_idx:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 78, End Line: 80
/// Returns the index which can be used to obtain a reference to the `Ssl` associated with a
/// context.
#[corresponds(SSL_get_ex_data_X509_STORE_CTX_idx)]
pub fn ssl_idx() -> Result<Index<X509StoreContext, SslRef>, ErrorStack> {
    unsafe {
        cvt_n(ffi::SSL_get_ex_data_X509_STORE_CTX_idx()).map(|idx| Index::from_raw(idx))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 84, End Line: 89
/// Creates a new `X509StoreContext` instance.
#[corresponds(X509_STORE_CTX_new)]
pub fn new() -> Result<X509StoreContext, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(ffi::X509_STORE_CTX_new()).map(X509StoreContext)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: ex_data,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in ex_data:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 95, End Line: 104
/// Returns application data pertaining to an `X509` store context.
#[corresponds(X509_STORE_CTX_get_ex_data)]
pub fn ex_data<T>(&self, index: Index<X509StoreContext, T>) -> Option<&T> {
    unsafe {
        let data = ffi::X509_STORE_CTX_get_ex_data(self.as_ptr(), index.as_raw());
        if data.is_null() { None } else { Some(&*(data as *const T)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: error,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in error:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 108, End Line: 110
/// Returns the error code of the context.
#[corresponds(X509_STORE_CTX_get_error)]
pub fn error(&self) -> X509VerifyResult {
    unsafe { X509VerifyResult::from_raw(ffi::X509_STORE_CTX_get_error(self.as_ptr())) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: init,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: init,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in init:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 127, End Line: 158
/// Initializes this context with the given certificate, certificates chain and certificate
/// store. After initializing the context, the `with_context` closure is called with the prepared
/// context. As long as the closure is running, the context stays initialized and can be used
/// to e.g. verify a certificate. The context will be cleaned up, after the closure finished.
///
/// * `trust` - The certificate store with the trusted certificates.
/// * `cert` - The certificate that should be verified.
/// * `cert_chain` - The certificates chain.
/// * `with_context` - The closure that is called with the initialized context.
///
/// This corresponds to [`X509_STORE_CTX_init`] before calling `with_context` and to
/// [`X509_STORE_CTX_cleanup`] after calling `with_context`.
///
/// [`X509_STORE_CTX_init`]:  https://www.openssl.org/docs/manmaster/crypto/X509_STORE_CTX_init.html
/// [`X509_STORE_CTX_cleanup`]:  https://www.openssl.org/docs/manmaster/crypto/X509_STORE_CTX_cleanup.html
pub fn init<F, T>(
    &mut self,
    trust: &store::X509StoreRef,
    cert: &X509Ref,
    cert_chain: &StackRef<X509>,
    with_context: F,
) -> Result<T, ErrorStack>
where
    F: FnOnce(&mut X509StoreContextRef) -> Result<T, ErrorStack>,
{
    struct Cleanup<'a>(&'a mut X509StoreContextRef);
    impl<'a> Drop for Cleanup<'a> {
        fn drop(&mut self) {
            unsafe {
                ffi::X509_STORE_CTX_cleanup(self.0.as_ptr());
            }
        }
    }
    unsafe {
        cvt(
            ffi::X509_STORE_CTX_init(
                self.as_ptr(),
                trust.as_ptr(),
                cert.as_ptr(),
                cert_chain.as_ptr(),
            ),
        )?;
        let cleanup = Cleanup(self);
        with_context(cleanup.0)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: verify_cert,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in verify_cert:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 167, End Line: 169
/// Verifies the stored certificate.
///
/// Returns `true` if verification succeeds. The `error` method will return the specific
/// validation error if the certificate was not valid.
///
/// This will only work inside of a call to `init`.
#[corresponds(X509_verify_cert)]
pub fn verify_cert(&mut self) -> Result<bool, ErrorStack> {
    unsafe { cvt_n(ffi::X509_verify_cert(self.as_ptr())).map(|n| n != 0) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_error,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in set_error:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 173, End Line: 177
/// Set the error code of the context.
#[corresponds(X509_STORE_CTX_set_error)]
pub fn set_error(&mut self, result: X509VerifyResult) {
    unsafe {
        ffi::X509_STORE_CTX_set_error(self.as_ptr(), result.as_raw());
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: current_cert,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in current_cert:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 182, End Line: 187
/// Returns a reference to the certificate which caused the error or None if
/// no certificate is relevant to the error.
#[corresponds(X509_STORE_CTX_get_current_cert)]
pub fn current_cert(&self) -> Option<&X509Ref> {
    unsafe {
        let ptr = ffi::X509_STORE_CTX_get_current_cert(self.as_ptr());
        X509Ref::from_const_ptr_opt(ptr)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: error_depth,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in error_depth:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 194, End Line: 196
/// Returns a non-negative integer representing the depth in the certificate
/// chain where the error occurred. If it is zero it occurred in the end
/// entity certificate, one if it is the certificate which signed the end
/// entity certificate and so on.
#[corresponds(X509_STORE_CTX_get_error_depth)]
pub fn error_depth(&self) -> u32 {
    unsafe { ffi::X509_STORE_CTX_get_error_depth(self.as_ptr()) as u32 }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: chain,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in chain:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 200, End Line: 210
/// Returns a reference to a complete valid `X509` certificate chain.
#[corresponds(X509_STORE_CTX_get0_chain)]
pub fn chain(&self) -> Option<&StackRef<X509>> {
    unsafe {
        let chain = X509_STORE_CTX_get0_chain(self.as_ptr());
        if chain.is_null() { None } else { Some(StackRef::from_ptr(chain)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: drop,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in drop:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 140, End Line: 144
fn drop(&mut self) {
    unsafe {
        ffi::X509_STORE_CTX_cleanup(self.0.as_ptr());
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_not_after,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in set_not_after:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 228, End Line: 230
/// Sets the notAfter constraint on the certificate.
#[corresponds(X509_set1_notAfter)]
pub fn set_not_after(&mut self, not_after: &Asn1TimeRef) -> Result<(), ErrorStack> {
    unsafe { cvt(X509_set1_notAfter(self.0.as_ptr(), not_after.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_not_before,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in set_not_before:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 234, End Line: 236
/// Sets the notBefore constraint on the certificate.
#[corresponds(X509_set1_notBefore)]
pub fn set_not_before(&mut self, not_before: &Asn1TimeRef) -> Result<(), ErrorStack> {
    unsafe { cvt(X509_set1_notBefore(self.0.as_ptr(), not_before.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_version,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in set_version:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 244, End Line: 246
/// Sets the version of the certificate.
///
/// Note that the version is zero-indexed; that is, a certificate corresponding to version 3 of
/// the X.509 standard should pass `2` to this method.
#[corresponds(X509_set_version)]
#[allow(clippy::useless_conversion)]
pub fn set_version(&mut self, version: i32) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::X509_set_version(self.0.as_ptr(), version as c_long)).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_serial_number,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in set_serial_number:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 250, End Line: 258
/// Sets the serial number of the certificate.
#[corresponds(X509_set_serialNumber)]
pub fn set_serial_number(
    &mut self,
    serial_number: &Asn1IntegerRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::X509_set_serialNumber(self.0.as_ptr(), serial_number.as_ptr()))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_issuer_name,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in set_issuer_name:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 262, End Line: 270
/// Sets the issuer name of the certificate.
#[corresponds(X509_set_issuer_name)]
pub fn set_issuer_name(&mut self, issuer_name: &X509NameRef) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::X509_set_issuer_name(self.0.as_ptr(), issuer_name.as_ptr())).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_subject_name,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in set_subject_name:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 291, End Line: 299
/// Sets the subject name of the certificate.
///
/// When building certificates, the `C`, `ST`, and `O` options are common when using the openssl command line tools.
/// The `CN` field is used for the common name, such as a DNS name.
///
/// ```
/// use openssl::x509::{X509, X509NameBuilder};
///
/// let mut x509_name = openssl::x509::X509NameBuilder::new().unwrap();
/// x509_name.append_entry_by_text("C", "US").unwrap();
/// x509_name.append_entry_by_text("ST", "CA").unwrap();
/// x509_name.append_entry_by_text("O", "Some organization").unwrap();
/// x509_name.append_entry_by_text("CN", "www.example.com").unwrap();
/// let x509_name = x509_name.build();
///
/// let mut x509 = openssl::x509::X509::builder().unwrap();
/// x509.set_subject_name(&x509_name).unwrap();
/// ```
#[corresponds(X509_set_subject_name)]
pub fn set_subject_name(
    &mut self,
    subject_name: &X509NameRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::X509_set_subject_name(self.0.as_ptr(), subject_name.as_ptr()))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_pubkey,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in set_pubkey:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 303, End Line: 308
/// Sets the public key associated with the certificate.
#[corresponds(X509_set_pubkey)]
pub fn set_pubkey<T>(&mut self, key: &PKeyRef<T>) -> Result<(), ErrorStack>
where
    T: HasPublic,
{
    unsafe { cvt(ffi::X509_set_pubkey(self.0.as_ptr(), key.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 6 statements, Complex: true, With_SAFETY_comment: false, Name: x509v3_context,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in x509v3_context:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 314, End Line: 343
/// Returns a context object which is needed to create certain X509 extension values.
///
/// Set `issuer` to `None` if the certificate will be self-signed.
#[corresponds(X509V3_set_ctx)]
pub fn x509v3_context<'a>(
    &'a self,
    issuer: Option<&'a X509Ref>,
    conf: Option<&'a ConfRef>,
) -> X509v3Context<'a> {
    unsafe {
        let mut ctx = mem::zeroed();
        let issuer = match issuer {
            Some(issuer) => issuer.as_ptr(),
            None => self.0.as_ptr(),
        };
        let subject = self.0.as_ptr();
        ffi::X509V3_set_ctx(
            &mut ctx,
            issuer,
            subject,
            ptr::null_mut(),
            ptr::null_mut(),
            0,
        );
        if let Some(conf) = conf {
            ffi::X509V3_set_nconf(&mut ctx, conf.as_ptr());
        }
        X509v3Context(ctx, PhantomData)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: append_extension2,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in append_extension2:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 354, End Line: 359
/// Adds an X509 extension value to the certificate.
#[corresponds(X509_add_ext)]
pub fn append_extension2(
    &mut self,
    extension: &X509ExtensionRef,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::X509_add_ext(self.0.as_ptr(), extension.as_ptr(), -1))?;
        Ok(())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: sign,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in sign:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 363, End Line: 368
/// Signs the certificate with a private key.
#[corresponds(X509_sign)]
pub fn sign<T>(
    &mut self,
    key: &PKeyRef<T>,
    hash: MessageDigest,
) -> Result<(), ErrorStack>
where
    T: HasPrivate,
{
    unsafe {
        cvt(ffi::X509_sign(self.0.as_ptr(), key.as_ptr(), hash.as_ptr())).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: subject_name,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in subject_name:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 389, End Line: 394
/// Returns this certificate's subject name.
#[corresponds(X509_get_subject_name)]
pub fn subject_name(&self) -> &X509NameRef {
    unsafe {
        let name = ffi::X509_get_subject_name(self.as_ptr());
        X509NameRef::from_const_ptr_opt(name).expect("subject name must not be null")
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: subject_name_hash,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in subject_name_hash:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 398, End Line: 403
/// Returns the hash of the certificates subject
#[corresponds(X509_subject_name_hash)]
pub fn subject_name_hash(&self) -> u32 {
    #[allow(clippy::unnecessary_cast)]
    unsafe { ffi::X509_subject_name_hash(self.as_ptr()) as u32 }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: issuer_name,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in issuer_name:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 407, End Line: 412
/// Returns this certificate's issuer name.
#[corresponds(X509_get_issuer_name)]
pub fn issuer_name(&self) -> &X509NameRef {
    unsafe {
        let name = ffi::X509_get_issuer_name(self.as_ptr());
        X509NameRef::from_const_ptr_opt(name).expect("issuer name must not be null")
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: issuer_name_hash,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in issuer_name_hash:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 416, End Line: 421
/// Returns the hash of the certificates issuer
#[corresponds(X509_issuer_name_hash)]
pub fn issuer_name_hash(&self) -> u32 {
    #[allow(clippy::unnecessary_cast)]
    unsafe { ffi::X509_issuer_name_hash(self.as_ptr()) as u32 }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: subject_alt_names,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in subject_alt_names:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 425, End Line: 435
/// Returns this certificate's subject alternative name entries, if they exist.
#[corresponds(X509_get_ext_d2i)]
pub fn subject_alt_names(&self) -> Option<Stack<GeneralName>> {
    unsafe {
        let stack = ffi::X509_get_ext_d2i(
            self.as_ptr(),
            ffi::NID_subject_alt_name,
            ptr::null_mut(),
            ptr::null_mut(),
        );
        Stack::from_ptr_opt(stack as *mut _)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: crl_distribution_points,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in crl_distribution_points:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 439, End Line: 449
/// Returns this certificate's CRL distribution points, if they exist.
#[corresponds(X509_get_ext_d2i)]
pub fn crl_distribution_points(&self) -> Option<Stack<DistPoint>> {
    unsafe {
        let stack = ffi::X509_get_ext_d2i(
            self.as_ptr(),
            ffi::NID_crl_distribution_points,
            ptr::null_mut(),
            ptr::null_mut(),
        );
        Stack::from_ptr_opt(stack as *mut _)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: issuer_alt_names,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in issuer_alt_names:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 453, End Line: 463
/// Returns this certificate's issuer alternative name entries, if they exist.
#[corresponds(X509_get_ext_d2i)]
pub fn issuer_alt_names(&self) -> Option<Stack<GeneralName>> {
    unsafe {
        let stack = ffi::X509_get_ext_d2i(
            self.as_ptr(),
            ffi::NID_issuer_alt_name,
            ptr::null_mut(),
            ptr::null_mut(),
        );
        Stack::from_ptr_opt(stack as *mut _)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: authority_info,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in authority_info:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 469, End Line: 479
/// Returns this certificate's [`authority information access`] entries, if they exist.
///
/// [`authority information access`]: https://tools.ietf.org/html/rfc5280#section-4.2.2.1
#[corresponds(X509_get_ext_d2i)]
pub fn authority_info(&self) -> Option<Stack<AccessDescription>> {
    unsafe {
        let stack = ffi::X509_get_ext_d2i(
            self.as_ptr(),
            ffi::NID_info_access,
            ptr::null_mut(),
            ptr::null_mut(),
        );
        Stack::from_ptr_opt(stack as *mut _)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: pathlen,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in pathlen:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 484, End Line: 487
/// Retrieves the path length extension from a certificate, if it exists.
#[corresponds(X509_get_pathlen)]
#[cfg(any(ossl110, boringssl))]
pub fn pathlen(&self) -> Option<u32> {
    let v = unsafe { ffi::X509_get_pathlen(self.as_ptr()) };
    u32::try_from(v).ok()
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: subject_key_id,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in subject_key_id:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 492, End Line: 497
/// Returns this certificate's subject key id, if it exists.
#[corresponds(X509_get0_subject_key_id)]
#[cfg(any(ossl110, boringssl))]
pub fn subject_key_id(&self) -> Option<&Asn1OctetStringRef> {
    unsafe {
        let data = ffi::X509_get0_subject_key_id(self.as_ptr());
        Asn1OctetStringRef::from_const_ptr_opt(data)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: authority_key_id,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in authority_key_id:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 502, End Line: 507
/// Returns this certificate's authority key id, if it exists.
#[corresponds(X509_get0_authority_key_id)]
#[cfg(any(ossl110, boringssl))]
pub fn authority_key_id(&self) -> Option<&Asn1OctetStringRef> {
    unsafe {
        let data = ffi::X509_get0_authority_key_id(self.as_ptr());
        Asn1OctetStringRef::from_const_ptr_opt(data)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: authority_issuer,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in authority_issuer:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 512, End Line: 517
/// Returns this certificate's authority issuer name entries, if they exist.
#[corresponds(X509_get0_authority_issuer)]
#[cfg(ossl111d)]
pub fn authority_issuer(&self) -> Option<&StackRef<GeneralName>> {
    unsafe {
        let stack = ffi::X509_get0_authority_issuer(self.as_ptr());
        StackRef::from_const_ptr_opt(stack)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: authority_serial,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in authority_serial:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 522, End Line: 527
/// Returns this certificate's authority serial number, if it exists.
#[corresponds(X509_get0_authority_serial)]
#[cfg(ossl111d)]
pub fn authority_serial(&self) -> Option<&Asn1IntegerRef> {
    unsafe {
        let r = ffi::X509_get0_authority_serial(self.as_ptr());
        Asn1IntegerRef::from_const_ptr_opt(r)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: public_key,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in public_key:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 530, End Line: 535
#[corresponds(X509_get_pubkey)]
pub fn public_key(&self) -> Result<PKey<Public>, ErrorStack> {
    unsafe {
        let pkey = cvt_p(ffi::X509_get_pubkey(self.as_ptr()))?;
        Ok(PKey::from_ptr(pkey))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: digest,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in digest:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 539, End Line: 556
/// Returns a digest of the DER representation of the certificate.
#[corresponds(X509_digest)]
pub fn digest(&self, hash_type: MessageDigest) -> Result<DigestBytes, ErrorStack> {
    unsafe {
        let mut digest = DigestBytes {
            buf: [0; ffi::EVP_MAX_MD_SIZE as usize],
            len: ffi::EVP_MAX_MD_SIZE as usize,
        };
        let mut len = ffi::EVP_MAX_MD_SIZE as c_uint;
        cvt(
            ffi::X509_digest(
                self.as_ptr(),
                hash_type.as_ptr(),
                digest.buf.as_mut_ptr() as *mut _,
                &mut len,
            ),
        )?;
        digest.len = len as usize;
        Ok(digest)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: not_after,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in not_after:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 565, End Line: 570
/// Returns the certificate's Not After validity period.
#[corresponds(X509_getm_notAfter)]
pub fn not_after(&self) -> &Asn1TimeRef {
    unsafe {
        let date = X509_getm_notAfter(self.as_ptr());
        Asn1TimeRef::from_const_ptr_opt(date).expect("not_after must not be null")
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: not_before,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in not_before:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 574, End Line: 579
/// Returns the certificate's Not Before validity period.
#[corresponds(X509_getm_notBefore)]
pub fn not_before(&self) -> &Asn1TimeRef {
    unsafe {
        let date = X509_getm_notBefore(self.as_ptr());
        Asn1TimeRef::from_const_ptr_opt(date).expect("not_before must not be null")
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: signature,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in signature:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 583, End Line: 589
/// Returns the certificate's signature
#[corresponds(X509_get0_signature)]
pub fn signature(&self) -> &Asn1BitStringRef {
    unsafe {
        let mut signature = ptr::null();
        X509_get0_signature(&mut signature, ptr::null_mut(), self.as_ptr());
        Asn1BitStringRef::from_const_ptr_opt(signature)
            .expect("signature must not be null")
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: signature_algorithm,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in signature_algorithm:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 593, End Line: 600
/// Returns the certificate's signature algorithm.
#[corresponds(X509_get0_signature)]
pub fn signature_algorithm(&self) -> &X509AlgorithmRef {
    unsafe {
        let mut algor = ptr::null();
        X509_get0_signature(ptr::null_mut(), &mut algor, self.as_ptr());
        X509AlgorithmRef::from_const_ptr_opt(algor)
            .expect("signature algorithm must not be null")
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: ocsp_responders,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in ocsp_responders:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 605, End Line: 607
/// Returns the list of OCSP responder URLs specified in the certificate's Authority Information
/// Access field.
#[corresponds(X509_get1_ocsp)]
pub fn ocsp_responders(&self) -> Result<Stack<OpensslString>, ErrorStack> {
    unsafe { cvt_p(ffi::X509_get1_ocsp(self.as_ptr())).map(|p| Stack::from_ptr(p)) }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: issued,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in issued:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 611, End Line: 616
/// Checks that this certificate issued `subject`.
#[corresponds(X509_check_issued)]
pub fn issued(&self, subject: &X509Ref) -> X509VerifyResult {
    unsafe {
        let r = ffi::X509_check_issued(self.as_ptr(), subject.as_ptr());
        X509VerifyResult::from_raw(r)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: version,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in version:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 625, End Line: 627
/// Returns certificate version. If this certificate has no explicit version set, it defaults to
/// version 1.
///
/// Note that `0` return value stands for version 1, `1` for version 2 and so on.
#[corresponds(X509_get_version)]
#[cfg(ossl110)]
#[allow(clippy::unnecessary_cast)]
pub fn version(&self) -> i32 {
    unsafe { ffi::X509_get_version(self.as_ptr()) as i32 }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: verify,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in verify:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 636, End Line: 641
/// Check if the certificate is signed using the given public key.
///
/// Only the signature is checked: no other checks (such as certificate chain validity)
/// are performed.
///
/// Returns `true` if verification succeeds.
#[corresponds(X509_verify)]
pub fn verify<T>(&self, key: &PKeyRef<T>) -> Result<bool, ErrorStack>
where
    T: HasPublic,
{
    unsafe { cvt_n(ffi::X509_verify(self.as_ptr(), key.as_ptr())).map(|n| n != 0) }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: serial_number,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in serial_number:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 645, End Line: 650
/// Returns this certificate's serial number.
#[corresponds(X509_get_serialNumber)]
pub fn serial_number(&self) -> &Asn1IntegerRef {
    unsafe {
        let r = ffi::X509_get_serialNumber(self.as_ptr());
        Asn1IntegerRef::from_const_ptr_opt(r).expect("serial number must not be null")
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: true, With_SAFETY_comment: false, Name: alias,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in alias:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 658, End Line: 668
/// Returns this certificate's "alias". This field is populated by
/// OpenSSL in some situations -- specifically OpenSSL will store a
/// PKCS#12 `friendlyName` in this field. This is not a part of the X.509
/// certificate itself, OpenSSL merely attaches it to this structure in
/// memory.
#[corresponds(X509_alias_get0)]
pub fn alias(&self) -> Option<&[u8]> {
    unsafe {
        let mut len = 0;
        let ptr = ffi::X509_alias_get0(self.as_ptr(), &mut len);
        if ptr.is_null() { None } else { Some(slice::from_raw_parts(ptr, len as usize)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: to_owned,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in to_owned:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 697, End Line: 702
fn to_owned(&self) -> X509 {
    unsafe {
        X509_up_ref(self.as_ptr());
        X509::from_ptr(self.as_ptr())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: cmp,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in cmp:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 706, End Line: 711
fn cmp(&self, other: &Self) -> cmp::Ordering {
    let cmp = unsafe { ffi::X509_cmp(self.as_ptr(), other.as_ptr()) };
    cmp.cmp(&0)
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: stack_from_pem,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in stack_from_pem:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 766, End Line: 794
/// Deserializes a list of PEM-formatted certificates.
#[corresponds(PEM_read_bio_X509)]
pub fn stack_from_pem(pem: &[u8]) -> Result<Vec<X509>, ErrorStack> {
    unsafe {
        ffi::init();
        let bio = MemBioSlice::new(pem)?;
        let mut certs = vec![];
        loop {
            let r = ffi::PEM_read_bio_X509(
                bio.as_ptr(),
                ptr::null_mut(),
                None,
                ptr::null_mut(),
            );
            if r.is_null() {
                let e = ErrorStack::get();
                if let Some(err) = e.errors().last() {
                    if err.library_code() == ffi::ERR_LIB_PEM as libc::c_int
                        && err.reason_code() == ffi::PEM_R_NO_START_LINE as libc::c_int
                    {
                        break;
                    }
                }
                return Err(e);
            } else {
                certs.push(X509(r));
            }
        }
        Ok(certs)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 6 statements, Complex: false, With_SAFETY_comment: false, Name: new_nid,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in new_nid:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 967, End Line: 999
/// Constructs an X509 extension value. See `man x509v3_config` for information on supported
/// extensions and their value formats.
///
/// Some extension types, such as `nid::SUBJECT_ALTERNATIVE_NAME`, require an `X509v3Context` to
/// be provided.
///
/// DO NOT CALL THIS WITH UNTRUSTED `value`: `value` is an OpenSSL
/// mini-language that can read arbitrary files.
///
/// See the extension module for builder types which will construct certain common extensions.
///
/// This function is deprecated, `X509Extension::new_from_der` or the
/// types in `x509::extension` should be used in its place.
#[deprecated(
    note = "Use x509::extension types or new_from_der instead",
    since = "0.10.51"
)]
pub fn new_nid(
    conf: Option<&ConfRef>,
    context: Option<&X509v3Context<'_>>,
    name: Nid,
    value: &str,
) -> Result<X509Extension, ErrorStack> {
    let value = CString::new(value).unwrap();
    let mut ctx;
    unsafe {
        ffi::init();
        let conf = conf.map_or(ptr::null_mut(), ConfRef::as_ptr);
        let context_ptr = match context {
            Some(c) => c.as_ptr(),
            None => {
                ctx = mem::zeroed();
                ffi::X509V3_set_ctx(
                    &mut ctx,
                    ptr::null_mut(),
                    ptr::null_mut(),
                    ptr::null_mut(),
                    ptr::null_mut(),
                    0,
                );
                &mut ctx
            }
        };
        let name = name.as_raw();
        let value = value.as_ptr() as *mut _;
        cvt_p(ffi::X509V3_EXT_nconf_nid(conf, context_ptr, name, value))
            .map(X509Extension)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: new_from_der,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in new_from_der:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1010, End Line: 1024
/// Constructs a new X509 extension value from its OID, whether it's
/// critical, and its DER contents.
///
/// The extent structure of the DER value will vary based on the
/// extension type, and can generally be found in the RFC defining the
/// extension.
///
/// For common extension types, there are Rust APIs provided in
/// `openssl::x509::extensions` which are more ergonomic.
pub fn new_from_der(
    oid: &Asn1ObjectRef,
    critical: bool,
    der_contents: &Asn1OctetStringRef,
) -> Result<X509Extension, ErrorStack> {
    unsafe {
        cvt_p(
                ffi::X509_EXTENSION_create_by_OBJ(
                    ptr::null_mut(),
                    oid.as_ptr(),
                    critical as _,
                    der_contents.as_ptr(),
                ),
            )
            .map(X509Extension)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: append_entry,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in append_entry:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1076, End Line: 1086
/// Add a name entry
#[corresponds(X509_NAME_add_entry)]
#[cfg(any(ossl101, libressl350))]
pub fn append_entry(
    &mut self,
    ne: &X509NameEntryRef,
) -> std::result::Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::X509_NAME_add_entry(self.0.as_ptr(), ne.as_ptr(), -1, 0)).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: append_entry_by_text,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in append_entry_by_text:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1093, End Line: 1108
/// Add a field entry by str.
///
/// This corresponds to [`X509_NAME_add_entry_by_txt`].
///
/// [`X509_NAME_add_entry_by_txt`]: https://www.openssl.org/docs/manmaster/crypto/X509_NAME_add_entry_by_txt.html
pub fn append_entry_by_text(
    &mut self,
    field: &str,
    value: &str,
) -> Result<(), ErrorStack> {
    unsafe {
        let field = CString::new(field).unwrap();
        assert!(value.len() <= crate ::SLenType::MAX as usize);
        cvt(
                ffi::X509_NAME_add_entry_by_txt(
                    self.0.as_ptr(),
                    field.as_ptr() as *mut _,
                    ffi::MBSTRING_UTF8,
                    value.as_ptr(),
                    value.len() as crate::SLenType,
                    -1,
                    0,
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: append_entry_by_text_with_type,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in append_entry_by_text_with_type:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1115, End Line: 1135
/// Add a field entry by str with a specific type.
///
/// This corresponds to [`X509_NAME_add_entry_by_txt`].
///
/// [`X509_NAME_add_entry_by_txt`]: https://www.openssl.org/docs/manmaster/crypto/X509_NAME_add_entry_by_txt.html
pub fn append_entry_by_text_with_type(
    &mut self,
    field: &str,
    value: &str,
    ty: Asn1Type,
) -> Result<(), ErrorStack> {
    unsafe {
        let field = CString::new(field).unwrap();
        assert!(value.len() <= crate ::SLenType::MAX as usize);
        cvt(
                ffi::X509_NAME_add_entry_by_txt(
                    self.0.as_ptr(),
                    field.as_ptr() as *mut _,
                    ty.as_raw(),
                    value.as_ptr(),
                    value.len() as crate::SLenType,
                    -1,
                    0,
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: append_entry_by_nid,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in append_entry_by_nid:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1142, End Line: 1156
/// Add a field entry by NID.
///
/// This corresponds to [`X509_NAME_add_entry_by_NID`].
///
/// [`X509_NAME_add_entry_by_NID`]: https://www.openssl.org/docs/manmaster/crypto/X509_NAME_add_entry_by_NID.html
pub fn append_entry_by_nid(
    &mut self,
    field: Nid,
    value: &str,
) -> Result<(), ErrorStack> {
    unsafe {
        assert!(value.len() <= crate ::SLenType::MAX as usize);
        cvt(
                ffi::X509_NAME_add_entry_by_NID(
                    self.0.as_ptr(),
                    field.as_raw(),
                    ffi::MBSTRING_UTF8,
                    value.as_ptr() as *mut _,
                    value.len() as crate::SLenType,
                    -1,
                    0,
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: append_entry_by_nid_with_type,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in append_entry_by_nid_with_type:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1163, End Line: 1182
/// Add a field entry by NID with a specific type.
///
/// This corresponds to [`X509_NAME_add_entry_by_NID`].
///
/// [`X509_NAME_add_entry_by_NID`]: https://www.openssl.org/docs/manmaster/crypto/X509_NAME_add_entry_by_NID.html
pub fn append_entry_by_nid_with_type(
    &mut self,
    field: Nid,
    value: &str,
    ty: Asn1Type,
) -> Result<(), ErrorStack> {
    unsafe {
        assert!(value.len() <= crate ::SLenType::MAX as usize);
        cvt(
                ffi::X509_NAME_add_entry_by_NID(
                    self.0.as_ptr(),
                    field.as_raw(),
                    ty.as_raw(),
                    value.as_ptr() as *mut _,
                    value.len() as crate::SLenType,
                    -1,
                    0,
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: load_client_ca_file,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in load_client_ca_file:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1212, End Line: 1215
/// Loads subject names from a file containing PEM-formatted certificates.
///
/// This is commonly used in conjunction with `SslContextBuilder::set_client_ca_list`.
pub fn load_client_ca_file<P: AsRef<Path>>(
    file: P,
) -> Result<Stack<X509Name>, ErrorStack> {
    let file = CString::new(file.as_ref().as_os_str().to_str().unwrap()).unwrap();
    unsafe {
        cvt_p(ffi::SSL_load_client_CA_file(file.as_ptr())).map(|p| Stack::from_ptr(p))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: try_cmp,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in try_cmp:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1259, End Line: 1265
/// Compare two names, like [`Ord`] but it may fail.
///
/// With OpenSSL versions from 3.0.0 this may return an error if the underlying `X509_NAME_cmp`
/// call fails.
/// For OpenSSL versions before 3.0.0 it will never return an error, but due to a bug it may
/// spuriously return `Ordering::Less` if the `X509_NAME_cmp` call fails.
#[corresponds(X509_NAME_cmp)]
pub fn try_cmp(&self, other: &X509NameRef) -> Result<Ordering, ErrorStack> {
    let cmp = unsafe { ffi::X509_NAME_cmp(self.as_ptr(), other.as_ptr()) };
    if cfg!(ossl300) && cmp == -2 {
        return Err(ErrorStack::get());
    }
    Ok(cmp.cmp(&0))
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: next,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in next:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1301, End Line: 1325
fn next(&mut self) -> Option<&'a X509NameEntryRef> {
    unsafe {
        match self.nid {
            Some(nid) => {
                self.loc = ffi::X509_NAME_get_index_by_NID(
                    self.name.as_ptr(),
                    nid.as_raw(),
                    self.loc,
                );
                if self.loc == -1 {
                    return None;
                }
            }
            None => {
                self.loc += 1;
                if self.loc >= ffi::X509_NAME_entry_count(self.name.as_ptr()) {
                    return None;
                }
            }
        }
        let entry = ffi::X509_NAME_get_entry(self.name.as_ptr(), self.loc);
        Some(
            X509NameEntryRef::from_const_ptr_opt(entry).expect("entry must not be null"),
        )
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: data,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in data:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1344, End Line: 1349
/// Returns the field value of an `X509NameEntry`.
///
/// This corresponds to [`X509_NAME_ENTRY_get_data`].
///
/// [`X509_NAME_ENTRY_get_data`]: https://www.openssl.org/docs/manmaster/crypto/X509_NAME_ENTRY_get_data.html
pub fn data(&self) -> &Asn1StringRef {
    unsafe {
        let data = ffi::X509_NAME_ENTRY_get_data(self.as_ptr());
        Asn1StringRef::from_ptr(data)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: object,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in object:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1357, End Line: 1362
/// Returns the `Asn1Object` value of an `X509NameEntry`.
/// This is useful for finding out about the actual `Nid` when iterating over all `X509NameEntries`.
///
/// This corresponds to [`X509_NAME_ENTRY_get_object`].
///
/// [`X509_NAME_ENTRY_get_object`]: https://www.openssl.org/docs/manmaster/crypto/X509_NAME_ENTRY_get_object.html
pub fn object(&self) -> &Asn1ObjectRef {
    unsafe {
        let object = ffi::X509_NAME_ENTRY_get_object(self.as_ptr());
        Asn1ObjectRef::from_ptr(object)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: add_extensions,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in add_extensions:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1455, End Line: 1466
/// Permits any number of extension fields to be added to the certificate.
pub fn add_extensions(
    &mut self,
    extensions: &StackRef<X509Extension>,
) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::X509_REQ_add_extensions(self.0.as_ptr(), extensions.as_ptr()))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: extensions,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in extensions:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1615, End Line: 1620
/// Returns the extensions of the certificate request.
///
/// This corresponds to [`X509_REQ_get_extensions"]
pub fn extensions(&self) -> Result<Stack<X509Extension>, ErrorStack> {
    unsafe {
        let extensions = cvt_p(ffi::X509_REQ_get_extensions(self.as_ptr()))?;
        Ok(Stack::from_ptr(extensions))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: revocation_date,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in revocation_date:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1692, End Line: 1698
/// Get the date that the certificate was revoked
#[corresponds(X509_REVOKED_get0_revocationDate)]
pub fn revocation_date(&self) -> &Asn1TimeRef {
    unsafe {
        let r = X509_REVOKED_get0_revocationDate(self.as_ptr() as *const _);
        assert!(! r.is_null());
        Asn1TimeRef::from_ptr(r as *mut _)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: true, Name: extension,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: get_revoked,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in get_revoked:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1868, End Line: 1877
/// Get the stack of revocation entries
pub fn get_revoked(&self) -> Option<&StackRef<X509Revoked>> {
    unsafe {
        let revoked = X509_CRL_get_REVOKED(self.as_ptr());
        if revoked.is_null() { None } else { Some(StackRef::from_ptr(revoked)) }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: last_update,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in last_update:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1881, End Line: 1887
/// Returns the CRL's `lastUpdate` time.
#[corresponds(X509_CRL_get0_lastUpdate)]
pub fn last_update(&self) -> &Asn1TimeRef {
    unsafe {
        let date = X509_CRL_get0_lastUpdate(self.as_ptr());
        assert!(! date.is_null());
        Asn1TimeRef::from_ptr(date as *mut _)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: next_update,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in next_update:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1893, End Line: 1898
/// Returns the CRL's `nextUpdate` time.
///
/// If the `nextUpdate` field is missing, returns `None`.
#[corresponds(X509_CRL_get0_nextUpdate)]
pub fn next_update(&self) -> Option<&Asn1TimeRef> {
    unsafe {
        let date = X509_CRL_get0_nextUpdate(self.as_ptr());
        Asn1TimeRef::from_const_ptr_opt(date)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: get_by_serial,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in get_by_serial:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1902, End Line: 1909
/// Get the revocation status of a certificate by its serial number
#[corresponds(X509_CRL_get0_by_serial)]
pub fn get_by_serial<'a>(&'a self, serial: &Asn1IntegerRef) -> CrlStatus<'a> {
    unsafe {
        let mut ret = ptr::null_mut::<ffi::X509_REVOKED>();
        let status = ffi::X509_CRL_get0_by_serial(
            self.as_ptr(),
            &mut ret as *mut _,
            serial.as_ptr(),
        );
        CrlStatus::from_ffi_status(status, ret)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: get_by_cert,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in get_by_cert:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 1913, End Line: 1920
/// Get the revocation status of a certificate
#[corresponds(X509_CRL_get0_by_cert)]
pub fn get_by_cert<'a>(&'a self, cert: &X509) -> CrlStatus<'a> {
    unsafe {
        let mut ret = ptr::null_mut::<ffi::X509_REVOKED>();
        let status = ffi::X509_CRL_get0_by_cert(
            self.as_ptr(),
            &mut ret as *mut _,
            cert.as_ptr(),
        );
        CrlStatus::from_ffi_status(status, ret)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: error_string,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in error_string:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 2021, End Line: 2028
/// Return a human readable error string from the verification error.
///
/// This corresponds to [`X509_verify_cert_error_string`].
///
/// [`X509_verify_cert_error_string`]: https://www.openssl.org/docs/manmaster/crypto/X509_verify_cert_error_string.html
#[allow(clippy::trivially_copy_pass_by_ref)]
pub fn error_string(&self) -> &'static str {
    ffi::init();
    unsafe {
        let s = ffi::X509_verify_cert_error_string(self.0 as c_long);
        str::from_utf8(CStr::from_ptr(s).to_bytes()).unwrap()
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: new_email,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in new_email:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 2071, End Line: 2073
pub(crate) fn new_email(email: &[u8]) -> Result<GeneralName, ErrorStack> {
    unsafe { GeneralName::new(ffi::GEN_EMAIL, Asn1Type::IA5STRING, email) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: new_dns,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in new_dns:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 2075, End Line: 2077
pub(crate) fn new_dns(dns: &[u8]) -> Result<GeneralName, ErrorStack> {
    unsafe { GeneralName::new(ffi::GEN_DNS, Asn1Type::IA5STRING, dns) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: new_uri,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in new_uri:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 2079, End Line: 2081
pub(crate) fn new_uri(uri: &[u8]) -> Result<GeneralName, ErrorStack> {
    unsafe { GeneralName::new(ffi::GEN_URI, Asn1Type::IA5STRING, uri) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: new_ip,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: new_ip,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in new_ip:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 2083, End Line: 2092
pub(crate) fn new_ip(ip: IpAddr) -> Result<GeneralName, ErrorStack> {
    match ip {
        IpAddr::V4(addr) => {
            unsafe {
                GeneralName::new(ffi::GEN_IPADD, Asn1Type::OCTET_STRING, &addr.octets())
            }
        }
        IpAddr::V6(addr) => {
            unsafe {
                GeneralName::new(ffi::GEN_IPADD, Asn1Type::OCTET_STRING, &addr.octets())
            }
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 7 statements, Complex: false, With_SAFETY_comment: false, Name: new_rid,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in new_rid:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 2094, End Line: 2113
pub(crate) fn new_rid(oid: Asn1Object) -> Result<GeneralName, ErrorStack> {
    unsafe {
        ffi::init();
        let gn = cvt_p(ffi::GENERAL_NAME_new())?;
        (*gn).type_ = ffi::GEN_RID;
        #[cfg(boringssl)]
        {
            (*gn).d.registeredID = oid.as_ptr();
        }
        #[cfg(not(boringssl))]
        {
            (*gn).d = oid.as_ptr().cast();
        }
        mem::forget(oid);
        Ok(GeneralName::from_ptr(gn))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 7 statements, Complex: true, With_SAFETY_comment: false, Name: new_other_name,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in new_other_name:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 2115, End Line: 2141
pub(crate) fn new_other_name(
    oid: Asn1Object,
    value: &[u8],
) -> Result<GeneralName, ErrorStack> {
    unsafe {
        ffi::init();
        let typ = cvt_p(
            ffi::d2i_ASN1_TYPE(
                ptr::null_mut(),
                &mut value.as_ptr().cast(),
                value.len().try_into().unwrap(),
            ),
        )?;
        let gn = cvt_p(ffi::GENERAL_NAME_new())?;
        (*gn).type_ = ffi::GEN_OTHERNAME;
        if let Err(e) = cvt(
            ffi::GENERAL_NAME_set0_othername(gn, oid.as_ptr().cast(), typ),
        ) {
            ffi::GENERAL_NAME_free(gn);
            return Err(e);
        }
        mem::forget(oid);
        Ok(GeneralName::from_ptr(gn))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 7 statements, Complex: true, With_SAFETY_comment: false, Name: ia5_string,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in ia5_string:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 2145, End Line: 2166
fn ia5_string(&self, ffi_type: c_int) -> Option<&str> {
    unsafe {
        if (*self.as_ptr()).type_ != ffi_type {
            return None;
        }
        #[cfg(boringssl)]
        let d = (*self.as_ptr()).d.ptr;
        #[cfg(not(boringssl))]
        let d = (*self.as_ptr()).d;
        let ptr = ASN1_STRING_get0_data(d as *mut _);
        let len = ffi::ASN1_STRING_length(d as *mut _);
        #[allow(clippy::unnecessary_cast)]
        let slice = slice::from_raw_parts(ptr as *const u8, len as usize);
        str::from_utf8(slice).ok()
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: true, With_SAFETY_comment: false, Name: directory_name,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in directory_name:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 2174, End Line: 2187
/// Returns the contents of this `GeneralName` if it is a `directoryName`.
pub fn directory_name(&self) -> Option<&X509NameRef> {
    unsafe {
        if (*self.as_ptr()).type_ != ffi::GEN_DIRNAME {
            return None;
        }
        #[cfg(boringssl)]
        let d = (*self.as_ptr()).d.ptr;
        #[cfg(not(boringssl))]
        let d = (*self.as_ptr()).d;
        Some(X509NameRef::from_const_ptr(d as *const _))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 6 statements, Complex: true, With_SAFETY_comment: false, Name: ipaddress,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in ipaddress:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 2200, End Line: 2216
/// Returns the contents of this `GeneralName` if it is an `iPAddress`.
pub fn ipaddress(&self) -> Option<&[u8]> {
    unsafe {
        if (*self.as_ptr()).type_ != ffi::GEN_IPADD {
            return None;
        }
        #[cfg(boringssl)]
        let d: *const ffi::ASN1_STRING = std::mem::transmute((*self.as_ptr()).d);
        #[cfg(not(boringssl))]
        let d = (*self.as_ptr()).d;
        let ptr = ASN1_STRING_get0_data(d as *mut _);
        let len = ffi::ASN1_STRING_length(d as *mut _);
        #[allow(clippy::unnecessary_cast)]
        Some(slice::from_raw_parts(ptr as *const u8, len as usize))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: distpoint,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in distpoint:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 2257, End Line: 2259
/// Returns the name of this distribution point if it exists
pub fn distpoint(&self) -> Option<&DistPointNameRef> {
    unsafe { DistPointNameRef::from_const_ptr_opt((*self.as_ptr()).distpoint) }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: fullname,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in fullname:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 2274, End Line: 2281
/// Returns the contents of this DistPointName if it is a fullname.
pub fn fullname(&self) -> Option<&StackRef<GeneralName>> {
    unsafe {
        if (*self.as_ptr()).type_ != 0 {
            return None;
        }
        StackRef::from_const_ptr_opt((*self.as_ptr()).name.fullname)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: method,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in method:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 2300, End Line: 2302
/// Returns the access method OID.
pub fn method(&self) -> &Asn1ObjectRef {
    unsafe { Asn1ObjectRef::from_ptr((*self.as_ptr()).method) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: location,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in location:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 2305, End Line: 2307
pub fn location(&self) -> &GeneralNameRef {
    unsafe { GeneralNameRef::from_ptr((*self.as_ptr()).location) }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: x509,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in x509:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 2346, End Line: 2351
pub fn x509(&self) -> Option<&X509Ref> {
    unsafe {
        let ptr = X509_OBJECT_get0_X509(self.as_ptr());
        X509Ref::from_const_ptr_opt(ptr)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: get_by_sname,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in get_by_sname:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 2550, End Line: 2562
/// Get the internal table index of an X509_PURPOSE for a given short name. Valid short
/// names include
///  - "sslclient",
///  - "sslserver",
///  - "nssslserver",
///  - "smimesign",
///  - "smimeencrypt",
///  - "crlsign",
///  - "any",
///  - "ocsphelper",
///  - "timestampsign"
/// The index can be used with `X509PurposeRef::from_idx()` to get the purpose.
#[allow(clippy::unnecessary_cast)]
pub fn get_by_sname(sname: &str) -> Result<c_int, ErrorStack> {
    unsafe {
        let sname = CString::new(sname).unwrap();
        cfg_if! {
            if #[cfg(any(ossl110, libressl280, boringssl))] { let purpose =
            cvt_n(ffi::X509_PURPOSE_get_by_sname(sname.as_ptr() as * const _)) ?; } else
            { let purpose = cvt_n(ffi::X509_PURPOSE_get_by_sname(sname.as_ptr() as * mut
            _)) ?; }
        }
        Ok(purpose)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: from_idx,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in from_idx:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 2566, End Line: 2571
/// Get an `X509PurposeRef` for a given index value. The index can be obtained from e.g.
/// `X509PurposeRef::get_by_sname()`.
#[corresponds(X509_PURPOSE_get0)]
pub fn from_idx(idx: c_int) -> Result<&'static X509PurposeRef, ErrorStack> {
    unsafe {
        let ptr = cvt_p_const(ffi::X509_PURPOSE_get0(idx))?;
        Ok(X509PurposeRef::from_const_ptr(ptr))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: purpose,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs

Found method with unsafe block in purpose:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\mod.rs
Start Line: 2583, End Line: 2594
/// Get the purpose value from an X509Purpose structure. This value is one of
/// - `X509_PURPOSE_SSL_CLIENT`
/// - `X509_PURPOSE_SSL_SERVER`
/// - `X509_PURPOSE_NS_SSL_SERVER`
/// - `X509_PURPOSE_SMIME_SIGN`
/// - `X509_PURPOSE_SMIME_ENCRYPT`
/// - `X509_PURPOSE_CRL_SIGN`
/// - `X509_PURPOSE_ANY`
/// - `X509_PURPOSE_OCSP_HELPER`
/// - `X509_PURPOSE_TIMESTAMP_SIGN`
pub fn purpose(&self) -> X509PurposeId {
    unsafe {
        cfg_if! {
            if #[cfg(any(ossl110, libressl280, boringssl))] { let x509_purpose = self
            .as_ptr() as * const ffi::X509_PURPOSE; } else { let x509_purpose = self
            .as_ptr() as * mut ffi::X509_PURPOSE; }
        }
        X509PurposeId::from_raw(ffi::X509_PURPOSE_get_id(x509_purpose))
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs
-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs
Start Line: 80, End Line: 86
/// Returns a builder for a certificate store.
///
/// The store is initially empty.
#[corresponds(X509_STORE_new)]
pub fn new() -> Result<X509StoreBuilder, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(ffi::X509_STORE_new()).map(X509StoreBuilder)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: add_cert,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs

Found method with unsafe block in add_cert:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs
Start Line: 100, End Line: 102
/// Adds a certificate to the certificate store.
#[corresponds(X509_STORE_add_cert)]
pub fn add_cert(&mut self, cert: X509) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::X509_STORE_add_cert(self.as_ptr(), cert.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_default_paths,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs

Found method with unsafe block in set_default_paths:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs
Start Line: 110, End Line: 112
/// Load certificates from their default locations.
///
/// These locations are read from the `SSL_CERT_FILE` and `SSL_CERT_DIR`
/// environment variables if present, or defaults specified at OpenSSL
/// build time otherwise.
#[corresponds(X509_STORE_set_default_paths)]
pub fn set_default_paths(&mut self) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::X509_STORE_set_default_paths(self.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: add_lookup,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs

-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: add_lookup,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs

Found method with unsafe block in add_lookup:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs
Start Line: 116, End Line: 122
/// Adds a lookup method to the store.
#[corresponds(X509_STORE_add_lookup)]
pub fn add_lookup<T>(
    &mut self,
    method: &'static X509LookupMethodRef<T>,
) -> Result<&mut X509LookupRef<T>, ErrorStack> {
    let lookup = unsafe { ffi::X509_STORE_add_lookup(self.as_ptr(), method.as_ptr()) };
    cvt_p(lookup).map(|ptr| unsafe { X509LookupRef::from_ptr_mut(ptr) })
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_flags,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs

Found method with unsafe block in set_flags:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs
Start Line: 127, End Line: 129
/// Sets certificate chain validation related flags.
#[corresponds(X509_STORE_set_flags)]
#[cfg(any(ossl102, boringssl, libressl261))]
pub fn set_flags(&mut self, flags: X509VerifyFlags) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::X509_STORE_set_flags(self.as_ptr(), flags.bits())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_purpose,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs

Found method with unsafe block in set_purpose:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs
Start Line: 134, End Line: 136
/// Sets the certificate purpose.
/// The purpose value can be obtained by `X509PurposeRef::get_by_sname()`
#[corresponds(X509_STORE_set_purpose)]
pub fn set_purpose(&mut self, purpose: X509PurposeId) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::X509_STORE_set_purpose(self.as_ptr(), purpose.as_raw())).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_param,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs

Found method with unsafe block in set_param:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs
Start Line: 141, End Line: 143
/// Sets certificate chain validation related parameters.
#[corresponds[X509_STORE_set1_param]]
#[cfg(any(ossl102, boringssl, libressl261))]
pub fn set_param(&mut self, param: &X509VerifyParamRef) -> Result<(), ErrorStack> {
    unsafe { cvt(ffi::X509_STORE_set1_param(self.as_ptr(), param.as_ptr())).map(|_| ()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: hash_dir,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs

Found method with unsafe block in hash_dir:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs
Start Line: 168, End Line: 170
/// Lookup method that loads certificates and CRLs on demand and caches
/// them in memory once they are loaded. It also checks for newer CRLs upon
/// each lookup, so that newer CRLs are used as soon as they appear in the
/// directory.
#[corresponds(X509_LOOKUP_hash_dir)]
pub fn hash_dir() -> &'static X509LookupMethodRef<HashDir> {
    unsafe { X509LookupMethodRef::from_const_ptr(ffi::X509_LOOKUP_hash_dir()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: add_dir,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs

Found method with unsafe block in add_dir:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs
Start Line: 178, End Line: 188
/// Specifies a directory from which certificates and CRLs will be loaded
/// on-demand. Must be used with `X509Lookup::hash_dir`.
#[corresponds(X509_LOOKUP_add_dir)]
pub fn add_dir(&mut self, name: &str, file_type: SslFiletype) -> Result<(), ErrorStack> {
    let name = CString::new(name).unwrap();
    unsafe {
        cvt(ffi::X509_LOOKUP_add_dir(self.as_ptr(), name.as_ptr(), file_type.as_raw()))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: file,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs

Found method with unsafe block in file:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs
Start Line: 200, End Line: 202
/// Lookup method loads all the certificates or CRLs present in a file
/// into memory at the time the file is added as a lookup source.
#[corresponds(X509_LOOKUP_file)]
pub fn file() -> &'static X509LookupMethodRef<File> {
    unsafe { X509LookupMethodRef::from_const_ptr(ffi::X509_LOOKUP_file()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: load_cert_file,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs

Found method with unsafe block in load_cert_file:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs
Start Line: 210, End Line: 224
/// Specifies a file from which certificates will be loaded
#[corresponds(X509_load_cert_file)]
pub fn load_cert_file<P: AsRef<Path>>(
    &mut self,
    file: P,
    file_type: SslFiletype,
) -> Result<(), ErrorStack> {
    let file = CString::new(file.as_ref().as_os_str().to_str().unwrap()).unwrap();
    unsafe {
        cvt(ffi::X509_load_cert_file(self.as_ptr(), file.as_ptr(), file_type.as_raw()))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: load_crl_file,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs

Found method with unsafe block in load_crl_file:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs
Start Line: 228, End Line: 241
/// Specifies a file from which certificate revocation lists will be loaded
#[corresponds(X509_load_crl_file)]
pub fn load_crl_file<P: AsRef<Path>>(
    &mut self,
    file: P,
    file_type: SslFiletype,
) -> Result<i32, ErrorStack> {
    let file = CString::new(file.as_ref().as_os_str().to_str().unwrap()).unwrap();
    unsafe {
        cvt(ffi::X509_load_crl_file(self.as_ptr(), file.as_ptr(), file_type.as_raw()))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: objects,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs

Found method with unsafe block in objects:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs
Start Line: 274, End Line: 276
/// Get a reference to the cache of certificates in this store.
///
/// This method is deprecated. It is **unsound** and will be removed in a
/// future version of rust-openssl. `X509StoreRef::all_certificates`
/// should be used instead.
#[deprecated(
    note = "This method is unsound, and will be removed in a future version of rust-openssl. X509StoreRef::all_certificates should be used instead."
)]
#[corresponds(X509_STORE_get0_objects)]
pub fn objects(&self) -> &StackRef<X509Object> {
    unsafe { StackRef::from_ptr(X509_STORE_get0_objects(self.as_ptr())) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: all_certificates,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs

Found method with unsafe block in all_certificates:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\store.rs
Start Line: 281, End Line: 283
/// Returns a stack of all the certificates in this store.
#[corresponds(X509_STORE_get1_all_certs)]
#[cfg(ossl300)]
pub fn all_certificates(&self) -> Stack<X509> {
    unsafe { Stack::from_ptr(ffi::X509_STORE_get1_all_certs(self.as_ptr())) }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\tests.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs
-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs
Start Line: 81, End Line: 86
/// Create an X509VerifyParam
#[corresponds(X509_VERIFY_PARAM_new)]
pub fn new() -> Result<X509VerifyParam, ErrorStack> {
    unsafe {
        ffi::init();
        cvt_p(ffi::X509_VERIFY_PARAM_new()).map(X509VerifyParam)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_hostflags,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs

Found method with unsafe block in set_hostflags:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs
Start Line: 92, End Line: 96
/// Set the host flags.
#[corresponds(X509_VERIFY_PARAM_set_hostflags)]
pub fn set_hostflags(&mut self, hostflags: X509CheckFlags) {
    unsafe {
        ffi::X509_VERIFY_PARAM_set_hostflags(self.as_ptr(), hostflags.bits());
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_flags,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs

Found method with unsafe block in set_flags:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs
Start Line: 100, End Line: 108
/// Set verification flags.
#[corresponds(X509_VERIFY_PARAM_set_flags)]
pub fn set_flags(&mut self, flags: X509VerifyFlags) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::X509_VERIFY_PARAM_set_flags(self.as_ptr(), flags.bits())).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: clear_flags,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs

Found method with unsafe block in clear_flags:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs
Start Line: 112, End Line: 120
/// Clear verification flags.
#[corresponds(X509_VERIFY_PARAM_clear_flags)]
pub fn clear_flags(&mut self, flags: X509VerifyFlags) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::X509_VERIFY_PARAM_clear_flags(self.as_ptr(), flags.bits())).map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: flags,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs

Found method with unsafe block in flags:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs
Start Line: 124, End Line: 127
/// Gets verification flags.
#[corresponds(X509_VERIFY_PARAM_get_flags)]
pub fn flags(&mut self) -> X509VerifyFlags {
    let bits = unsafe { ffi::X509_VERIFY_PARAM_get_flags(self.as_ptr()) };
    X509VerifyFlags::from_bits_retain(bits)
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_host,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs

Found method with unsafe block in set_host:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs
Start Line: 131, End Line: 142
/// Set the expected DNS hostname.
#[corresponds(X509_VERIFY_PARAM_set1_host)]
pub fn set_host(&mut self, host: &str) -> Result<(), ErrorStack> {
    unsafe {
        let raw_host = if host.is_empty() { "\0" } else { host };
        cvt(
                ffi::X509_VERIFY_PARAM_set1_host(
                    self.as_ptr(),
                    raw_host.as_ptr() as *const _,
                    host.len(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: set_email,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs

Found method with unsafe block in set_email:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs
Start Line: 146, End Line: 157
/// Set the expected email address.
#[corresponds(X509_VERIFY_PARAM_set1_email)]
pub fn set_email(&mut self, email: &str) -> Result<(), ErrorStack> {
    unsafe {
        let raw_email = if email.is_empty() { "\0" } else { email };
        cvt(
                ffi::X509_VERIFY_PARAM_set1_email(
                    self.as_ptr(),
                    raw_email.as_ptr() as *const _,
                    email.len(),
                ),
            )
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: set_ip,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs

Found method with unsafe block in set_ip:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs
Start Line: 161, End Line: 181
/// Set the expected IPv4 or IPv6 address.
#[corresponds(X509_VERIFY_PARAM_set1_ip)]
pub fn set_ip(&mut self, ip: IpAddr) -> Result<(), ErrorStack> {
    unsafe {
        let mut buf = [0; 16];
        let len = match ip {
            IpAddr::V4(addr) => {
                buf[..4].copy_from_slice(&addr.octets());
                4
            }
            IpAddr::V6(addr) => {
                buf.copy_from_slice(&addr.octets());
                16
            }
        };
        cvt(ffi::X509_VERIFY_PARAM_set1_ip(self.as_ptr(), buf.as_ptr() as *const _, len))
            .map(|_| ())
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_time,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs

Found method with unsafe block in set_time:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs
Start Line: 185, End Line: 187
/// Set the verification time, where time is of type time_t, traditionaly defined as seconds since the epoch
#[corresponds(X509_VERIFY_PARAM_set_time)]
pub fn set_time(&mut self, time: time_t) {
    unsafe { ffi::X509_VERIFY_PARAM_set_time(self.as_ptr(), time) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_depth,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs

Found method with unsafe block in set_depth:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs
Start Line: 191, End Line: 193
/// Set the verification depth
#[corresponds(X509_VERIFY_PARAM_set_depth)]
pub fn set_depth(&mut self, depth: c_int) {
    unsafe { ffi::X509_VERIFY_PARAM_set_depth(self.as_ptr(), depth) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_auth_level,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs

Found method with unsafe block in set_auth_level:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs
Start Line: 198, End Line: 200
/// Sets the authentication security level to auth_level
#[corresponds(X509_VERIFY_PARAM_set_auth_level)]
#[cfg(ossl110)]
pub fn set_auth_level(&mut self, lvl: c_int) {
    unsafe { ffi::X509_VERIFY_PARAM_set_auth_level(self.as_ptr(), lvl) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: auth_level,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs

Found method with unsafe block in auth_level:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs
Start Line: 205, End Line: 207
/// Gets the current authentication security level
#[corresponds(X509_VERIFY_PARAM_get_auth_level)]
#[cfg(ossl110)]
pub fn auth_level(&self) -> i32 {
    unsafe { ffi::X509_VERIFY_PARAM_get_auth_level(self.as_ptr()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: set_purpose,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs

Found method with unsafe block in set_purpose:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl\src\x509\verify.rs
Start Line: 212, End Line: 214
/// Sets the verification purpose
#[corresponds(X509_VERIFY_PARAM_set_purpose)]
#[cfg(any(ossl102, boringssl))]
pub fn set_purpose(&mut self, purpose: X509PurposeId) -> Result<(), ErrorStack> {
    unsafe {
        cvt(ffi::X509_VERIFY_PARAM_set_purpose(self.as_ptr(), purpose.0)).map(|_| ())
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-errors\build.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-errors\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-errors\tests\test.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-macros\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\build\cfgs.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\build\find_normal.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\build\find_vendored.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\build\main.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\build\run_bindgen.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\aes.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\asn1.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\bio.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\bn.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\cms.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\crypto.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\dtls1.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\ec.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\err.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\evp.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\aes.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\asn1.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\bio.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\bn.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\cmac.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\cms.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\conf.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\crypto.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\dh.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\dsa.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\ec.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\err.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\evp.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\hmac.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\kdf.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\object.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\ocsp.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\params.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\pem.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\pkcs12.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\pkcs7.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\poly1305.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\provider.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\rand.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\rsa.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\safestack.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\sha.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\srtp.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\ssl.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\stack.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\tls1.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\x509.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\x509v3.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\handwritten\x509_vfy.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\lib.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: init,  File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\lib.rs

Found function with unsafe block in init:
File: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\lib.rs
Start Line: 26, End Line: 30
pub fn init() {
    unsafe {
        CRYPTO_library_init();
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\macros.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\obj_mac.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\ocsp.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\pem.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\pkcs7.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\rsa.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\sha.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\srtp.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\ssl.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\ssl3.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\tls1.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\types.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\x509.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\x509v3.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\openssl-sys\src\x509_vfy.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\systest\build.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-openssl-da7f26d59aaa74bb4c6eb9181807d6e56047df44\systest\src\main.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\benches\bench.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: next,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in next:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 251, End Line: 253
#[inline]
fn next(&mut self) -> Option<T> {
    self.iter.next().map(|reference| unsafe { ptr::read(reference) })
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: next_back,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in next_back:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 263, End Line: 265
#[inline]
fn next_back(&mut self) -> Option<T> {
    self.iter.next_back().map(|reference| unsafe { ptr::read(reference) })
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: new,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in new:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 406, End Line: 413
/// Construct an empty vector
#[inline]
pub fn new() -> SmallVec<A> {
    unsafe {
        SmallVec {
            capacity: 0,
            data: SmallVecData::from_inline(mem::uninitialized()),
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: from_vec,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in from_vec:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 448, End Line: 470
/// Construct a new `SmallVec` from a `Vec<A::Item>`.
///
/// Elements will be copied to the inline buffer if vec.capacity() <= A::size().
///
/// ```rust
/// use smallvec::SmallVec;
///
/// let vec = vec![1, 2, 3, 4, 5];
/// let small_vec: SmallVec<[_; 3]> = SmallVec::from_vec(vec);
///
/// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);
/// ```
#[inline]
pub fn from_vec(mut vec: Vec<A::Item>) -> SmallVec<A> {
    if vec.capacity() <= A::size() {
        unsafe {
            let mut data = SmallVecData::<A>::from_inline(mem::uninitialized());
            let len = vec.len();
            vec.set_len(0);
            ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut().ptr_mut(), len);
            SmallVec { capacity: len, data }
        }
    } else {
        let (ptr, cap, len) = (vec.as_mut_ptr(), vec.capacity(), vec.len());
        mem::forget(vec);
        SmallVec {
            capacity: cap,
            data: SmallVecData::from_heap(ptr, len),
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: from_buf_and_len,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in from_buf_and_len:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 504, End Line: 507
/// Constructs a new `SmallVec` on the stack from an `A` without
/// copying elements. Also sets the length, which must be less or
/// equal to the size of `buf`.
///
/// ```rust
/// use smallvec::SmallVec;
///
/// let buf = [1, 2, 3, 4, 5, 0, 0, 0];
/// let small_vec: SmallVec<_> = SmallVec::from_buf_and_len(buf, 5);
///
/// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);
/// ```
#[inline]
pub fn from_buf_and_len(buf: A, len: usize) -> SmallVec<A> {
    assert!(len <= A::size());
    unsafe { SmallVec::from_buf_and_len_unchecked(buf, len) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: true, With_SAFETY_comment: false, Name: triple,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in triple:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 569, End Line: 578
/// Returns a tuple with (data ptr, len, capacity)
/// Useful to get all SmallVec properties with a single check of the current storage variant.
#[inline]
fn triple(&self) -> (*const A::Item, usize, usize) {
    unsafe {
        if self.spilled() {
            let (ptr, len) = self.data.heap();
            (ptr, len, self.capacity)
        } else {
            (self.data.inline().ptr(), self.capacity, A::size())
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: true, With_SAFETY_comment: false, Name: triple_mut,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in triple_mut:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 582, End Line: 591
/// Returns a tuple with (data ptr, len ptr, capacity)
#[inline]
fn triple_mut(&mut self) -> (*mut A::Item, &mut usize, usize) {
    unsafe {
        if self.spilled() {
            let &mut (ptr, ref mut len_ptr) = self.data.heap_mut();
            (ptr, len_ptr, self.capacity)
        } else {
            (self.data.inline_mut().ptr_mut(), &mut self.capacity, A::size())
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: drain,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in drain:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 600, End Line: 613
/// Empty the vector and return an iterator over its former contents.
pub fn drain(&mut self) -> Drain<A::Item> {
    unsafe {
        let ptr = self.as_mut_ptr();
        let current_len = self.len();
        self.set_len(0);
        let slice = slice::from_raw_parts_mut(ptr, current_len);
        Drain { iter: slice.iter_mut() }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: true, With_SAFETY_comment: false, Name: pop,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in pop:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 631, End Line: 641
/// Remove an item from the end of the vector and return it, or None if empty.
#[inline]
pub fn pop(&mut self) -> Option<A::Item> {
    unsafe {
        let (ptr, len_ptr, _) = self.triple_mut();
        if *len_ptr == 0 {
            return None;
        }
        let last_index = *len_ptr - 1;
        *len_ptr = last_index;
        Some(ptr::read(ptr.offset(last_index as isize)))
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: true, With_SAFETY_comment: false, Name: grow,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in grow:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 646, End Line: 670
/// Re-allocate to set the capacity to `max(new_cap, inline_size())`.
///
/// Panics if `new_cap` is less than the vector's length.
pub fn grow(&mut self, new_cap: usize) {
    unsafe {
        let (ptr, &mut len, cap) = self.triple_mut();
        let unspilled = !self.spilled();
        assert!(new_cap >= len);
        if new_cap <= self.inline_size() {
            if unspilled {
                return;
            }
            self.data = SmallVecData::from_inline(mem::uninitialized());
            ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);
        } else if new_cap != cap {
            let mut vec = Vec::with_capacity(new_cap);
            let new_alloc = vec.as_mut_ptr();
            mem::forget(vec);
            ptr::copy_nonoverlapping(ptr, new_alloc, len);
            self.data = SmallVecData::from_heap(new_alloc, len);
            self.capacity = new_cap;
            if unspilled {
                return;
            }
        }
        deallocate(ptr, cap);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: shrink_to_fit,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in shrink_to_fit:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 710, End Line: 726
/// Shrink the capacity of the vector as much as possible.
///
/// When possible, this will move data from an external heap buffer to the vector's inline
/// storage.
pub fn shrink_to_fit(&mut self) {
    if !self.spilled() {
        return;
    }
    let len = self.len();
    if self.inline_size() >= len {
        unsafe {
            let (ptr, len) = self.data.heap();
            self.data = SmallVecData::from_inline(mem::uninitialized());
            ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);
            deallocate(ptr, self.capacity);
            self.capacity = len;
        }
    } else if self.capacity() > len {
        self.grow(len);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: true, With_SAFETY_comment: false, Name: truncate,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in truncate:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 735, End Line: 744
/// Shorten the vector, keeping the first `len` elements and dropping the rest.
///
/// If `len` is greater than or equal to the vector's current length, this has no
/// effect.
///
/// This does not re-allocate.  If you want the vector's capacity to shrink, call
/// `shrink_to_fit` after truncating.
pub fn truncate(&mut self, len: usize) {
    unsafe {
        let (ptr, len_ptr, _) = self.triple_mut();
        while len < *len_ptr {
            let last_index = *len_ptr - 1;
            *len_ptr = last_index;
            ptr::drop_in_place(ptr.offset(last_index as isize));
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: swap_remove,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in swap_remove:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 766, End Line: 770
/// Remove the element at position `index`, replacing it with the last element.
///
/// This does not preserve ordering, but is O(1).
///
/// Panics if `index` is out of bounds.
#[inline]
pub fn swap_remove(&mut self, index: usize) -> A::Item {
    let len = self.len();
    self.swap(len - 1, index);
    self.pop().unwrap_or_else(|| unsafe { unreachable() })
}



-----------------------------------------------------------------
Checking unsafe block with 8 statements, Complex: false, With_SAFETY_comment: false, Name: remove,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in remove:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 782, End Line: 793
/// Remove and return the element at position `index`, shifting all elements after it to the
/// left.
///
/// Panics if `index` is out of bounds.
pub fn remove(&mut self, index: usize) -> A::Item {
    unsafe {
        let (mut ptr, len_ptr, _) = self.triple_mut();
        let len = *len_ptr;
        assert!(index < len);
        *len_ptr = len - 1;
        ptr = ptr.offset(index as isize);
        let item = ptr::read(ptr);
        ptr::copy(ptr.offset(1), ptr, len - index - 1);
        item
    }
}



-----------------------------------------------------------------
Checking unsafe block with 7 statements, Complex: false, With_SAFETY_comment: false, Name: insert,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in insert:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 798, End Line: 810
/// Insert an element at position `index`, shifting all elements after it to the right.
///
/// Panics if `index` is out of bounds.
pub fn insert(&mut self, index: usize, element: A::Item) {
    self.reserve(1);
    unsafe {
        let (mut ptr, len_ptr, _) = self.triple_mut();
        let len = *len_ptr;
        assert!(index <= len);
        *len_ptr = len + 1;
        ptr = ptr.offset(index as isize);
        ptr::copy(ptr, ptr.offset(1), len - index);
        ptr::write(ptr, element);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 9 statements, Complex: true, With_SAFETY_comment: false, Name: insert_many,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in insert_many:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 814, End Line: 856
/// Insert multiple elements at position `index`, shifting all following elements toward the
/// back.
pub fn insert_many<I: IntoIterator<Item = A::Item>>(
    &mut self,
    index: usize,
    iterable: I,
) {
    let iter = iterable.into_iter();
    if index == self.len() {
        return self.extend(iter);
    }
    let (lower_size_bound, _) = iter.size_hint();
    assert!(lower_size_bound <= std::isize::MAX as usize);
    assert!(index + lower_size_bound >= index);
    self.reserve(lower_size_bound);
    unsafe {
        let old_len = self.len();
        assert!(index <= old_len);
        let mut ptr = self.as_mut_ptr().offset(index as isize);
        ptr::copy(ptr, ptr.offset(lower_size_bound as isize), old_len - index);
        self.set_len(index);
        let mut num_added = 0;
        for element in iter {
            let mut cur = ptr.offset(num_added as isize);
            if num_added >= lower_size_bound {
                self.reserve(1);
                ptr = self.as_mut_ptr().offset(index as isize);
                cur = ptr.offset(num_added as isize);
                ptr::copy(cur, cur.offset(1), old_len - index);
            }
            ptr::write(cur, element);
            num_added += 1;
        }
        if num_added < lower_size_bound {
            ptr::copy(
                ptr.offset(lower_size_bound as isize),
                ptr.offset(num_added as isize),
                old_len - index,
            );
        }
        self.set_len(old_len + num_added);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: into_vec,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in into_vec:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 860, End Line: 871
/// Convert a SmallVec to a Vec, without reallocating if the SmallVec has already spilled onto
/// the heap.
pub fn into_vec(self) -> Vec<A::Item> {
    if self.spilled() {
        unsafe {
            let (ptr, len) = self.data.heap();
            let v = Vec::from_raw_parts(ptr, len, self.capacity);
            mem::forget(self);
            v
        }
    } else {
        self.into_iter().collect()
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: into_inner,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in into_inner:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 877, End Line: 887
/// Convert the SmallVec into an `A` if possible. Otherwise return `Err(Self)`.
///
/// This method returns `Err(Self)` if the SmallVec is too short (and the `A` contains uninitialized elements),
/// or if the SmallVec is too long (and all the elements were spilled to the heap).
pub fn into_inner(self) -> Result<A, Self> {
    if self.spilled() || self.len() != A::size() {
        Err(self)
    } else {
        unsafe {
            let data = ptr::read(&self.data);
            mem::forget(self);
            Ok(data.into_inline())
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: true, With_SAFETY_comment: false, Name: dedup_by,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in dedup_by:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 913, End Line: 941
/// Removes consecutive duplicate elements using the given equality relation.
pub fn dedup_by<F>(&mut self, mut same_bucket: F)
where
    F: FnMut(&mut A::Item, &mut A::Item) -> bool,
{
    let len = self.len();
    if len <= 1 {
        return;
    }
    let ptr = self.as_mut_ptr();
    let mut w: usize = 1;
    unsafe {
        for r in 1..len {
            let p_r = ptr.offset(r as isize);
            let p_wm1 = ptr.offset((w - 1) as isize);
            if !same_bucket(&mut *p_r, &mut *p_wm1) {
                if r != w {
                    let p_w = p_wm1.offset(1);
                    mem::swap(&mut *p_r, &mut *p_w);
                }
                w += 1;
            }
        }
    }
    self.truncate(w);
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: from_slice,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in from_slice:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 1036, End Line: 1056
/// Copy the elements from a slice into a new `SmallVec`.
///
/// For slices of `Copy` types, this is more efficient than `SmallVec::from(slice)`.
pub fn from_slice(slice: &[A::Item]) -> Self {
    let len = slice.len();
    if len <= A::size() {
        SmallVec {
            capacity: len,
            data: SmallVecData::from_inline(unsafe {
                let mut data: A = mem::uninitialized();
                ptr::copy_nonoverlapping(slice.as_ptr(), data.ptr_mut(), len);
                data
            }),
        }
    } else {
        let mut b = slice.to_vec();
        let (ptr, cap) = (b.as_mut_ptr(), b.capacity());
        mem::forget(b);
        SmallVec {
            capacity: cap,
            data: SmallVecData::from_heap(ptr, len),
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: insert_from_slice,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in insert_from_slice:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 1062, End Line: 1075
/// Copy elements from a slice into the vector at position `index`, shifting any following
/// elements toward the back.
///
/// For slices of `Copy` types, this is more efficient than `insert`.
pub fn insert_from_slice(&mut self, index: usize, slice: &[A::Item]) {
    self.reserve(slice.len());
    let len = self.len();
    assert!(index <= len);
    unsafe {
        let slice_ptr = slice.as_ptr();
        let ptr = self.as_mut_ptr().offset(index as isize);
        ptr::copy(ptr, ptr.offset(slice.len() as isize), len - index);
        ptr::copy_nonoverlapping(slice_ptr, ptr, slice.len());
        self.set_len(len + slice.len());
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: true, With_SAFETY_comment: false, Name: from_elem,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in from_elem:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 1111, End Line: 1127
/// Creates a `SmallVec` with `n` copies of `elem`.
/// ```
/// use smallvec::SmallVec;
///
/// let v = SmallVec::<[char; 128]>::from_elem('d', 2);
/// assert_eq!(v, SmallVec::from_buf(['d', 'd']));
/// ```
pub fn from_elem(elem: A::Item, n: usize) -> Self {
    if n > A::size() {
        vec![elem; n].into()
    } else {
        let mut v = SmallVec::<A>::new();
        unsafe {
            let (ptr, len_ptr, _) = v.triple_mut();
            let mut local_len = SetLenOnDrop::new(len_ptr);
            for i in 0..n as isize {
                ::std::ptr::write(ptr.offset(i), elem.clone());
                local_len.increment_len(1);
            }
        }
        v
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: deref,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in deref:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 1133, End Line: 1138
#[inline]
fn deref(&self) -> &[A::Item] {
    unsafe {
        let (ptr, len, _) = self.triple();
        slice::from_raw_parts(ptr, len)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 2 statements, Complex: false, With_SAFETY_comment: false, Name: deref_mut,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in deref_mut:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 1143, End Line: 1148
#[inline]
fn deref_mut(&mut self) -> &mut [A::Item] {
    unsafe {
        let (ptr, &mut len, _) = self.triple_mut();
        slice::from_raw_parts_mut(ptr, len)
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: true, With_SAFETY_comment: false, Name: extend,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in extend:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 1345, End Line: 1366
fn extend<I: IntoIterator<Item = A::Item>>(&mut self, iterable: I) {
    let mut iter = iterable.into_iter();
    let (lower_size_bound, _) = iter.size_hint();
    self.reserve(lower_size_bound);
    unsafe {
        let (ptr, len_ptr, cap) = self.triple_mut();
        let mut len = SetLenOnDrop::new(len_ptr);
        while len.get() < cap {
            if let Some(out) = iter.next() {
                ptr::write(ptr.offset(len.get() as isize), out);
                len.increment_len(1);
            } else {
                break;
            }
        }
    }
    for elem in iter {
        self.push(elem);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: into_iter,  File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs

Found method with unsafe block in into_iter:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 1513, End Line: 1524
fn into_iter(mut self) -> Self::IntoIter {
    unsafe {
        let len = self.len();
        self.set_len(0);
        IntoIter {
            data: self,
            current: 0,
            end: len,
        }
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\build.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: next,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in next:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 216, End Line: 218
#[inline]
fn next(&mut self) -> Option<T> {
    self.iter.next().map(|reference| unsafe { ptr::read(reference) })
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: next_back,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in next_back:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 228, End Line: 230
#[inline]
fn next_back(&mut self) -> Option<T> {
    self.iter.next_back().map(|reference| unsafe { ptr::read(reference) })
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: from_vec,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in from_vec:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 325, End Line: 328
/// Construct a new `StackVec` from a `Vec<A::Item>`.
///
/// Elements will be copied to the inline buffer if vec.len() <= A::size().
///
/// ```rust
/// use stackvector::StackVec;
///
/// let vec = vec![1, 2, 3, 4, 5];
/// let stack_vec: StackVec<[_; 5]> = StackVec::from_vec(vec);
///
/// assert_eq!(&*stack_vec, &[1, 2, 3, 4, 5]);
/// ```
#[inline]
pub fn from_vec(vec: Vec<A::Item>) -> StackVec<A> {
    assert!(vec.len() <= A::size());
    unsafe { Self::from_vec_unchecked(vec) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: from_buf_and_len,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in from_buf_and_len:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 375, End Line: 378
/// Constructs a new `StackVec` on the stack from an `A` without
/// copying elements. Also sets the length, which must be less or
/// equal to the size of `buf`.
///
/// ```rust
/// use stackvector::StackVec;
///
/// let buf = [1, 2, 3, 4, 5, 0, 0, 0];
/// let stack_vec: StackVec<_> = StackVec::from_buf_and_len(buf, 5);
///
/// assert_eq!(&*stack_vec, &[1, 2, 3, 4, 5]);
/// ```
#[inline]
pub fn from_buf_and_len(buf: A, len: usize) -> StackVec<A> {
    assert!(len <= A::size());
    unsafe { StackVec::from_buf_and_len_unchecked(buf, len) }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: drain,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in drain:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 431, End Line: 440
/// Empty the vector and return an iterator over its former contents.
pub fn drain(&mut self) -> Drain<A::Item> {
    unsafe {
        let slice = slice::from_raw_parts_mut(self.as_mut_ptr(), self.len());
        self.set_len(0);
        Drain { iter: slice.iter_mut() }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: true, With_SAFETY_comment: false, Name: truncate,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in truncate:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 470, End Line: 477
/// Shorten the vector, keeping the first `len` elements and dropping the rest.
///
/// If `len` is greater than or equal to the vector's current length, this has no
/// effect.
/// `shrink_to_fit` after truncating.
pub fn truncate(&mut self, len: usize) {
    unsafe {
        while len < self.length {
            self.length -= 1;
            ptr::drop_in_place(self.as_mut_ptr().padd(self.length));
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: swap_remove,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in swap_remove:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 501, End Line: 505
/// Remove the element at position `index`, replacing it with the last element.
///
/// This does not preserve ordering, but is O(1).
///
/// Panics if `index` is out of bounds.
#[inline]
pub fn swap_remove(&mut self, index: usize) -> A::Item {
    let len = self.len();
    self.swap(len - 1, index);
    unsafe { self.pop().unchecked_unwrap() }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: false, With_SAFETY_comment: false, Name: remove,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in remove:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 517, End Line: 526
/// Remove and return the element at position `index`, shifting all elements after it to the
/// left.
///
/// Panics if `index` is out of bounds.
pub fn remove(&mut self, index: usize) -> A::Item {
    assert!(index < self.len());
    unsafe {
        self.length -= 1;
        let ptr = self.as_mut_ptr().padd(index);
        let item = ptr::read(ptr);
        ptr::copy(ptr.offset(1), ptr, self.length - index);
        item
    }
}



-----------------------------------------------------------------
Checking unsafe block with 4 statements, Complex: false, With_SAFETY_comment: false, Name: insert,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in insert:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 531, End Line: 539
/// Insert an element at position `index`, shifting all elements after it to the right.
///
/// Panics if `index` is out of bounds.
pub fn insert(&mut self, index: usize, element: A::Item) {
    assert!(index < self.len() && self.len() < self.capacity());
    unsafe {
        let ptr = self.as_mut_ptr().padd(index);
        ptr::copy(ptr, ptr.offset(1), self.length - index);
        ptr::write(ptr, element);
        self.length += 1;
    }
}



-----------------------------------------------------------------
Checking unsafe block with 9 statements, Complex: true, With_SAFETY_comment: false, Name: insert_many,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in insert_many:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 543, End Line: 585
/// Insert multiple elements at position `index`, shifting all following elements toward the
/// back.
pub fn insert_many<I: iter::IntoIterator<Item = A::Item>>(
    &mut self,
    index: usize,
    iterable: I,
) {
    let iter = iterable.into_iter();
    if index == self.len() {
        return self.extend(iter);
    }
    let (lower_size_bound, _) = iter.size_hint();
    assert!(lower_size_bound <= std::isize::MAX as usize);
    assert!(index + lower_size_bound >= index);
    assert!(self.len() + lower_size_bound <= self.capacity());
    unsafe {
        let old_len = self.len();
        assert!(index <= old_len);
        let mut ptr = self.as_mut_ptr().padd(index);
        ptr::copy(ptr, ptr.padd(lower_size_bound), old_len - index);
        self.set_len(index);
        let mut num_added = 0;
        for element in iter {
            let mut cur = ptr.padd(num_added);
            if num_added >= lower_size_bound {
                assert!(self.len() + 1 <= self.capacity());
                ptr = self.as_mut_ptr().padd(index);
                cur = ptr.padd(num_added);
                ptr::copy(cur, cur.padd(1), old_len - index);
            }
            ptr::write(cur, element);
            num_added += 1;
        }
        if num_added < lower_size_bound {
            ptr::copy(ptr.padd(lower_size_bound), ptr.padd(num_added), old_len - index);
        }
        self.set_len(old_len + num_added);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: into_inner,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in into_inner:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 593, End Line: 603
/// Convert the StackVec into an `A`.
pub fn into_inner(self) -> Result<A, Self> {
    if self.len() != A::size() {
        Err(self)
    } else {
        unsafe {
            let data = ptr::read(&self.data);
            mem::forget(self);
            Ok(mem::ManuallyDrop::into_inner(data))
        }
    }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: true, With_SAFETY_comment: false, Name: dedup_by,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in dedup_by:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 629, End Line: 657
/// Removes consecutive duplicate elements using the given equality relation.
pub fn dedup_by<F>(&mut self, mut same_bucket: F)
where
    F: FnMut(&mut A::Item, &mut A::Item) -> bool,
{
    let len = self.len();
    if len <= 1 {
        return;
    }
    let ptr = self.as_mut_ptr();
    let mut w: usize = 1;
    unsafe {
        for r in 1..len {
            let p_r = ptr.offset(r as isize);
            let p_wm1 = ptr.offset((w - 1) as isize);
            if !same_bucket(&mut *p_r, &mut *p_wm1) {
                if r != w {
                    let p_w = p_wm1.offset(1);
                    mem::swap(&mut *p_r, &mut *p_w);
                }
                w += 1;
            }
        }
    }
    self.truncate(w);
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: from_slice,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in from_slice:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 672, End Line: 682
/// Copy the elements from a slice into a new `StackVec`.
///
/// For slices of `Copy` types, this is more efficient than `StackVec::from(slice)`.
pub fn from_slice(slice: &[A::Item]) -> Self {
    assert!(slice.len() <= A::size());
    StackVec {
        length: slice.len(),
        data: unsafe {
            let mut data: A = mem::uninitialized();
            ptr::copy_nonoverlapping(slice.as_ptr(), data.ptr_mut(), slice.len());
            mem::ManuallyDrop::new(data)
        },
    }
}



-----------------------------------------------------------------
Checking unsafe block with 6 statements, Complex: false, With_SAFETY_comment: false, Name: insert_from_slice,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in insert_from_slice:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 688, End Line: 698
/// Copy elements from a slice into the vector at position `index`, shifting any following
/// elements toward the back.
///
/// For slices of `Copy` types, this is more efficient than `insert`.
pub fn insert_from_slice(&mut self, index: usize, slice: &[A::Item]) {
    assert!(index <= self.len() && self.len() + slice.len() <= self.capacity());
    unsafe {
        let len = self.len();
        let slice_ptr = slice.as_ptr();
        let ptr = self.as_mut_ptr().padd(index);
        ptr::copy(ptr, ptr.padd(slice.len()), len - index);
        ptr::copy_nonoverlapping(slice_ptr, ptr, slice.len());
        self.set_len(len + slice.len());
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: true, With_SAFETY_comment: false, Name: from_elem,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in from_elem:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 734, End Line: 746
/// Creates a `StackVec` with `n` copies of `elem`.
/// ```
/// use stackvector::StackVec;
///
/// let v = StackVec::<[char; 128]>::from_elem('d', 2);
/// assert_eq!(v, StackVec::from_buf(['d', 'd']));
/// ```
pub fn from_elem(elem: A::Item, n: usize) -> Self {
    assert!(n <= A::size());
    let mut v = StackVec::<A>::new();
    unsafe {
        let ptr = v.as_mut_ptr();
        let mut local_len = SetLenOnDrop::new(&mut v.length);
        for i in 0..n as isize {
            ptr::write(ptr.offset(i), elem.clone());
            local_len.increment_len(1);
        }
    }
    v
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: deref,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in deref:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 752, End Line: 756
#[inline]
fn deref(&self) -> &[A::Item] {
    unsafe { slice::from_raw_parts(self.data.ptr(), self.len()) }
}



-----------------------------------------------------------------
Checking unsafe block with 1 statements, Complex: false, With_SAFETY_comment: false, Name: deref_mut,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in deref_mut:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 761, End Line: 765
#[inline]
fn deref_mut(&mut self) -> &mut [A::Item] {
    unsafe { slice::from_raw_parts_mut(self.data.ptr_mut(), self.len()) }
}



-----------------------------------------------------------------
Checking unsafe block with 5 statements, Complex: true, With_SAFETY_comment: false, Name: extend,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in extend:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 896, End Line: 920
fn extend<I: iter::IntoIterator<Item = A::Item>>(&mut self, iterable: I) {
    let mut iter = iterable.into_iter();
    let (lower_bound, upper_bound) = iter.size_hint();
    let upper_bound = upper_bound.expect("iterable must provide upper bound.");
    assert!(self.len() + upper_bound <= self.capacity());
    unsafe {
        let len = self.len();
        let ptr = self.as_mut_ptr().padd(len);
        let mut count = 0;
        while count < lower_bound {
            if let Some(out) = iter.next() {
                ptr::write(ptr.padd(count), out);
                count += 1;
            } else {
                break;
            }
        }
        self.set_len(len + count);
    }
    for elem in iter {
        self.push(elem);
    }
}



-----------------------------------------------------------------
Checking unsafe block with 3 statements, Complex: false, With_SAFETY_comment: false, Name: into_iter,  File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

Found method with unsafe block in into_iter:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 1057, End Line: 1068
fn into_iter(mut self) -> Self::IntoIter {
    unsafe {
        let len = self.len();
        self.set_len(0);
        IntoIter {
            data: self,
            current: 0,
            end: len,
        }
    }
}



