Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\fuzz\fuzz_targets\fuzz_search.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\assignment.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\name.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\parse.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\search\attributes.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\search\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\search\outcome.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\search\refmap.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\source.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\state.rs
Overunsafe detected in function: from_bytes, file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\state.rs
Checking unsafe block with 1 statements, overunsafe: true, function: from_bytes, file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\state.rs
Found method with unsafe block in from_bytes:
File: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\src\state.rs
Start Line: 19, End Line: 28
/// Keep `input` as our value.
pub fn from_bytes(input: &'a [u8]) -> Self {
    Self(
        KStringRef::from_ref(
            #[allow(unsafe_code)]
            unsafe { std::str::from_utf8_unchecked(input) },
        ),
    )
}



Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\tests\assignment\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\tests\attributes.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\tests\parse\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\tests\search\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\gitoxide-a807dd1ffb05efd177700d065095249e6c4b3c68\gix-attributes\tests\state\mod.rs
Processing file: overunsafe库\存在overunsafe的rust库\insert_many-697ec9fb89a337e17ba45a95d8c0c246b0b627a6\src\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Overunsafe detected in function: use_read_unaligned, file: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Checking unsafe block with 2 statements, overunsafe: true, function: use_read_unaligned, file: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Found function with unsafe block in use_read_unaligned:
File: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Start Line: 9, End Line: 17
fn use_read_unaligned() {
    let data: [u8; 5] = [0x01, 0x00, 0x00, 0x00, 0x02];
    let unaligned_ptr = &data[1] as *const u8 as *const u32;
    unsafe {
        let value = ptr::read_unaligned(unaligned_ptr);
        println!("Value from read_unaligned: {}", value);
    }
}



Overunsafe detected in function: use_write_unaligned, file: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Checking unsafe block with 2 statements, overunsafe: true, function: use_write_unaligned, file: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Found function with unsafe block in use_write_unaligned:
File: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Start Line: 20, End Line: 28
fn use_write_unaligned() {
    let mut data: [u8; 5] = [0u8; 5];
    let unaligned_ptr = &mut data[1] as *mut u8 as *mut u32;
    unsafe {
        ptr::write_unaligned(unaligned_ptr, 0x12345678);
        println!("Data after write_unaligned: {:?}", data);
    }
}



Overunsafe detected in function: use_from_raw_parts, file: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Checking unsafe block with 2 statements, overunsafe: true, function: use_from_raw_parts, file: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Found function with unsafe block in use_from_raw_parts:
File: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Start Line: 31, End Line: 39
fn use_from_raw_parts() {
    let data: [u32; 4] = [1, 2, 3, 4];
    let ptr = data.as_ptr();
    unsafe {
        let slice = slice::from_raw_parts(ptr, 4);
        println!("Slice from from_raw_parts: {:?}", slice);
    }
}



Overunsafe detected in function: use_transmute, file: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Checking unsafe block with 2 statements, overunsafe: true, function: use_transmute, file: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Found function with unsafe block in use_transmute:
File: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Start Line: 42, End Line: 49
fn use_transmute() {
    let x: u32 = 42;
    unsafe {
        let y: f32 = mem::transmute(x);
        println!("Value after transmute: {}", y);
    }
}



Overunsafe detected in function: use_zeroed, file: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Checking unsafe block with 2 statements, overunsafe: true, function: use_zeroed, file: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Found function with unsafe block in use_zeroed:
File: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Start Line: 52, End Line: 57
fn use_zeroed() {
    unsafe {
        let x: u32 = mem::zeroed();
        println!("Value after zeroed: {}", x);
    }
}



Overunsafe detected in function: use_ptr_write, file: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Checking unsafe block with 2 statements, overunsafe: true, function: use_ptr_write, file: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Found function with unsafe block in use_ptr_write:
File: overunsafe库\存在overunsafe的rust库\lwz的overunsafe模式\unsafe_operations.rs
Start Line: 60, End Line: 68
fn use_ptr_write() {
    let mut x = 0;
    let ptr = &mut x as *mut i32;
    unsafe {
        ptr::write(ptr, 42);
        println!("Value after ptr::write: {}", x);
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-cpuid-72492c8c4ecaa2d18b2ab43471272325ee80c755\build.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-cpuid-72492c8c4ecaa2d18b2ab43471272325ee80c755\examples\cache.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-cpuid-72492c8c4ecaa2d18b2ab43471272325ee80c755\examples\cpu.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-cpuid-72492c8c4ecaa2d18b2ab43471272325ee80c755\examples\topology.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-cpuid-72492c8c4ecaa2d18b2ab43471272325ee80c755\examples\tsc_frequency.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-cpuid-72492c8c4ecaa2d18b2ab43471272325ee80c755\src\bin\cpuid.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-cpuid-72492c8c4ecaa2d18b2ab43471272325ee80c755\src\lib.rs
Checking unsafe block with 1 statements, overunsafe: false, function: cpuid_count, file: overunsafe库\存在overunsafe的rust库\rust-cpuid-72492c8c4ecaa2d18b2ab43471272325ee80c755\src\lib.rs
Overunsafe detected in function: as_bytes, file: overunsafe库\存在overunsafe的rust库\rust-cpuid-72492c8c4ecaa2d18b2ab43471272325ee80c755\src\lib.rs
Checking unsafe block with 1 statements, overunsafe: true, function: as_bytes, file: overunsafe库\存在overunsafe的rust库\rust-cpuid-72492c8c4ecaa2d18b2ab43471272325ee80c755\src\lib.rs
Found function with unsafe block in as_bytes:
File: overunsafe库\存在overunsafe的rust库\rust-cpuid-72492c8c4ecaa2d18b2ab43471272325ee80c755\src\lib.rs
Start Line: 88, End Line: 91
fn as_bytes(v: &u32) -> &[u8] {
    let start = v as *const u32 as *const u8;
    unsafe { slice::from_raw_parts(start, 4) }
}



Overunsafe detected in function: as_string, file: overunsafe库\存在overunsafe的rust库\rust-cpuid-72492c8c4ecaa2d18b2ab43471272325ee80c755\src\lib.rs
Checking unsafe block with 4 statements, overunsafe: true, function: as_string, file: overunsafe库\存在overunsafe的rust库\rust-cpuid-72492c8c4ecaa2d18b2ab43471272325ee80c755\src\lib.rs
Found method with unsafe block in as_string:
File: overunsafe库\存在overunsafe的rust库\rust-cpuid-72492c8c4ecaa2d18b2ab43471272325ee80c755\src\lib.rs
Start Line: 596, End Line: 604
/// Return vendor identification as human readable string.
pub fn as_string<'a>(&'a self) -> &'a str {
    unsafe {
        let brand_string_start = self as *const VendorInfo as *const u8;
        let slice = slice::from_raw_parts(brand_string_start, 3 * 4);
        let byte_array: &'a [u8] = transmute(slice);
        str::from_utf8_unchecked(byte_array)
    }
}



Overunsafe detected in function: processor_brand_string, file: overunsafe库\存在overunsafe的rust库\rust-cpuid-72492c8c4ecaa2d18b2ab43471272325ee80c755\src\lib.rs
Checking unsafe block with 5 statements, overunsafe: true, function: processor_brand_string, file: overunsafe库\存在overunsafe的rust库\rust-cpuid-72492c8c4ecaa2d18b2ab43471272325ee80c755\src\lib.rs
Found method with unsafe block in processor_brand_string:
File: overunsafe库\存在overunsafe的rust库\rust-cpuid-72492c8c4ecaa2d18b2ab43471272325ee80c755\src\lib.rs
Start Line: 4155, End Line: 4172
/// Retrieve processor brand string.
pub fn processor_brand_string<'a>(&'a self) -> Option<&'a str> {
    if self.leaf_is_supported(EAX_EXTENDED_BRAND_STRING) {
        Some(unsafe {
            let brand_string_start = &self.data[2] as *const CpuIdResult as *const u8;
            let mut slice = slice::from_raw_parts(brand_string_start, 3 * 4 * 4);
            match slice.iter().position(|&x| x == 0) {
                Some(index) => slice = slice::from_raw_parts(brand_string_start, index),
                None => {}
            }
            let byte_array: &'a [u8] = transmute(slice);
            str::from_utf8_unchecked(byte_array)
        })
    } else {
        None
    }
}



Processing file: overunsafe库\存在overunsafe的rust库\rust-cpuid-72492c8c4ecaa2d18b2ab43471272325ee80c755\src\tests.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\benches\bench.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 1 statements, overunsafe: false, function: next, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 1 statements, overunsafe: false, function: next_back, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 1 statements, overunsafe: false, function: new, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Overunsafe detected in function: from_vec, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 5 statements, overunsafe: true, function: from_vec, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Found method with unsafe block in from_vec:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 448, End Line: 470
/// Construct a new `SmallVec` from a `Vec<A::Item>`.
///
/// Elements will be copied to the inline buffer if vec.capacity() <= A::size().
///
/// ```rust
/// use smallvec::SmallVec;
///
/// let vec = vec![1, 2, 3, 4, 5];
/// let small_vec: SmallVec<[_; 3]> = SmallVec::from_vec(vec);
///
/// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);
/// ```
#[inline]
pub fn from_vec(mut vec: Vec<A::Item>) -> SmallVec<A> {
    if vec.capacity() <= A::size() {
        unsafe {
            let mut data = SmallVecData::<A>::from_inline(mem::uninitialized());
            let len = vec.len();
            vec.set_len(0);
            ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut().ptr_mut(), len);
            SmallVec { capacity: len, data }
        }
    } else {
        let (ptr, cap, len) = (vec.as_mut_ptr(), vec.capacity(), vec.len());
        mem::forget(vec);
        SmallVec {
            capacity: cap,
            data: SmallVecData::from_heap(ptr, len),
        }
    }
}



Checking unsafe block with 1 statements, overunsafe: false, function: from_buf_and_len, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 1 statements, overunsafe: false, function: triple, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 1 statements, overunsafe: false, function: triple_mut, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 5 statements, overunsafe: false, function: drain, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 5 statements, overunsafe: false, function: pop, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Overunsafe detected in function: grow, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 5 statements, overunsafe: true, function: grow, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Found method with unsafe block in grow:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 647, End Line: 671
/// Re-allocate to set the capacity to `max(new_cap, inline_size())`.
///
/// Panics if `new_cap` is less than the vector's length.
/// RUSTSEC-2019-0009与RUSTSEC-2019-0012
pub fn grow(&mut self, new_cap: usize) {
    unsafe {
        let (ptr, &mut len, cap) = self.triple_mut();
        let unspilled = !self.spilled();
        assert!(new_cap >= len);
        if new_cap <= self.inline_size() {
            if unspilled {
                return;
            }
            self.data = SmallVecData::from_inline(mem::uninitialized());
            ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);
        } else if new_cap != cap {
            let mut vec = Vec::with_capacity(new_cap);
            let new_alloc = vec.as_mut_ptr();
            mem::forget(vec);
            ptr::copy_nonoverlapping(ptr, new_alloc, len);
            self.data = SmallVecData::from_heap(new_alloc, len);
            self.capacity = new_cap;
            if unspilled {
                return;
            }
        }
        deallocate(ptr, cap);
    }
}



Overunsafe detected in function: shrink_to_fit, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 5 statements, overunsafe: true, function: shrink_to_fit, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Found method with unsafe block in shrink_to_fit:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 711, End Line: 727
/// Shrink the capacity of the vector as much as possible.
///
/// When possible, this will move data from an external heap buffer to the vector's inline
/// storage.
pub fn shrink_to_fit(&mut self) {
    if !self.spilled() {
        return;
    }
    let len = self.len();
    if self.inline_size() >= len {
        unsafe {
            let (ptr, len) = self.data.heap();
            self.data = SmallVecData::from_inline(mem::uninitialized());
            ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);
            deallocate(ptr, self.capacity);
            self.capacity = len;
        }
    } else if self.capacity() > len {
        self.grow(len);
    }
}



Checking unsafe block with 2 statements, overunsafe: false, function: truncate, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 1 statements, overunsafe: false, function: swap_remove, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Overunsafe detected in function: remove, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 8 statements, overunsafe: true, function: remove, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Found method with unsafe block in remove:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 783, End Line: 794
/// Remove and return the element at position `index`, shifting all elements after it to the
/// left.
///
/// Panics if `index` is out of bounds.
pub fn remove(&mut self, index: usize) -> A::Item {
    unsafe {
        let (mut ptr, len_ptr, _) = self.triple_mut();
        let len = *len_ptr;
        assert!(index < len);
        *len_ptr = len - 1;
        ptr = ptr.offset(index as isize);
        let item = ptr::read(ptr);
        ptr::copy(ptr.offset(1), ptr, len - index - 1);
        item
    }
}



Overunsafe detected in function: insert, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 7 statements, overunsafe: true, function: insert, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Found method with unsafe block in insert:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 799, End Line: 811
/// Insert an element at position `index`, shifting all elements after it to the right.
///
/// Panics if `index` is out of bounds.
pub fn insert(&mut self, index: usize, element: A::Item) {
    self.reserve(1);
    unsafe {
        let (mut ptr, len_ptr, _) = self.triple_mut();
        let len = *len_ptr;
        assert!(index <= len);
        *len_ptr = len + 1;
        ptr = ptr.offset(index as isize);
        ptr::copy(ptr, ptr.offset(1), len - index);
        ptr::write(ptr, element);
    }
}



Overunsafe detected in function: insert_many, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 9 statements, overunsafe: true, function: insert_many, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Found method with unsafe block in insert_many:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 815, End Line: 858
/// Insert multiple elements at position `index`, shifting all following elements toward the
/// back.
pub fn insert_many<I: IntoIterator<Item = A::Item>>(
    &mut self,
    index: usize,
    iterable: I,
) {
    let iter = iterable.into_iter();
    if index == self.len() {
        return self.extend(iter);
    }
    let (lower_size_bound, _) = iter.size_hint();
    assert!(lower_size_bound <= std::isize::MAX as usize);
    assert!(index + lower_size_bound >= index);
    self.reserve(lower_size_bound);
    unsafe {
        let old_len = self.len();
        assert!(index <= old_len);
        let mut ptr = self.as_mut_ptr().offset(index as isize);
        ptr::copy(ptr, ptr.offset(lower_size_bound as isize), old_len - index);
        self.set_len(index);
        let mut num_added = 0;
        for element in iter {
            let mut cur = ptr.offset(num_added as isize);
            if num_added >= lower_size_bound {
                self.reserve(1);
                ptr = self.as_mut_ptr().offset(index as isize);
                cur = ptr.offset(num_added as isize);
                ptr::copy(cur, cur.offset(1), old_len - index);
            }
            ptr::write(cur, element);
            num_added += 1;
        }
        if num_added < lower_size_bound {
            ptr::copy(
                ptr.offset(lower_size_bound as isize),
                ptr.offset(num_added as isize),
                old_len - index,
            );
        }
        self.set_len(old_len + num_added);
    }
}



Checking unsafe block with 4 statements, overunsafe: false, function: into_vec, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 3 statements, overunsafe: false, function: into_inner, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 3 statements, overunsafe: false, function: into_inner, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 1 statements, overunsafe: false, function: dedup_by, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Overunsafe detected in function: from_slice, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 3 statements, overunsafe: true, function: from_slice, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Found method with unsafe block in from_slice:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 1038, End Line: 1058
/// Copy the elements from a slice into a new `SmallVec`.
///
/// For slices of `Copy` types, this is more efficient than `SmallVec::from(slice)`.
pub fn from_slice(slice: &[A::Item]) -> Self {
    let len = slice.len();
    if len <= A::size() {
        SmallVec {
            capacity: len,
            data: SmallVecData::from_inline(unsafe {
                let mut data: A = mem::uninitialized();
                ptr::copy_nonoverlapping(slice.as_ptr(), data.ptr_mut(), len);
                data
            }),
        }
    } else {
        let mut b = slice.to_vec();
        let (ptr, cap) = (b.as_mut_ptr(), b.capacity());
        mem::forget(b);
        SmallVec {
            capacity: cap,
            data: SmallVecData::from_heap(ptr, len),
        }
    }
}



Overunsafe detected in function: insert_from_slice, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 5 statements, overunsafe: true, function: insert_from_slice, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Found method with unsafe block in insert_from_slice:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 1064, End Line: 1077
/// Copy elements from a slice into the vector at position `index`, shifting any following
/// elements toward the back.
///
/// For slices of `Copy` types, this is more efficient than `insert`.
pub fn insert_from_slice(&mut self, index: usize, slice: &[A::Item]) {
    self.reserve(slice.len());
    let len = self.len();
    assert!(index <= len);
    unsafe {
        let slice_ptr = slice.as_ptr();
        let ptr = self.as_mut_ptr().offset(index as isize);
        ptr::copy(ptr, ptr.offset(slice.len() as isize), len - index);
        ptr::copy_nonoverlapping(slice_ptr, ptr, slice.len());
        self.set_len(len + slice.len());
    }
}



Checking unsafe block with 3 statements, overunsafe: false, function: from_elem, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 3 statements, overunsafe: false, function: from_elem, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Overunsafe detected in function: deref, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 2 statements, overunsafe: true, function: deref, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Found method with unsafe block in deref:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 1135, End Line: 1140
#[inline]
fn deref(&self) -> &[A::Item] {
    unsafe {
        let (ptr, len, _) = self.triple();
        slice::from_raw_parts(ptr, len)
    }
}



Checking unsafe block with 2 statements, overunsafe: false, function: deref_mut, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Overunsafe detected in function: extend, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Checking unsafe block with 3 statements, overunsafe: true, function: extend, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Found method with unsafe block in extend:
File: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Start Line: 1347, End Line: 1368
fn extend<I: IntoIterator<Item = A::Item>>(&mut self, iterable: I) {
    let mut iter = iterable.into_iter();
    let (lower_size_bound, _) = iter.size_hint();
    self.reserve(lower_size_bound);
    unsafe {
        let (ptr, len_ptr, cap) = self.triple_mut();
        let mut len = SetLenOnDrop::new(len_ptr);
        while len.get() < cap {
            if let Some(out) = iter.next() {
                ptr::write(ptr.offset(len.get() as isize), out);
                len.increment_len(1);
            } else {
                break;
            }
        }
    }
    for elem in iter {
        self.push(elem);
    }
}



Checking unsafe block with 3 statements, overunsafe: false, function: into_iter, file: overunsafe库\存在overunsafe的rust库\rust-smallvec-19de50108d403efaa7cd979eac3bb97a4432fd4b\lib.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\build.rs
Processing file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Checking unsafe block with 1 statements, overunsafe: false, function: next, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Checking unsafe block with 1 statements, overunsafe: false, function: next_back, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Overunsafe detected in function: from_vec, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Checking unsafe block with 1 statements, overunsafe: true, function: from_vec, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Found method with unsafe block in from_vec:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 325, End Line: 328
/// Construct a new `StackVec` from a `Vec<A::Item>`.
///
/// Elements will be copied to the inline buffer if vec.len() <= A::size().
///
/// ```rust
/// use stackvector::StackVec;
///
/// let vec = vec![1, 2, 3, 4, 5];
/// let stack_vec: StackVec<[_; 5]> = StackVec::from_vec(vec);
///
/// assert_eq!(&*stack_vec, &[1, 2, 3, 4, 5]);
/// ```
#[inline]
pub fn from_vec(vec: Vec<A::Item>) -> StackVec<A> {
    assert!(vec.len() <= A::size());
    unsafe { Self::from_vec_unchecked(vec) }
}



Checking unsafe block with 1 statements, overunsafe: false, function: from_buf_and_len, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Checking unsafe block with 3 statements, overunsafe: false, function: drain, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Checking unsafe block with 1 statements, overunsafe: false, function: truncate, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Checking unsafe block with 1 statements, overunsafe: false, function: swap_remove, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Overunsafe detected in function: remove, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Checking unsafe block with 5 statements, overunsafe: true, function: remove, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Found method with unsafe block in remove:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 517, End Line: 526
/// Remove and return the element at position `index`, shifting all elements after it to the
/// left.
///
/// Panics if `index` is out of bounds.
pub fn remove(&mut self, index: usize) -> A::Item {
    assert!(index < self.len());
    unsafe {
        self.length -= 1;
        let ptr = self.as_mut_ptr().padd(index);
        let item = ptr::read(ptr);
        ptr::copy(ptr.offset(1), ptr, self.length - index);
        item
    }
}



Overunsafe detected in function: insert, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Checking unsafe block with 4 statements, overunsafe: true, function: insert, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Found method with unsafe block in insert:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 531, End Line: 539
/// Insert an element at position `index`, shifting all elements after it to the right.
///
/// Panics if `index` is out of bounds.
pub fn insert(&mut self, index: usize, element: A::Item) {
    assert!(index < self.len() && self.len() < self.capacity());
    unsafe {
        let ptr = self.as_mut_ptr().padd(index);
        ptr::copy(ptr, ptr.offset(1), self.length - index);
        ptr::write(ptr, element);
        self.length += 1;
    }
}



Overunsafe detected in function: insert_many, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Checking unsafe block with 9 statements, overunsafe: true, function: insert_many, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Found method with unsafe block in insert_many:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 543, End Line: 585
/// Insert multiple elements at position `index`, shifting all following elements toward the
/// back.
pub fn insert_many<I: iter::IntoIterator<Item = A::Item>>(
    &mut self,
    index: usize,
    iterable: I,
) {
    let iter = iterable.into_iter();
    if index == self.len() {
        return self.extend(iter);
    }
    let (lower_size_bound, _) = iter.size_hint();
    assert!(lower_size_bound <= std::isize::MAX as usize);
    assert!(index + lower_size_bound >= index);
    assert!(self.len() + lower_size_bound <= self.capacity());
    unsafe {
        let old_len = self.len();
        assert!(index <= old_len);
        let mut ptr = self.as_mut_ptr().padd(index);
        ptr::copy(ptr, ptr.padd(lower_size_bound), old_len - index);
        self.set_len(index);
        let mut num_added = 0;
        for element in iter {
            let mut cur = ptr.padd(num_added);
            if num_added >= lower_size_bound {
                assert!(self.len() + 1 <= self.capacity());
                ptr = self.as_mut_ptr().padd(index);
                cur = ptr.padd(num_added);
                ptr::copy(cur, cur.padd(1), old_len - index);
            }
            ptr::write(cur, element);
            num_added += 1;
        }
        if num_added < lower_size_bound {
            ptr::copy(ptr.padd(lower_size_bound), ptr.padd(num_added), old_len - index);
        }
        self.set_len(old_len + num_added);
    }
}



Checking unsafe block with 3 statements, overunsafe: false, function: into_inner, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Checking unsafe block with 3 statements, overunsafe: false, function: into_inner, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Checking unsafe block with 1 statements, overunsafe: false, function: dedup_by, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Overunsafe detected in function: from_slice, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Checking unsafe block with 3 statements, overunsafe: true, function: from_slice, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Found method with unsafe block in from_slice:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 672, End Line: 682
/// Copy the elements from a slice into a new `StackVec`.
///
/// For slices of `Copy` types, this is more efficient than `StackVec::from(slice)`.
pub fn from_slice(slice: &[A::Item]) -> Self {
    assert!(slice.len() <= A::size());
    StackVec {
        length: slice.len(),
        data: unsafe {
            let mut data: A = mem::uninitialized();
            ptr::copy_nonoverlapping(slice.as_ptr(), data.ptr_mut(), slice.len());
            mem::ManuallyDrop::new(data)
        },
    }
}



Overunsafe detected in function: insert_from_slice, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Checking unsafe block with 6 statements, overunsafe: true, function: insert_from_slice, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Found method with unsafe block in insert_from_slice:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 688, End Line: 698
/// Copy elements from a slice into the vector at position `index`, shifting any following
/// elements toward the back.
///
/// For slices of `Copy` types, this is more efficient than `insert`.
pub fn insert_from_slice(&mut self, index: usize, slice: &[A::Item]) {
    assert!(index <= self.len() && self.len() + slice.len() <= self.capacity());
    unsafe {
        let len = self.len();
        let slice_ptr = slice.as_ptr();
        let ptr = self.as_mut_ptr().padd(index);
        ptr::copy(ptr, ptr.padd(slice.len()), len - index);
        ptr::copy_nonoverlapping(slice_ptr, ptr, slice.len());
        self.set_len(len + slice.len());
    }
}



Overunsafe detected in function: from_elem, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Checking unsafe block with 3 statements, overunsafe: true, function: from_elem, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Found method with unsafe block in from_elem:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 734, End Line: 746
/// Creates a `StackVec` with `n` copies of `elem`.
/// ```
/// use stackvector::StackVec;
///
/// let v = StackVec::<[char; 128]>::from_elem('d', 2);
/// assert_eq!(v, StackVec::from_buf(['d', 'd']));
/// ```
pub fn from_elem(elem: A::Item, n: usize) -> Self {
    assert!(n <= A::size());
    let mut v = StackVec::<A>::new();
    unsafe {
        let ptr = v.as_mut_ptr();
        let mut local_len = SetLenOnDrop::new(&mut v.length);
        for i in 0..n as isize {
            ptr::write(ptr.offset(i), elem.clone());
            local_len.increment_len(1);
        }
    }
    v
}



Overunsafe detected in function: deref, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Checking unsafe block with 1 statements, overunsafe: true, function: deref, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Found method with unsafe block in deref:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 752, End Line: 756
#[inline]
fn deref(&self) -> &[A::Item] {
    unsafe { slice::from_raw_parts(self.data.ptr(), self.len()) }
}



Checking unsafe block with 1 statements, overunsafe: false, function: deref_mut, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Overunsafe detected in function: extend, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Checking unsafe block with 5 statements, overunsafe: true, function: extend, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Found method with unsafe block in extend:
File: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs
Start Line: 896, End Line: 921
fn extend<I: iter::IntoIterator<Item = A::Item>>(&mut self, iterable: I) {
    let mut iter = iterable.into_iter();
    let (lower_bound, upper_bound) = iter.size_hint();
    let upper_bound = upper_bound.expect("iterable must provide upper bound.");
    assert!(self.len() + upper_bound <= self.capacity());
    unsafe {
        let len = self.len();
        let ptr = self.as_mut_ptr().padd(len);
        let mut count = 0;
        while count < lower_bound {
            if let Some(out) = iter.next() {
                ptr::write(ptr.padd(count), out);
                count += 1;
            } else {
                break;
            }
        }
        self.set_len(len + count);
    }
    for elem in iter {
        self.push(elem);
    }
}



Checking unsafe block with 3 statements, overunsafe: false, function: into_iter, file: overunsafe库\存在overunsafe的rust库\rust-stackvector-d0382d5ef903fc96bdcc08c02e36e6dd2eda11a5\src\lib.rs

--- Summary ---
Total functions: 648
Total unsafe blocks: 59
Total unsafe blocks without SAFETY comment: 58
Total Potential Overunsafe function: 29
Potential Overunsafe function ratio: 4.48%
